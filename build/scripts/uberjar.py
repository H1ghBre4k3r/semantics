# KIELER - Kiel Integrated Environment for Layout Eclipse RichClient
# http://www.informatik.uni-kiel.de/rtsys/kieler/
#
# Copyright 2019 by
# + Kiel University
#   + Department of Computer Science
#     + Real-Time and Embedded Systems Group
#
# This code is provided under the terms of the Eclipse Public License (EPL).
# See the file epl-v10.html for the license text.

#
# This script bundles a self-contained eclipse update site into an executable uber-jar (no shading!) and several platform specific executable scripts bundling the jar.
# Author: Alexander Schulz-Rosengarten <als@informatik.uni-kiel.de>
#

# General Documentation:
# The idea of having an executable non-eclipse application with eclipse plugins is to bundle them into a uber/fat jar containing all dependencies.
# Usually this job is done by the maven-shade-plugin. However, since we build our plugins with tycho and have a defined target platform for dependency resolution, this system is incompatible with maven-shade. maven-shade would require to redefine each dependency explicitly and from a maven repository.
# Hence, we build a self-contained update side using tycho, this way we have all our dependencies automatically and correctly resolve without any redefinitions and we can build only specific plugins into the executable.
# Then this script bundles the jars in the update side into one uber jar.
# In contrast to maven-shade this script cannot 'shade' dependencies. If this should be necessary in the future, it might be a solution to process the update side by another build run using maven-shade and some pom file generated by a script to correctly defining the dependencies to include.

from __future__ import print_function # python3 print

import os
import stat
import sys
import shutil
import argparse
from subprocess import call, PIPE
from fnmatch import fnmatch
from os.path import isfile, isdir, join, abspath, relpath, dirname, basename

IGNORED_JARS = [
    'org.apache.ant*'
]
IGNORED_FILES = [
    'org/*/*.java',
    'com/*/*.java',
    'de/*/*.java',
    '**/*._trace',
    '**/*.g',
    '**/*.mwe2',
    '**/*.xtext'
    '*.html',
    '*.profile',
    '.api_description',
    '.options',
    'about.*',
    'about_files/*',
    'log4j.properties',
    'META-INF/*.DSA',
    'META-INF/*.RSA',
    'META-INF/*.SF',
    'META-INF/eclipse.inf',
    'META-INF/INDEX.LIST',
    'META-INF/MANIFEST.MF', # not sure if we have to merge the content somehow?
    'META-INF/maven/*',
    'META-INF/NOTICE.txt',
    'OSGI-INF/l10n/bundle.properties',
    'plugin.xml',
    'profile.list',
    'systembundle.properties',
    'xtend-gen/*'
]
APPEND_MERGE = [
    'plugin.properties',
    'META-INF/services/*',
    'META-INF/LICENSE.txt'
]
IGNORE_MERGE = [
    'eclipse32.png',
    'modeling32.png',
    'epl-v10.html',
    'org/osgi/service/log/*', # known duplicate in org.eclipse.osgi and org.eclipse.osgi.services
]

def main(args):
    print('-- Creating uber jar --')

    extracted = abspath(join(args.build, 'extracted'))
    merged = abspath(join(args.build, 'merged'))

    if not isdir(args.source):
        stop('%s is not a directory' % args.source)

    if isdir(extracted):
        shutil.rmtree(extracted)
    else:
        os.mkdir(extracted)
    if isdir(merged):
        shutil.rmtree(merged)
    else:
        os.mkdir(merged)

    # Extract
    for jar in sorted(os.listdir(args.source)):
        if not jar.endswith('.jar') or any(fnmatch(jar, ign) for ign in IGNORED_JARS):
            print('Skipping file: ', jar)
            continue
        else:
            print('Extracting jar: ', jar)
            target = abspath(join(extracted, jar[:-4]))
            if not isdir(target):
                os.makedirs(target)

            # Unpack jar
            call(['jar', 'xf', abspath(join(args.source, jar))], cwd=target)

            # Merge content
            for root, dirs, files in os.walk(target):
                for file in [file for file in [relpath(join(root, f), target) for f in files] if not any(fnmatch(file, pattern) for pattern in IGNORED_FILES)]:
                    src = join(target, file)
                    dest = join(merged, file)
                    if isfile(dest): # potential conflict
                        if any(fnmatch(file, match) for match in APPEND_MERGE): # merge by append
                            with open(src, 'r') as i:
                                with open(dest, 'a') as o:
                                    o.write('\n')
                                    o.write(i.read())
                        elif any(fnmatch(file, match) for match in IGNORE_MERGE): # merge by ignoring overriders, assuming identical files ;)
                            pass
                        else:
                            errPrint('[ERROR] Could not merge', jar, 'Conflicting file:', file)
                    else:
                        if not isdir(dirname(dest)):
                            os.makedirs(dirname(dest))
                        os.rename(src, dest)

    # Bundle
    traget_dir = abspath(args.target)
    jar = join(traget_dir, args.name + '.jar')
    print('Creating jar:', relpath(jar, args.target))
    if not isdir(dirname(jar)):
        os.makedirs(dirname(jar))
    call(['jar', 'cfe', jar, args.main, '.'], cwd=merged)

    # Wrapper scripts
    if args.scripts:
        # This is some magic found in the depth of the Internet by chsch
        print('-- Creating standalone scripts --')
        java9_options = '--add-opens java.base/java.lang=ALL-UNNAMED --add-opens java.base/jdk.internal.loader=ALL-UNNAMED'
        with open(jar, 'rb') as jar_file:
            code = jar_file.read()
            # linux 
            with open(join(traget_dir, args.name + '-linux'), 'wb') as file:
                write_script(file, '#!/usr/bin/env bash\nexec java -Xmx512m %s -jar $0 "$@"\n' % java9_options, code)
            with open(join(traget_dir, args.name + '-linuxJava8'), 'wb') as file:
                write_script(file, '#!/usr/bin/env bash\nexec java -Xmx512m -jar $0 "$@"\n', code)
            # windows
            with open(join(traget_dir, args.name + '-win.bat'), 'wb') as file:
                write_script(file, 'java -Xmx512m %s -jar %%0 %%* \r\n exit /b \r\n' % java9_options, code) # escaped percent sign because of format string!
            with open(join(traget_dir, args.name + '-winJava8.bat'), 'wb') as file:
                write_script(file, 'java -Xmx512m -jar %0 %* \r\n exit /b \r\n', code)
            # osx
            with open(join(traget_dir, args.name + '-osx'), 'wb') as file:
                write_script(file, '#!/usr/bin/env bash\nexec java -XstartOnFirstThread -Xmx512m %s -jar $0 "$@"' % java9_options, code)
            with open(join(traget_dir, args.name + '-osxJava8'), 'wb') as file:
                write_script(file, '#!/usr/bin/env bash\nexec java -XstartOnFirstThread -Xmx512m -jar $0 "$@"', code)

def write_script(file, command, code):
    print('Creating script', basename(file.name))
    file.write(command)
    file.write(code)
    flags = os.fstat(file.fileno()).st_mode
    flags |= stat.S_IXUSR | stat.S_IXGRP | stat.S_IXOTH
    os.fchmod(file.fileno(), stat.S_IMODE(flags))

def stop(msg):
    errPrint('[ERROR] ' + msg)
    sys.exit(2)

def errPrint(*args, **kwargs):
    print(*args, file=sys.stderr, **kwargs)

if __name__ == '__main__':
    argParser = argparse.ArgumentParser(description='This script bundles a self-contained eclipse update site into an executable uber-jar (no shading!) and several platform specific executable scripts bundling the jar.')
    argParser.add_argument('-s', dest='scripts', action="store_true", help='create platform specific standalone scripts of the jar')
    argParser.add_argument('source', help='directory containing all plugins that should be bundled (self-contained update site)')
    argParser.add_argument('name', help='name of the generated executable jar/script')
    argParser.add_argument('main', help='main class of the generated jar')
    argParser.add_argument('target', help='target directory to store generated jar/ and scripts')
    argParser.add_argument('build', help='directory for storing intermediate results')
    try:
        main(argParser.parse_args())
    except KeyboardInterrupt:
        print('\nAbort')
        sys.exit(0)