/*
 * generated by Xtext 2.10.0
 */
package de.cau.rtsys.peu.serializer;

import com.google.inject.Inject;
import de.cau.rtsys.peu.railSL.Block;
import de.cau.rtsys.peu.railSL.ContactWaitStatement;
import de.cau.rtsys.peu.railSL.CrossingStatement;
import de.cau.rtsys.peu.railSL.LightStatement;
import de.cau.rtsys.peu.railSL.Program;
import de.cau.rtsys.peu.railSL.RailSLPackage;
import de.cau.rtsys.peu.railSL.SetPointStatement;
import de.cau.rtsys.peu.railSL.SetTrackStatement;
import de.cau.rtsys.peu.railSL.TimeWaitStatement;
import de.cau.rtsys.peu.services.RailSLGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;

@SuppressWarnings("all")
public class RailSLSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private RailSLGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == RailSLPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case RailSLPackage.BLOCK:
				sequence_Block(context, (Block) semanticObject); 
				return; 
			case RailSLPackage.CONTACT_WAIT_STATEMENT:
				sequence_ContactWaitStatement(context, (ContactWaitStatement) semanticObject); 
				return; 
			case RailSLPackage.CROSSING_STATEMENT:
				sequence_CrossingStatement(context, (CrossingStatement) semanticObject); 
				return; 
			case RailSLPackage.LIGHT_STATEMENT:
				sequence_LightStatement(context, (LightStatement) semanticObject); 
				return; 
			case RailSLPackage.PROGRAM:
				sequence_Program(context, (Program) semanticObject); 
				return; 
			case RailSLPackage.SET_POINT_STATEMENT:
				sequence_SetPointStatement(context, (SetPointStatement) semanticObject); 
				return; 
			case RailSLPackage.SET_TRACK_STATEMENT:
				sequence_SetTrackStatement(context, (SetTrackStatement) semanticObject); 
				return; 
			case RailSLPackage.TIME_WAIT_STATEMENT:
				sequence_TimeWaitStatement(context, (TimeWaitStatement) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Block returns Block
	 *
	 * Constraint:
	 *     (statements+=Statement+ end=BLOCK_END)
	 */
	protected void sequence_Block(ISerializationContext context, Block semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ContactWaitStatement
	 *     WaitStatement returns ContactWaitStatement
	 *     ContactWaitStatement returns ContactWaitStatement
	 *
	 * Constraint:
	 *     ((event='Reach' | event='Pass') (contactIndex='first' | contactIndex='second') segName=SEG_NAME)
	 */
	protected void sequence_ContactWaitStatement(ISerializationContext context, ContactWaitStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns CrossingStatement
	 *     OpStatement returns CrossingStatement
	 *     CrossingStatement returns CrossingStatement
	 *
	 * Constraint:
	 *     (mode='Open' | mode='Close')
	 */
	protected void sequence_CrossingStatement(ISerializationContext context, CrossingStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns LightStatement
	 *     OpStatement returns LightStatement
	 *     LightStatement returns LightStatement
	 *
	 * Constraint:
	 *     (lights+=INT lights+=INT* (state='on' | state='off'))
	 */
	protected void sequence_LightStatement(ISerializationContext context, LightStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Program returns Program
	 *
	 * Constraint:
	 *     blocks+=Block+
	 */
	protected void sequence_Program(ISerializationContext context, Program semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns SetPointStatement
	 *     SetStatement returns SetPointStatement
	 *     SetPointStatement returns SetPointStatement
	 *
	 * Constraint:
	 *     (points+=INT points+=INT* (orientation='straight' | orientation='branch'))
	 */
	protected void sequence_SetPointStatement(ISerializationContext context, SetPointStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns SetTrackStatement
	 *     SetStatement returns SetTrackStatement
	 *     SetTrackStatement returns SetTrackStatement
	 *
	 * Constraint:
	 *     (segments+=SEG_NAME segments+=SEG_NAME* mode=TrackSetting)
	 */
	protected void sequence_SetTrackStatement(ISerializationContext context, SetTrackStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns TimeWaitStatement
	 *     WaitStatement returns TimeWaitStatement
	 *     TimeWaitStatement returns TimeWaitStatement
	 *
	 * Constraint:
	 *     time=INT+
	 */
	protected void sequence_TimeWaitStatement(ISerializationContext context, TimeWaitStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
