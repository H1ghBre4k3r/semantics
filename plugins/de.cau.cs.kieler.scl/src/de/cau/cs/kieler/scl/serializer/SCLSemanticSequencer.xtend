/*
 * generated by Xtext
 */
package de.cau.cs.kieler.scl.serializer

import com.google.inject.Inject
import de.cau.cs.kieler.scl.Thread
import de.cau.cs.kieler.scl.services.SCLGrammarAccess
import org.eclipse.xtext.serializer.ISerializationContext

class SCLSemanticSequencer extends AbstractSCLSemanticSequencer {

    @Inject
    private SCLGrammarAccess grammarAccess;
  
    /**
     * Contexts:
     *     Thread returns Thread
     *
     * Constraint:
     *     ((annotations+=Annotation* declarations+=Declaration* statements+=Statement*) | statements+=Statement+)?
     */
    override sequence_Thread(ISerializationContext context, Thread semanticObject) {
        val feeder = createSequencerFeeder(semanticObject, createNodeProvider(semanticObject))
        val g = grammarAccess.threadAccess
        
        if (semanticObject.annotations.empty && semanticObject.declarations.empty) {
            if (!semanticObject.statements.nullOrEmpty) {
                for (idxStm : semanticObject.statements.indexed) {
                    feeder.accept(g.getStatementsStatementParserRuleCall_1_1_0, idxStm.value, idxStm.key)
                }
            }
        } else {
            for (idxAnnotation : semanticObject.annotations.indexed) {
                feeder.accept(g.annotationsAnnotationParserRuleCall_1_0_0_0, idxAnnotation.value, idxAnnotation.key)
            }
            
            for (idxDecl : semanticObject.declarations.indexed) {
                feeder.accept(g.declarationsDeclarationParserRuleCall_1_0_2_0, idxDecl.value, idxDecl.key)
            }
            
            if (!semanticObject.statements.nullOrEmpty) {
                for (idxStm : semanticObject.statements.indexed) {
                    feeder.accept(g.getStatementsStatementParserRuleCall_1_0_3_0, idxStm.value, idxStm.key)
                }
            }
        }
        
        feeder.finish
    }
    
}
