/*
 * generated by Xtext
 */
package de.cau.cs.kieler.scl.validation

import de.cau.cs.kieler.scl.Label
import de.cau.cs.kieler.scl.SCLProgram
import org.eclipse.xtext.validation.Check
import de.cau.cs.kieler.scl.SequencePart
import org.eclipse.emf.ecore.EObject
import java.util.List
import de.cau.cs.kieler.scl.SCLPackage
import de.cau.cs.kieler.scl.Conditional
import de.cau.cs.kieler.scl.ScopeStatement
import org.eclipse.xtext.validation.CheckType
import de.cau.cs.kieler.scl.SCLResource
import org.eclipse.xtext.Keyword

//import org.eclipse.xtext.validation.Check

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class SCLValidator extends AbstractSCLValidator {
    
    public static val DUBLICATE_LABEL = "Duplicate label"
    public static val LEAGACY_CONDITIONAL = "This conditional uses legacy syntax. Please use if {...} else {...} instead."

     /*
     * Checks if labels are unique
     */
    @Check
    def checkUniqueLabel(SCLProgram program) {
        for(module : program.modules) {
            module.eAllContents().filter(Label).groupBy[name].forEach[name, labels|
                if (labels.size > 1) {
                    labels.forEach[error(DUBLICATE_LABEL, it, null, -1)]
                }
            ]
        }
    }
    
     /*
     * Checks legacy conditionals
     */
    @Check(CheckType.NORMAL)
    def checkLegacyConditional(SCLProgram program) {
        val res = program.eResource
        if (res instanceof SCLResource) {
            val conditionals = res.parseResult.rootNode.asTreeIterable.filter[semanticElement instanceof Conditional].groupBy[semanticElement]
            for (cond : conditionals.keySet) {
                if (conditionals.get(cond).filter[grammarElement instanceof Keyword].exists["then".equals((grammarElement as Keyword).value)]) {
                    info(LEAGACY_CONDITIONAL, cond, null)
                }
            }
        }
    }

}
