grammar de.cau.cs.kieler.scl.SCL with org.yakindu.sct.model.stext.SText 

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
import "http://www.yakindu.org/sct/sgraph/2.0.0" as sgraph
import "http://www.yakindu.org/base/types/2.0.0" as types
import "http://www.yakindu.org/base/base/2.0.0" as base
import "http://www.yakindu.org/sct/statechart/SText" as stext
//import "http://kieler.cs.cau.de/annotations" as annotations

generate scl "http://www.cau.de/cs/kieler/scl/scl"

Program:
	'module' name = ID
	(declarations+=VariableDeclaration)*
	'{'
        (
            ((statements += InstructionStatement';') | statements += EmptyStatement)*
            (statements +=  InstructionStatement statements += EmptyStatement*)?
         )
    '}' 
;

//KeyStringValueAnnotation returns annotations::StringAnnotation:
//    '@' name=ID value=STRING
//;

VariableDeclaration:
    (input?='input')? (output?='output')? (static?='static')? 
    type=[types::Type|FQN] name=ID
    ('=' initialValue=Expression)?';'
//    (input?='input')? (output?='output')? 
//(name=ID)(':'type=[types::Type])?('='initialValue=Expression)?';'
;

Statement:
    EmptyStatement | InstructionStatement
;

EmptyStatement:
    (annotations += Annotation)*
    (label = ID ':')
;

InstructionStatement:    
    (
        (annotations += Annotation)*
//        (label = ID ':')?
        instruction = (Assignment | Conditional | Goto | Parallel | Pause | StatementScope)
    )
;

Instruction:
    Assignment | Conditional | Goto | Parallel | Pause | StatementScope
;

//terminal SL_ANNOTATION     : '@' !('\n'|'\r')* ('\r'? '\n')?;

Annotation:
    '@' name = ID 
    (':' parameter += ID(',' parameter += ID)*)? 
;

Assignment:
    assignment = Expression
;

Conditional:
    'if' expression = Expression 'then'
        (
            ((statements += InstructionStatement';') | statements += EmptyStatement)*
            (statements +=  InstructionStatement statements += EmptyStatement*)?
         )
     ('else'
        (
            ((elseStatements += InstructionStatement';') | elseStatements += EmptyStatement)*
            (elseStatements +=  InstructionStatement elseStatements += EmptyStatement*)?
         )
         )?
    'end' 
;

Goto:
    'goto' targetLabel = ID 
;

//AbstractThread:
//    Thread | Program
//;

StatementSequence:
    Thread | Program | Conditional | StatementScope
;

Thread:
    {Thread}
        (
            ((statements += InstructionStatement';') | statements += EmptyStatement)*
            (statements +=  InstructionStatement statements += EmptyStatement*)?
         )
;

Parallel:
    'fork'
    (    threads += Thread
    ('par'
         threads += Thread)*)
    'join'
;


Pause:
    'pause' {Pause}
;

StatementScope:
    {StatementScope}
    '{'
    (declarations+=VariableDeclaration)*
        (
            ((statements += InstructionStatement';') | statements += EmptyStatement)*
            (statements +=  InstructionStatement statements += EmptyStatement*)?
         )
    '}'    
;
