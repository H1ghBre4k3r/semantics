grammar de.cau.cs.kieler.scl.SCL with de.cau.cs.kieler.core.kexpressions.text.KEXT
 
//// we do not need to generate the transitionlabel ecore model, because we
//// only reuse classes of the official sccharts metamodel
//generate transitionlabel "http://kieler.cs.cau.de/sccharts/actionlabel"
 
import "http://www.eclipse.org/emf/2002/Ecore" as ecore
//import "http://kieler.cs.cau.de/sccharts/0.1.0" as sccharts
import "http://kieler.cs.cau.de/annotations" as annotations
import "http://kieler.cs.cau.de/kexpressions/0.1.2" as kexpressions
import "http://kieler.cs.cau.de/keffects/0.1.0" as keffects
import "http://kieler.cs.cau.de/kext/kext" as kext

import "http://kieler.cs.cau.de/scl/scl" as scl
//generate scl "http://kieler.cs.cau.de/scl/scl"

SCLProgram returns scl::SCLProgram:
	(annotations+=Annotation)*
    'module' name = ID
    (declarations+=Declaration)*
    '{'
        (
            ((statements += InstructionStatement';') | statements += EmptyStatement)*
            (statements +=  InstructionStatement statements += EmptyStatement*)?
         )
    '}' 
;

EmptyStatement returns scl::EmptyStatement:
    (annotations += Annotation)*
    (label = ID ':')
;

Instruction returns scl::Instruction:
    Assignment | Conditional | Goto | Parallel | Pause | StatementScope
;

InstructionStatement returns scl::InstructionStatement:    
    (
        (annotations += Annotation)*
        instruction = Instruction
    )
;

Assignment returns scl::Assignment:
    valuedObject=[kexpressions::ValuedObject]
    ('[' indices+=Expression ']')*
     "=" expression = Expression ;

Conditional returns scl::Conditional:
    'if' expression = Expression 'then'
        (declarations+=Declaration)*
        (
            ((statements += InstructionStatement';') | statements += EmptyStatement)*
            (statements +=  InstructionStatement statements += EmptyStatement*)?
         )
     ('else'
        (declarations+=Declaration)*
        (
            ((elseStatements += InstructionStatement';') | elseStatements += EmptyStatement)*
            (elseStatements +=  InstructionStatement elseStatements += EmptyStatement*)?
         )
         )?
    'end' 
;

Goto returns scl::Goto:
    'goto' targetLabel = ID 
;

Thread returns scl::Thread:
    {scl::Thread}
    ((annotations+=Annotation)* 'thread')?
        (
            ((statements += InstructionStatement';') | statements += EmptyStatement)*
            (statements +=  InstructionStatement statements += EmptyStatement*)?
         )
;

Parallel returns scl::Parallel:
    'fork'
    (    threads += Thread
    ('par'
         threads += Thread)*)
    'join'
;


Pause returns scl::Pause:
    'pause' {scl::Pause}
;

StatementScope returns scl::StatementScope:
    {scl::StatementScope}
    '{'
        (declarations+=Declaration)*
        (
            ((statements += InstructionStatement';') | statements += EmptyStatement)*
            (statements +=  InstructionStatement statements += EmptyStatement*)?
         )
    '}'    
;