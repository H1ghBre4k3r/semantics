grammar de.cau.cs.kieler.scl.SCL with de.cau.cs.kieler.kexpressions.kext.KExt
  
import "http://www.eclipse.org/emf/2002/Ecore" as ecore
import "http://kieler.cs.cau.de/annotations" as annotations
import "http://kieler.cs.cau.de/kexpressions/0.1.2" as kexpressions
import "http://kieler.cs.cau.de/keffects/0.1.0" as keffects
import "http://kieler.cs.cau.de/kext/0.1.0" as kext
import "http://kieler.cs.cau.de/scl/0.2.0"

SCLProgram returns SCLProgram:
    pragmas+=Pragma*
    modules+=Module*
;

Module returns Module:
    (annotations += Annotation)*
    =>'module' name = ID ':'?
    (declarations += Declaration)*
    ((statements += InstructionStatement ';') | (statements += MetaStatement))*
    (statements += Statement)?
;

Statement returns Statement:
    MetaStatement | InstructionStatement
;

InstructionStatement returns Statement:
	Assignment | LegacyConditional | Goto | Parallel | Pause | ModuleCall
;

MetaStatement returns Statement:
    Label | ScopeStatement | Conditional
;

Pause returns Pause:
    {Pause}
    (annotations += Annotation)*
    'pause'
;

Label returns Label:
    (annotations += Annotation)*
    (name = ID ':')
;

Goto returns Goto:
    (annotations += Annotation)*
    'goto' target = [Label|ID]
;

Assignment returns Assignment:
    (annotations += Annotation)*
    reference = ValuedObjectReference
    operator = AssignOperator
    expression = Expression
    (=>'schedule' schedule+=ScheduleObjectReference+)?
;

Conditional returns Conditional: 
    (annotations += Annotation)*
    'if' expression = BoolExpression
    =>'{'
    (declarations+=Declaration)*
    ((statements += InstructionStatement ';')|(statements += MetaStatement))* (statements += Statement)?
    '}'
    (else = ElseScope)?
;

ElseScope returns ElseScope:
    {ElseScope}
    (annotations += Annotation)*
    'else' '{'
    (declarations+=Declaration)*
    ((statements += InstructionStatement ';')|(statements += MetaStatement))*
    (statements += Statement)?        
    '}'
;

LegacyConditional returns Conditional: 
    (annotations += Annotation)*
    'if' expression = BoolExpression
    =>'then'
    ((statements += InstructionStatement ';')|(statements += MetaStatement))*
    (statements += Statement)?
    ( 'end' | (else = LeagacyElseScope))
;

LeagacyElseScope returns ElseScope:
    {ElseScope}
    (annotations += Annotation)*
    'else'
    ((statements += InstructionStatement ';')|(statements += MetaStatement))*
    (statements += Statement)?        
    'end'
;

Thread returns Thread:
    {Thread}
    (
        (
            (annotations += Annotation)*
            =>'{'
            (declarations+=Declaration)*
            ((statements += InstructionStatement ';')|(statements += MetaStatement))*
            (statements += Statement)?
            '}'
        ) | (
            ((statements += InstructionStatement ';')|(statements += MetaStatement))*
            (statements += Statement)?
        )
    )
;

Parallel returns Parallel:
    'fork'
    (
        threads += Thread
        (
            =>'par'
            threads += Thread
        )*
    )
    'join'
;

ScopeStatement returns ScopeStatement:
    {ScopeStatement}
    (annotations += Annotation)*
    '{'
        (declarations+=Declaration)*
        ((statements += InstructionStatement ';')|(statements += MetaStatement))*
        (statements += Statement)?
    '}'
;

ModuleCall returns ModuleCall:
    (annotations += Annotation)*
    'run'
    module = [Module|ID]
    ('(' parameters += Parameter (',' parameters += Parameter)* ')' | '()')?
;
    
Parameter returns kexpressions::Parameter:
    ((pureOutput ?= '!')? callByReference ?= '&')?
    expression = Expression
    ('to' explicitBinding = [kexpressions::ValuedObject|ID] ('[' explicitBindingIndices+=Expression ']')*)?
;    