grammar de.cau.cs.kieler.scl.SCL with de.cau.cs.kieler.core.kexpressions.KExpressions
 
//// we do not need to generate the transitionlabel ecore model, because we
//// only reuse classes of the official sccharts metamodel
//generate transitionlabel "http://kieler.cs.cau.de/sccharts/actionlabel"
 
import "http://www.eclipse.org/emf/2002/Ecore" as ecore
//import "http://kieler.cs.cau.de/sccharts/0.1.0" as sccharts
import "http://kieler.cs.cau.de/annotations" as annotations
import "http://kieler.cs.cau.de/kexpressions/0.1.2" as kexpressions

generate scl "http://kieler.cs.cau.de/scl/scl"

SCLProgram:
	(annotations+=Annotation)*
    'module' name = ID
    (declarations+=Declaration)*
    '{'
        (
            ((statements += InstructionStatement';') | statements += EmptyStatement)*
            (statements +=  InstructionStatement statements += EmptyStatement*)?
         )
    '}' 
;

Declaration returns kexpressions::Declaration:
    (annotations+=Annotation)*
	(const?='const')?
    (input?='input')?
    (output?='output')?
    (static?='static')?
    (signal?='signal')?
    (
        type = HostType hostType = STRING valuedObjects+=ValuedObject (',' valuedObjects+=ValuedObject)* ';' |
        type = ValueType valuedObjects+=ValuedObject (',' valuedObjects+=ValuedObject)* ';'
    )
;

// Override ValueType rule without host type
enum ValueType returns kexpressions::ValueType:
    PURE="pure" | BOOL="bool" | UNSIGNED="unsigned" | 
    INT="int" | FLOAT="float" |
    STRING="string";

ValuedObject returns kexpressions::ValuedObject:
//    (annotations+=Annotation)* // Parser does not like this
    name=ID ('=' initialValue=Expression)?
    ( 'combine'
      (combineOperator = CombineOperator)
    )?
;

Statement:
    EmptyStatement | InstructionStatement
;

EmptyStatement:
    (annotations += Annotation)*
    (label = ID ':')
;

InstructionStatement:    
    (
        (annotations += Annotation)*
        instruction = (Assignment | Conditional | Goto | Parallel | Pause | StatementScope)
    )
;

Instruction:
    Assignment | Conditional | Goto | Parallel | Pause | StatementScope
;

Assignment:
//    assignment = kexpressions::Expression
    valuedObject = [kexpressions::ValuedObject] 
    '=' 
    expression = Expression
;

Conditional:
    'if' expression = Expression 'then'
        (declarations+=Declaration)*
        (
            ((statements += InstructionStatement';') | statements += EmptyStatement)*
            (statements +=  InstructionStatement statements += EmptyStatement*)?
         )
     ('else'
        (declarations+=Declaration)*
        (
            ((elseStatements += InstructionStatement';') | elseStatements += EmptyStatement)*
            (elseStatements +=  InstructionStatement elseStatements += EmptyStatement*)?
         )
         )?
    'end' 
;

Goto:
    'goto' targetLabel = ID 
;

StatementSequence:
    Thread | SCLProgram | Conditional | StatementScope
;

Thread:
    {Thread}
        (
            ((statements += InstructionStatement';') | statements += EmptyStatement)*
            (statements +=  InstructionStatement statements += EmptyStatement*)?
         )
;

Parallel:
    'fork'
    (    threads += Thread
    ('par'
         threads += Thread)*)
    'join'
;


Pause:
    'pause' {Pause}
;

StatementScope:
    {StatementScope}
    '{'
        (declarations+=Declaration)*
        (
            ((statements += InstructionStatement';') | statements += EmptyStatement)*
            (statements +=  InstructionStatement statements += EmptyStatement*)?
         )
    '}'    
;