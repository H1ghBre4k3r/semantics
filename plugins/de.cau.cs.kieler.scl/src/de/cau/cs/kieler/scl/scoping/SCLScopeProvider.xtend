/*
 * generated by Xtext
 */
package de.cau.cs.kieler.scl.scoping

import de.cau.cs.kieler.kexpressions.kext.scoping.KExtScopeProvider
import de.cau.cs.kieler.scl.Goto
import de.cau.cs.kieler.scl.Label
import de.cau.cs.kieler.scl.Module
import de.cau.cs.kieler.scl.ModuleCall
import de.cau.cs.kieler.scl.SCLProgram
import java.util.Collections
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.xtext.naming.QualifiedName
import org.eclipse.xtext.resource.EObjectDescription
import org.eclipse.xtext.resource.IEObjectDescription
import org.eclipse.xtext.scoping.IScope
import org.eclipse.xtext.scoping.Scopes
import de.cau.cs.kieler.kexpressions.ValuedObject
import de.cau.cs.kieler.scl.Loop
import de.cau.cs.kieler.scl.MethodImplementationDeclaration

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 *
 */
class SCLScopeProvider extends KExtScopeProvider {

    override getScope(EObject context, EReference reference) {
        return switch(context) {
            Goto: getScopeForLabel(context, reference)
            ModuleCall: getScopeForModule(context, reference)
            default: super.getScope(context, reference)
        }
    }
    
    protected def IScope getScopeForLabel(Goto goto, EReference reference) {
        var EObject module = goto
        while (module != null) {
            if (module instanceof Module) {
                return Scopes.scopeFor(module.eAllContents.filter(Label).toList)
            }
            module = module.eContainer
        }
    }

    protected def IScope getScopeForModule(ModuleCall call, EReference reference) {
        var EObject program = call
        while (program != null) {
            if (program instanceof SCLProgram) {
                return Scopes.scopeFor(program.modules)
            }
            program = program.eContainer
        }
    }
    
    override IScope getScopeHierarchical(EObject context, EReference reference) {
        val candidates = <ValuedObject> newArrayList
        var declarationScope = context.nextDeclarationScope
        while (declarationScope !== null) {
            for(declaration : declarationScope.declarations) {
                for(VO : declaration.valuedObjects) {
                    candidates += VO
                }
            }
            
            // Add for loop counter variable            
            if (declarationScope instanceof Loop) {
                if (declarationScope.initializationDeclaration !== null) {
                    candidates += declarationScope.initializationDeclaration.valuedObjects
                }
            }
            
            // Add method parameters           
            if (declarationScope instanceof MethodImplementationDeclaration) {
                candidates += declarationScope.parameterDeclarations.map[valuedObjects].flatten
            }
            
            declarationScope = declarationScope.nextDeclarationScope
        }
        return Scopes.scopeFor(candidates)
    }
}
