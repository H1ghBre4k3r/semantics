/*
 * generated by Xtext
 */
package de.cau.cs.kieler.simulation.trace.scoping

import de.cau.cs.kieler.kexpressions.kext.scoping.KExtScopeProvider
import de.cau.cs.kieler.simulation.trace.ktrace.KTracePackage
import de.cau.cs.kieler.simulation.trace.ktrace.Tick
import de.cau.cs.kieler.simulation.trace.ktrace.Trace
import de.cau.cs.kieler.simulation.trace.ktrace.TraceFile
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.xtext.scoping.IScope
import org.eclipse.xtext.scoping.Scopes

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 *
 */
class KTraceScopeProvider extends KExtScopeProvider {

    override getScope(EObject context, EReference reference) {
        if (context instanceof Tick && reference == KTracePackage.Literals.TICK__GOTO) {
            return Scopes.scopeFor(((context as Tick).eContainer as Trace).ticks)
        }
        
        return super.getScope(context, reference);
    }

    override getScopeForValuedObjectReference(EObject context, EReference reference) {
        context.getScopeForValuedObject(reference)
    }
    
    override IScope getScopeForValuedObject(EObject context, EReference reference) {
        val root = context.traceFile
        if (root !== null) {
            return Scopes.scopeFor(root.aggregatedValuedObjects)
        } else {
            return IScope.NULLSCOPE
        }
    }
    
    private def traceFile(EObject context) {
        var eO = context
        while(eO !== null) {
            if (eO instanceof TraceFile) return eO
            eO = eO.eContainer
        }
        return null
    }

}
