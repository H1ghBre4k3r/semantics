/*! \file sc.c 
 *
 * Main file for using SyncChart C macros
 *
 * See README.txt for general information.
 * See LICENSE.txt for licensing information.
 * For further information, see
 * http://www.informatik.uni-kiel.de/rtsys/sc/ .
 *
 * @author Reinhard v. Hanxleden,
 * rvh@informatik.uni-kiel.de
 */

#include "sc-generic.h"

// ===================================================================
//! The main program
/*! Returns 0 iff outputs generated by program match reference trace
 */
int main()
{
  int runCnt;               // Counts program runs
  int tickCnt;              // Counts program ticks
  int runInstrCnt;          // Instructions in one run
  int runsInstrCnt = 0;     // Instructions accumulated over all runs
  double runCycleCnt;       // Clock cycles in one run
  double runsCycleCnt = 0;  // Clock cycles accumulated over all runs
  int outputsOK = 1;        // Outputs of simulation correct?
  int notDone;              // Automaton still running?
  int i, ok;
  int sigsetSize = _sigMax / _setPartSize + 1;

  // Execute all runs
  for (runCnt = 0; (runCnt < _runMax) && outputsOK; runCnt++) {
    trace1("#### RUN %d STARTS ##################################\n",	
	   runCnt);

    runInstrCnt = 0;
    runCycleCnt = 0;
    tickCnt = 0;
    RESET();                         // Reset automaton

    do {                             // Execute all ticks of one run
      _tickInstrCnt = 0;
      getInputs(runCnt, tickCnt);

      for (i = 0; i < sigsetSize; i++) {
	sigCopyFrom(tickInputsPtr[i], signalsPtr[i]);
      }

      trace2("==== TICK %d STARTS, inputs = %s",
	     tickCnt, _sigPtr2str(tickInputsPtr));
      if (tickCnt != 0) {
	trace1(", enabled = %s", _idPtr2str2(enabledPtr));
      }
      sig2names("\n==== Inputs (id/name): ", "\n", tickInputsPtr);
      if (tickCnt != 0) {
	id2names("==== Enabled (id/state): ", "\n", enabledPtr);
      }

      notDone = tick();             // Call automaton function
      runInstrCnt += _tickInstrCnt;
      runCycleCnt += _tickCycleCnt;
      trace3("==== TICK %d terminates after %d instructions and %.0f cycles.\n",
	     tickCnt, _tickInstrCnt, _tickCycleCnt);
      id2names("==== Enabled (id/state): ", "\n", enabledPtr);
      sig2names("==== Resulting signals (id/name): ", "", signalsPtr);
      outputsOK = checkOutputs(runCnt, tickCnt, tickOutputsPtr);
      if (outputsOK) {
	for (i = 0; i < sigsetSize; i++) {
	  //sigCopyFrom(tickSignalsPtr[i], castSignals(tickInputsPtr[i]) | castSignals(tickOutputsPtr[i]));
	  // The above assumed that inputs that are set by the environment
	  // must be persistent at the end of a tick. This is true for signals,
	  // which cannot be set to "absent" once they have been set to present
	  // by the environment. However, under sequential constructiveness, this
	  // must not hold for boolean inputs, which may be set to false during a tick.
	  sigCopyFrom(tickSignalsPtr[i], castSignals(tickOutputsPtr[i]));
	}
	for (i = 0; outputsOK && (i < sigsetSize); i++) {
	  outputsOK = (castSignals(signalsPtr[i]) == castSignals(tickSignalsPtr[i]));
	}
	if (!outputsOK) {
	  sig2names(", Outputs NOT OK - expected signals ", "!!\n\n",
		    tickSignalsPtr);
	}
      }

      if (outputsOK) {
	trace0(", Outputs OK.\n\n");
      } else {
	notDone = 0;
      }

      tickCnt++;
      if (tickCnt >= _tickMax) {
	trace1("==== Executed _tickMax = %d ticks, terminate.\n", _tickMax);
	notDone = 0;
      }

    } while (notDone && outputsOK);
    
    trace3("#### RUN %d terminates after %d instructions and %.0f cycles\n\n",
	   runCnt, runInstrCnt, runCycleCnt);					
    runsInstrCnt += runInstrCnt;
    runsCycleCnt += runCycleCnt;
  };

  trace2("#### All runs terminate, after %d instructions and %.0f cycles\n\n", runsInstrCnt, runsCycleCnt);					
  return !outputsOK;
}