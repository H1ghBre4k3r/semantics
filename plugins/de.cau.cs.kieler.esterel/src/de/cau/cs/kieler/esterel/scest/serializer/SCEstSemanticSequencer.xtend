/*
 * generated by Xtext
 */
package de.cau.cs.kieler.esterel.scest.serializer

import com.google.inject.Inject
import de.cau.cs.kieler.esterel.EsterelParallel
import de.cau.cs.kieler.esterel.EsterelThread
import de.cau.cs.kieler.esterel.scest.services.SCEstGrammarAccess
import org.eclipse.xtext.serializer.ISerializationContext

class SCEstSemanticSequencer extends AbstractSCEstSemanticSequencer {

    @Inject
    private SCEstGrammarAccess grammarAccess;
    @Inject
    extension SCEstSytaxHelper
    
    protected override sequence_EsterelParallel(ISerializationContext context, EsterelParallel semanticObject) {
        val feeder = createSequencerFeeder(semanticObject, createNodeProvider(semanticObject))
        val g = grammarAccess.esterelParallelAccess
        
        if (!semanticObject.statements.nullOrEmpty) {
            for (idxStm : semanticObject.statements.indexed) {
                // Do not serialize threads with only one statement
                val stm = if (idxStm.value instanceof EsterelThread) {
                    val thread = idxStm.value as EsterelThread
                    if (thread.statements.size == 1) {
                        thread.statements.head
                    } else {
                        thread
                    }
                } else {
                    idxStm.value
                }
                
                switch (idxStm.key) {
                    case 0: feeder.accept(g.esterelParallelStatementsAction_1_0, stm, idxStm.key)
                    default: feeder.accept(g.statementsEsterelThreadParserRuleCall_1_1_1_0, stm, idxStm.key)
                }
            }
        }
        
        feeder.finish
    }
    
    protected override sequence_EsterelThread(ISerializationContext context, EsterelThread semanticObject) {
        if (!semanticObject.statements.nullOrEmpty) {
            val feeder = createSequencerFeeder(semanticObject, createNodeProvider(semanticObject))
            val g = grammarAccess.esterelThreadAccess
            
            if (semanticObject.statements.size > 1) {
                for (idxStm : semanticObject.statements.indexed) {
                    // Do not serialize threads with only one statement
                    val stm = if (idxStm.value instanceof EsterelThread) {
                        val thread = idxStm.value as EsterelThread
                        if (thread.statements.size == 1) {
                            thread.statements.head
                        } else {
                            thread
                        }
                    } else {
                        idxStm.value
                    }
                    
                    if (stm.isSCLStatement) {
                        switch (idxStm.key) {
                            case 0: {
                                feeder.accept(g.getEsterelThreadStatementsAction_1_1_0, stm, idxStm.key)
                            }
                            default: feeder.accept(g.getStatementsEsterelThreadParserRuleCall_1_1_1_0, idxStm.value, idxStm.key)
                        }
                    } else {
                        switch (idxStm.key) {
                            case 0: {
                                feeder.accept(g.getEsterelThreadStatementsAction_0_1_0, stm, idxStm.key)
                            }
                            default: feeder.accept(g.getStatementsEsterelThreadParserRuleCall_0_1_1_1_0, idxStm.value, idxStm.key)
                        }
                    }
                }
            } else {
                // Will not happen
                throw new IllegalStateException("Should not happen")
            }
            feeder.finish
        }
        
    }
}
