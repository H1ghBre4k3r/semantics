/*
 * generated by Xtext
 */
package de.cau.cs.kieler.esterel.services;

import com.google.inject.Singleton;
import com.google.inject.Inject;

import java.util.List;

import org.eclipse.xtext.*;
import org.eclipse.xtext.service.GrammarProvider;
import org.eclipse.xtext.service.AbstractElementFinder.*;

import de.cau.cs.kieler.esterel.kexpressions.services.KExpressionsGrammarAccess;
import de.cau.cs.kieler.annotations.services.AnnotationsGrammarAccess;
import org.eclipse.xtext.common.services.TerminalsGrammarAccess;

@Singleton
public class EsterelGrammarAccess extends AbstractGrammarElementFinder {
	
	
	public class ProgramElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.Program");
		private final Assignment cModulesAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cModulesModuleParserRuleCall_0 = (RuleCall)cModulesAssignment.eContents().get(0);
		
		////	root rule. an esterel file can contain multiple modules
		//Program hidden(ESTEREL_SL_COMMENT, ESTEREL_ML_COMMENT, WS):
		//	modules+=Module*;
		@Override public ParserRule getRule() { return rule; }

		//modules+=Module*
		public Assignment getModulesAssignment() { return cModulesAssignment; }

		//Module
		public RuleCall getModulesModuleParserRuleCall_0() { return cModulesModuleParserRuleCall_0; }
	}

	public class ModuleElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.Module");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cModuleKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cColonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cInterfaceAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cInterfaceModuleInterfaceParserRuleCall_3_0 = (RuleCall)cInterfaceAssignment_3.eContents().get(0);
		private final Assignment cBodyAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cBodyModuleBodyParserRuleCall_4_0 = (RuleCall)cBodyAssignment_4.eContents().get(0);
		private final Assignment cEndAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cEndEndModuleParserRuleCall_5_0 = (RuleCall)cEndAssignment_5.eContents().get(0);
		
		//// a module consists of an interface and a body
		//// !-(module)
		//Module:
		//	"module" name=ID ":" interface=ModuleInterface? body=ModuleBody end=EndModule;
		@Override public ParserRule getRule() { return rule; }

		//"module" name=ID ":" interface=ModuleInterface? body=ModuleBody end=EndModule
		public Group getGroup() { return cGroup; }

		//"module"
		public Keyword getModuleKeyword_0() { return cModuleKeyword_0; }

		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }

		//":"
		public Keyword getColonKeyword_2() { return cColonKeyword_2; }

		//interface=ModuleInterface?
		public Assignment getInterfaceAssignment_3() { return cInterfaceAssignment_3; }

		//ModuleInterface
		public RuleCall getInterfaceModuleInterfaceParserRuleCall_3_0() { return cInterfaceModuleInterfaceParserRuleCall_3_0; }

		//body=ModuleBody
		public Assignment getBodyAssignment_4() { return cBodyAssignment_4; }

		//ModuleBody
		public RuleCall getBodyModuleBodyParserRuleCall_4_0() { return cBodyModuleBodyParserRuleCall_4_0; }

		//end=EndModule
		public Assignment getEndAssignment_5() { return cEndAssignment_5; }

		//EndModule
		public RuleCall getEndEndModuleParserRuleCall_5_0() { return cEndEndModuleParserRuleCall_5_0; }
	}

	public class EndModuleElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.EndModule");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cEndKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final Keyword cModuleKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Keyword cFullStopKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		
		//EndModule:
		//	"end" "module"
		//	| ".";
		@Override public ParserRule getRule() { return rule; }

		//"end" "module" | "."
		public Alternatives getAlternatives() { return cAlternatives; }

		//"end" "module"
		public Group getGroup_0() { return cGroup_0; }

		//"end"
		public Keyword getEndKeyword_0_0() { return cEndKeyword_0_0; }

		//"module"
		public Keyword getModuleKeyword_0_1() { return cModuleKeyword_0_1; }

		//"."
		public Keyword getFullStopKeyword_1() { return cFullStopKeyword_1; }
	}

	public class ModuleBodyElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.ModuleBody");
		private final Assignment cStatementsAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cStatementsStatementParserRuleCall_0 = (RuleCall)cStatementsAssignment.eContents().get(0);
		
		////deprecated
		//ModuleBody:
		//	statements+=Statement;
		@Override public ParserRule getRule() { return rule; }

		//statements+=Statement
		public Assignment getStatementsAssignment() { return cStatementsAssignment; }

		//Statement
		public RuleCall getStatementsStatementParserRuleCall_0() { return cStatementsStatementParserRuleCall_0; }
	}

	public class ModuleInterfaceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.ModuleInterface");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cIntSignalDeclsAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cIntSignalDeclsInterfaceSignalDeclParserRuleCall_0_0 = (RuleCall)cIntSignalDeclsAssignment_0.eContents().get(0);
		private final Assignment cIntTypeDeclsAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cIntTypeDeclsTypeDeclParserRuleCall_1_0 = (RuleCall)cIntTypeDeclsAssignment_1.eContents().get(0);
		private final Assignment cIntSensorDeclsAssignment_2 = (Assignment)cAlternatives.eContents().get(2);
		private final RuleCall cIntSensorDeclsSensorDeclParserRuleCall_2_0 = (RuleCall)cIntSensorDeclsAssignment_2.eContents().get(0);
		private final Assignment cIntConstantDeclsAssignment_3 = (Assignment)cAlternatives.eContents().get(3);
		private final RuleCall cIntConstantDeclsConstantDeclsParserRuleCall_3_0 = (RuleCall)cIntConstantDeclsAssignment_3.eContents().get(0);
		private final Assignment cIntRelationDeclsAssignment_4 = (Assignment)cAlternatives.eContents().get(4);
		private final RuleCall cIntRelationDeclsRelationDeclParserRuleCall_4_0 = (RuleCall)cIntRelationDeclsAssignment_4.eContents().get(0);
		private final Assignment cIntTaskDeclsAssignment_5 = (Assignment)cAlternatives.eContents().get(5);
		private final RuleCall cIntTaskDeclsTaskDeclParserRuleCall_5_0 = (RuleCall)cIntTaskDeclsAssignment_5.eContents().get(0);
		private final Assignment cIntFunctionDeclsAssignment_6 = (Assignment)cAlternatives.eContents().get(6);
		private final RuleCall cIntFunctionDeclsFunctionDeclParserRuleCall_6_0 = (RuleCall)cIntFunctionDeclsAssignment_6.eContents().get(0);
		private final Assignment cIntProcedureDeclsAssignment_7 = (Assignment)cAlternatives.eContents().get(7);
		private final RuleCall cIntProcedureDeclsProcedureDeclParserRuleCall_7_0 = (RuleCall)cIntProcedureDeclsAssignment_7.eContents().get(0);
		
		//// -!
		////            Interface Declarations
		//// ----------------------------------------------
		//ModuleInterface:
		//	(intSignalDecls+=InterfaceSignalDecl
		//	| intTypeDecls+=TypeDecl
		//	| intSensorDecls+=SensorDecl
		//	| intConstantDecls+=ConstantDecls
		//	| intRelationDecls+=RelationDecl
		//	| intTaskDecls+=TaskDecl
		//	| intFunctionDecls+=FunctionDecl
		//	| intProcedureDecls+=ProcedureDecl)+;
		@Override public ParserRule getRule() { return rule; }

		//(intSignalDecls+=InterfaceSignalDecl | intTypeDecls+=TypeDecl | intSensorDecls+=SensorDecl |
		//intConstantDecls+=ConstantDecls | intRelationDecls+=RelationDecl | intTaskDecls+=TaskDecl |
		//intFunctionDecls+=FunctionDecl | intProcedureDecls+=ProcedureDecl)+
		public Alternatives getAlternatives() { return cAlternatives; }

		//intSignalDecls+=InterfaceSignalDecl
		public Assignment getIntSignalDeclsAssignment_0() { return cIntSignalDeclsAssignment_0; }

		//InterfaceSignalDecl
		public RuleCall getIntSignalDeclsInterfaceSignalDeclParserRuleCall_0_0() { return cIntSignalDeclsInterfaceSignalDeclParserRuleCall_0_0; }

		//intTypeDecls+=TypeDecl
		public Assignment getIntTypeDeclsAssignment_1() { return cIntTypeDeclsAssignment_1; }

		//TypeDecl
		public RuleCall getIntTypeDeclsTypeDeclParserRuleCall_1_0() { return cIntTypeDeclsTypeDeclParserRuleCall_1_0; }

		//intSensorDecls+=SensorDecl
		public Assignment getIntSensorDeclsAssignment_2() { return cIntSensorDeclsAssignment_2; }

		//SensorDecl
		public RuleCall getIntSensorDeclsSensorDeclParserRuleCall_2_0() { return cIntSensorDeclsSensorDeclParserRuleCall_2_0; }

		//intConstantDecls+=ConstantDecls
		public Assignment getIntConstantDeclsAssignment_3() { return cIntConstantDeclsAssignment_3; }

		//ConstantDecls
		public RuleCall getIntConstantDeclsConstantDeclsParserRuleCall_3_0() { return cIntConstantDeclsConstantDeclsParserRuleCall_3_0; }

		//intRelationDecls+=RelationDecl
		public Assignment getIntRelationDeclsAssignment_4() { return cIntRelationDeclsAssignment_4; }

		//RelationDecl
		public RuleCall getIntRelationDeclsRelationDeclParserRuleCall_4_0() { return cIntRelationDeclsRelationDeclParserRuleCall_4_0; }

		//intTaskDecls+=TaskDecl
		public Assignment getIntTaskDeclsAssignment_5() { return cIntTaskDeclsAssignment_5; }

		//TaskDecl
		public RuleCall getIntTaskDeclsTaskDeclParserRuleCall_5_0() { return cIntTaskDeclsTaskDeclParserRuleCall_5_0; }

		//intFunctionDecls+=FunctionDecl
		public Assignment getIntFunctionDeclsAssignment_6() { return cIntFunctionDeclsAssignment_6; }

		//FunctionDecl
		public RuleCall getIntFunctionDeclsFunctionDeclParserRuleCall_6_0() { return cIntFunctionDeclsFunctionDeclParserRuleCall_6_0; }

		//intProcedureDecls+=ProcedureDecl
		public Assignment getIntProcedureDeclsAssignment_7() { return cIntProcedureDeclsAssignment_7; }

		//ProcedureDecl
		public RuleCall getIntProcedureDeclsProcedureDeclParserRuleCall_7_0() { return cIntProcedureDeclsProcedureDeclParserRuleCall_7_0; }
	}

	public class ChannelDescriptionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.ChannelDescription");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cColonKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final Assignment cTypeAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cTypeEsterelTypeIdentifierParserRuleCall_0_1_0 = (RuleCall)cTypeAssignment_0_1.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cTypeAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cTypeEsterelTypeIdentifierParserRuleCall_1_1_0 = (RuleCall)cTypeAssignment_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Keyword cColonEqualsSignKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cExpressionAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cExpressionExpressionParserRuleCall_2_1_0 = (RuleCall)cExpressionAssignment_2_1.eContents().get(0);
		private final Keyword cColonKeyword_2_2 = (Keyword)cGroup_2.eContents().get(2);
		private final Assignment cTypeAssignment_2_3 = (Assignment)cGroup_2.eContents().get(3);
		private final RuleCall cTypeEsterelTypeIdentifierParserRuleCall_2_3_0 = (RuleCall)cTypeAssignment_2_3.eContents().get(0);
		
		//// overwrite to add the EsterelTypeIdentifier
		//ChannelDescription:
		//	":" type=EsterelTypeIdentifier | "(" type=EsterelTypeIdentifier ")" | ":=" expression=Expression ":"
		//	type=EsterelTypeIdentifier;
		@Override public ParserRule getRule() { return rule; }

		//":" type=EsterelTypeIdentifier | "(" type=EsterelTypeIdentifier ")" | ":=" expression=Expression ":"
		//type=EsterelTypeIdentifier
		public Alternatives getAlternatives() { return cAlternatives; }

		//":" type=EsterelTypeIdentifier
		public Group getGroup_0() { return cGroup_0; }

		//":"
		public Keyword getColonKeyword_0_0() { return cColonKeyword_0_0; }

		//type=EsterelTypeIdentifier
		public Assignment getTypeAssignment_0_1() { return cTypeAssignment_0_1; }

		//EsterelTypeIdentifier
		public RuleCall getTypeEsterelTypeIdentifierParserRuleCall_0_1_0() { return cTypeEsterelTypeIdentifierParserRuleCall_0_1_0; }

		//"(" type=EsterelTypeIdentifier ")"
		public Group getGroup_1() { return cGroup_1; }

		//"("
		public Keyword getLeftParenthesisKeyword_1_0() { return cLeftParenthesisKeyword_1_0; }

		//type=EsterelTypeIdentifier
		public Assignment getTypeAssignment_1_1() { return cTypeAssignment_1_1; }

		//EsterelTypeIdentifier
		public RuleCall getTypeEsterelTypeIdentifierParserRuleCall_1_1_0() { return cTypeEsterelTypeIdentifierParserRuleCall_1_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_1_2() { return cRightParenthesisKeyword_1_2; }

		//":=" expression=Expression ":" type=EsterelTypeIdentifier
		public Group getGroup_2() { return cGroup_2; }

		//":="
		public Keyword getColonEqualsSignKeyword_2_0() { return cColonEqualsSignKeyword_2_0; }

		//expression=Expression
		public Assignment getExpressionAssignment_2_1() { return cExpressionAssignment_2_1; }

		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_2_1_0() { return cExpressionExpressionParserRuleCall_2_1_0; }

		//":"
		public Keyword getColonKeyword_2_2() { return cColonKeyword_2_2; }

		//type=EsterelTypeIdentifier
		public Assignment getTypeAssignment_2_3() { return cTypeAssignment_2_3; }

		//EsterelTypeIdentifier
		public RuleCall getTypeEsterelTypeIdentifierParserRuleCall_2_3_0() { return cTypeEsterelTypeIdentifierParserRuleCall_2_3_0; }
	}

	public class EsterelTypeIdentifierElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.EsterelTypeIdentifier");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cTypeAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cTypeValueTypeEnumRuleCall_0_0 = (RuleCall)cTypeAssignment_0.eContents().get(0);
		private final Assignment cTypeIDAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cTypeIDIDTerminalRuleCall_1_0 = (RuleCall)cTypeIDAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Action cEsterelTypeIdentifierAction_2_0 = (Action)cGroup_2.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cGroup_2.eContents().get(1);
		private final Keyword cCombineKeyword_2_1_0 = (Keyword)cGroup_2_1.eContents().get(0);
		private final Alternatives cAlternatives_2_1_1 = (Alternatives)cGroup_2_1.eContents().get(1);
		private final Assignment cTypeAssignment_2_1_1_0 = (Assignment)cAlternatives_2_1_1.eContents().get(0);
		private final RuleCall cTypeValueTypeEnumRuleCall_2_1_1_0_0 = (RuleCall)cTypeAssignment_2_1_1_0.eContents().get(0);
		private final Assignment cTypeIDAssignment_2_1_1_1 = (Assignment)cAlternatives_2_1_1.eContents().get(1);
		private final RuleCall cTypeIDIDTerminalRuleCall_2_1_1_1_0 = (RuleCall)cTypeIDAssignment_2_1_1_1.eContents().get(0);
		private final Keyword cWithKeyword_2_1_2 = (Keyword)cGroup_2_1.eContents().get(2);
		private final Alternatives cAlternatives_2_1_3 = (Alternatives)cGroup_2_1.eContents().get(3);
		private final Assignment cFuncAssignment_2_1_3_0 = (Assignment)cAlternatives_2_1_3.eContents().get(0);
		private final CrossReference cFuncFunctionCrossReference_2_1_3_0_0 = (CrossReference)cFuncAssignment_2_1_3_0.eContents().get(0);
		private final RuleCall cFuncFunctionIDTerminalRuleCall_2_1_3_0_0_1 = (RuleCall)cFuncFunctionCrossReference_2_1_3_0_0.eContents().get(1);
		private final Assignment cOperatorAssignment_2_1_3_1 = (Assignment)cAlternatives_2_1_3.eContents().get(1);
		private final RuleCall cOperatorCombineOperatorEnumRuleCall_2_1_3_1_0 = (RuleCall)cOperatorAssignment_2_1_3_1.eContents().get(0);
		
		//// overwrite to allow function references for signal declarations
		//EsterelTypeIdentifier kexpressions::TypeIdentifier:
		//	type=ValueType
		//	| typeID=ID
		//	| {EsterelTypeIdentifier} ("combine" (type=ValueType | typeID=ID) "with" (func=[Function] |
		//	operator=CombineOperator))
		@Override public ParserRule getRule() { return rule; }

		//type=ValueType | typeID=ID | {EsterelTypeIdentifier} ("combine" (type=ValueType | typeID=ID) "with" (func=[Function] |
		//operator=CombineOperator))
		public Alternatives getAlternatives() { return cAlternatives; }

		//type=ValueType
		public Assignment getTypeAssignment_0() { return cTypeAssignment_0; }

		//ValueType
		public RuleCall getTypeValueTypeEnumRuleCall_0_0() { return cTypeValueTypeEnumRuleCall_0_0; }

		//typeID=ID
		public Assignment getTypeIDAssignment_1() { return cTypeIDAssignment_1; }

		//ID
		public RuleCall getTypeIDIDTerminalRuleCall_1_0() { return cTypeIDIDTerminalRuleCall_1_0; }

		//{EsterelTypeIdentifier} ("combine" (type=ValueType | typeID=ID) "with" (func=[Function] | operator=CombineOperator))
		public Group getGroup_2() { return cGroup_2; }

		//{EsterelTypeIdentifier}
		public Action getEsterelTypeIdentifierAction_2_0() { return cEsterelTypeIdentifierAction_2_0; }

		//("combine" (type=ValueType | typeID=ID) "with" (func=[Function] | operator=CombineOperator))
		public Group getGroup_2_1() { return cGroup_2_1; }

		//"combine"
		public Keyword getCombineKeyword_2_1_0() { return cCombineKeyword_2_1_0; }

		//(type=ValueType | typeID=ID)
		public Alternatives getAlternatives_2_1_1() { return cAlternatives_2_1_1; }

		//type=ValueType
		public Assignment getTypeAssignment_2_1_1_0() { return cTypeAssignment_2_1_1_0; }

		//ValueType
		public RuleCall getTypeValueTypeEnumRuleCall_2_1_1_0_0() { return cTypeValueTypeEnumRuleCall_2_1_1_0_0; }

		//typeID=ID
		public Assignment getTypeIDAssignment_2_1_1_1() { return cTypeIDAssignment_2_1_1_1; }

		//ID
		public RuleCall getTypeIDIDTerminalRuleCall_2_1_1_1_0() { return cTypeIDIDTerminalRuleCall_2_1_1_1_0; }

		//"with"
		public Keyword getWithKeyword_2_1_2() { return cWithKeyword_2_1_2; }

		//(func=[Function] | operator=CombineOperator)
		public Alternatives getAlternatives_2_1_3() { return cAlternatives_2_1_3; }

		//func=[Function]
		public Assignment getFuncAssignment_2_1_3_0() { return cFuncAssignment_2_1_3_0; }

		//[Function]
		public CrossReference getFuncFunctionCrossReference_2_1_3_0_0() { return cFuncFunctionCrossReference_2_1_3_0_0; }

		//ID
		public RuleCall getFuncFunctionIDTerminalRuleCall_2_1_3_0_0_1() { return cFuncFunctionIDTerminalRuleCall_2_1_3_0_0_1; }

		//operator=CombineOperator
		public Assignment getOperatorAssignment_2_1_3_1() { return cOperatorAssignment_2_1_3_1; }

		//CombineOperator
		public RuleCall getOperatorCombineOperatorEnumRuleCall_2_1_3_1_0() { return cOperatorCombineOperatorEnumRuleCall_2_1_3_1_0; }
	}

	public class TypeIdentifierElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.TypeIdentifier");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cTypeAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cTypeValueTypeEnumRuleCall_0_0 = (RuleCall)cTypeAssignment_0.eContents().get(0);
		private final Assignment cTypeIDAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cTypeIDIDTerminalRuleCall_1_0 = (RuleCall)cTypeIDAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Keyword cCombineKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Alternatives cAlternatives_2_1 = (Alternatives)cGroup_2.eContents().get(1);
		private final Assignment cTypeAssignment_2_1_0 = (Assignment)cAlternatives_2_1.eContents().get(0);
		private final RuleCall cTypeValueTypeEnumRuleCall_2_1_0_0 = (RuleCall)cTypeAssignment_2_1_0.eContents().get(0);
		private final Assignment cTypeIDAssignment_2_1_1 = (Assignment)cAlternatives_2_1.eContents().get(1);
		private final RuleCall cTypeIDIDTerminalRuleCall_2_1_1_0 = (RuleCall)cTypeIDAssignment_2_1_1.eContents().get(0);
		private final Keyword cWithKeyword_2_2 = (Keyword)cGroup_2.eContents().get(2);
		private final Assignment cOperatorAssignment_2_3 = (Assignment)cGroup_2.eContents().get(3);
		private final RuleCall cOperatorCombineOperatorEnumRuleCall_2_3_0 = (RuleCall)cOperatorAssignment_2_3.eContents().get(0);
		private final Group cGroup_3 = (Group)cAlternatives.eContents().get(3);
		private final Action cEsterelTypeAction_3_0 = (Action)cGroup_3.eContents().get(0);
		private final Assignment cEstTypeAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final CrossReference cEstTypeTypeCrossReference_3_1_0 = (CrossReference)cEstTypeAssignment_3_1.eContents().get(0);
		private final RuleCall cEstTypeTypeIDTerminalRuleCall_3_1_0_1 = (RuleCall)cEstTypeTypeCrossReference_3_1_0.eContents().get(1);
		
		//// overwrite to allow type definitions in a specific module
		//TypeIdentifier:
		//	type=ValueType
		//	| typeID=ID
		//	| "combine" (type=ValueType | typeID=ID) "with" operator=CombineOperator | {EsterelType} estType=[Type];
		@Override public ParserRule getRule() { return rule; }

		//type=ValueType | typeID=ID | "combine" (type=ValueType | typeID=ID) "with" operator=CombineOperator | {EsterelType}
		//estType=[Type]
		public Alternatives getAlternatives() { return cAlternatives; }

		//type=ValueType
		public Assignment getTypeAssignment_0() { return cTypeAssignment_0; }

		//ValueType
		public RuleCall getTypeValueTypeEnumRuleCall_0_0() { return cTypeValueTypeEnumRuleCall_0_0; }

		//typeID=ID
		public Assignment getTypeIDAssignment_1() { return cTypeIDAssignment_1; }

		//ID
		public RuleCall getTypeIDIDTerminalRuleCall_1_0() { return cTypeIDIDTerminalRuleCall_1_0; }

		//"combine" (type=ValueType | typeID=ID) "with" operator=CombineOperator
		public Group getGroup_2() { return cGroup_2; }

		//"combine"
		public Keyword getCombineKeyword_2_0() { return cCombineKeyword_2_0; }

		//(type=ValueType | typeID=ID)
		public Alternatives getAlternatives_2_1() { return cAlternatives_2_1; }

		//type=ValueType
		public Assignment getTypeAssignment_2_1_0() { return cTypeAssignment_2_1_0; }

		//ValueType
		public RuleCall getTypeValueTypeEnumRuleCall_2_1_0_0() { return cTypeValueTypeEnumRuleCall_2_1_0_0; }

		//typeID=ID
		public Assignment getTypeIDAssignment_2_1_1() { return cTypeIDAssignment_2_1_1; }

		//ID
		public RuleCall getTypeIDIDTerminalRuleCall_2_1_1_0() { return cTypeIDIDTerminalRuleCall_2_1_1_0; }

		//"with"
		public Keyword getWithKeyword_2_2() { return cWithKeyword_2_2; }

		//operator=CombineOperator
		public Assignment getOperatorAssignment_2_3() { return cOperatorAssignment_2_3; }

		//CombineOperator
		public RuleCall getOperatorCombineOperatorEnumRuleCall_2_3_0() { return cOperatorCombineOperatorEnumRuleCall_2_3_0; }

		//{EsterelType} estType=[Type]
		public Group getGroup_3() { return cGroup_3; }

		//{EsterelType}
		public Action getEsterelTypeAction_3_0() { return cEsterelTypeAction_3_0; }

		//estType=[Type]
		public Assignment getEstTypeAssignment_3_1() { return cEstTypeAssignment_3_1; }

		//[Type]
		public CrossReference getEstTypeTypeCrossReference_3_1_0() { return cEstTypeTypeCrossReference_3_1_0; }

		//ID
		public RuleCall getEstTypeTypeIDTerminalRuleCall_3_1_0_1() { return cEstTypeTypeIDTerminalRuleCall_3_1_0_1; }
	}

	public class LocalSignalDeclElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.LocalSignalDecl");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cSignalKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cSignalListAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cSignalListLocalSignalListParserRuleCall_1_0 = (RuleCall)cSignalListAssignment_1.eContents().get(0);
		private final Keyword cInKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cStatementAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cStatementStatementParserRuleCall_3_0 = (RuleCall)cStatementAssignment_3.eContents().get(0);
		private final Keyword cEndKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cOptEndAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final Keyword cOptEndSignalKeyword_5_0 = (Keyword)cOptEndAssignment_5.eContents().get(0);
		
		//// ==> Local Signal Declaration
		//// !-(localsignal) -------------------------------------
		//LocalSignalDecl:
		//	"signal" signalList=LocalSignalList "in" statement=Statement "end" optEnd="signal"?;
		@Override public ParserRule getRule() { return rule; }

		//"signal" signalList=LocalSignalList "in" statement=Statement "end" optEnd="signal"?
		public Group getGroup() { return cGroup; }

		//"signal"
		public Keyword getSignalKeyword_0() { return cSignalKeyword_0; }

		//signalList=LocalSignalList
		public Assignment getSignalListAssignment_1() { return cSignalListAssignment_1; }

		//LocalSignalList
		public RuleCall getSignalListLocalSignalListParserRuleCall_1_0() { return cSignalListLocalSignalListParserRuleCall_1_0; }

		//"in"
		public Keyword getInKeyword_2() { return cInKeyword_2; }

		//statement=Statement
		public Assignment getStatementAssignment_3() { return cStatementAssignment_3; }

		//Statement
		public RuleCall getStatementStatementParserRuleCall_3_0() { return cStatementStatementParserRuleCall_3_0; }

		//"end"
		public Keyword getEndKeyword_4() { return cEndKeyword_4; }

		//optEnd="signal"?
		public Assignment getOptEndAssignment_5() { return cOptEndAssignment_5; }

		//"signal"
		public Keyword getOptEndSignalKeyword_5_0() { return cOptEndSignalKeyword_5_0; }
	}

	public class LocalSignalListElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.LocalSignalList");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cLocalSignalAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cSignalAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cSignalISignalParserRuleCall_1_0 = (RuleCall)cSignalAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cCommaKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cSignalAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cSignalISignalParserRuleCall_2_1_0 = (RuleCall)cSignalAssignment_2_1.eContents().get(0);
		
		//LocalSignalList:
		//	{LocalSignal} signal+=ISignal ("," signal+=ISignal)*;
		@Override public ParserRule getRule() { return rule; }

		//{LocalSignal} signal+=ISignal ("," signal+=ISignal)*
		public Group getGroup() { return cGroup; }

		//{LocalSignal}
		public Action getLocalSignalAction_0() { return cLocalSignalAction_0; }

		//signal+=ISignal
		public Assignment getSignalAssignment_1() { return cSignalAssignment_1; }

		//ISignal
		public RuleCall getSignalISignalParserRuleCall_1_0() { return cSignalISignalParserRuleCall_1_0; }

		//("," signal+=ISignal)*
		public Group getGroup_2() { return cGroup_2; }

		//","
		public Keyword getCommaKeyword_2_0() { return cCommaKeyword_2_0; }

		//signal+=ISignal
		public Assignment getSignalAssignment_2_1() { return cSignalAssignment_2_1; }

		//ISignal
		public RuleCall getSignalISignalParserRuleCall_2_1_0() { return cSignalISignalParserRuleCall_2_1_0; }
	}

	public class SensorDeclElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.SensorDecl");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cSensorKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cSensorsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cSensorsSensorWithTypeParserRuleCall_1_0 = (RuleCall)cSensorsAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cCommaKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cSensorsAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cSensorsSensorWithTypeParserRuleCall_2_1_0 = (RuleCall)cSensorsAssignment_2_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//// -!
		//// ==> Sensor
		//// -------------------------------------
		//SensorDecl:
		//	"sensor" sensors+=SensorWithType ("," sensors+=SensorWithType)* ";";
		@Override public ParserRule getRule() { return rule; }

		//"sensor" sensors+=SensorWithType ("," sensors+=SensorWithType)* ";"
		public Group getGroup() { return cGroup; }

		//"sensor"
		public Keyword getSensorKeyword_0() { return cSensorKeyword_0; }

		//sensors+=SensorWithType
		public Assignment getSensorsAssignment_1() { return cSensorsAssignment_1; }

		//SensorWithType
		public RuleCall getSensorsSensorWithTypeParserRuleCall_1_0() { return cSensorsSensorWithTypeParserRuleCall_1_0; }

		//("," sensors+=SensorWithType)*
		public Group getGroup_2() { return cGroup_2; }

		//","
		public Keyword getCommaKeyword_2_0() { return cCommaKeyword_2_0; }

		//sensors+=SensorWithType
		public Assignment getSensorsAssignment_2_1() { return cSensorsAssignment_2_1; }

		//SensorWithType
		public RuleCall getSensorsSensorWithTypeParserRuleCall_2_1_0() { return cSensorsSensorWithTypeParserRuleCall_2_1_0; }

		//";"
		public Keyword getSemicolonKeyword_3() { return cSemicolonKeyword_3; }
	}

	public class SensorWithTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.SensorWithType");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Assignment cSensorAssignment_0_0 = (Assignment)cGroup_0.eContents().get(0);
		private final RuleCall cSensorSensorParserRuleCall_0_0_0 = (RuleCall)cSensorAssignment_0_0.eContents().get(0);
		private final Group cGroup_0_1 = (Group)cGroup_0.eContents().get(1);
		private final Keyword cColonKeyword_0_1_0 = (Keyword)cGroup_0_1.eContents().get(0);
		private final Assignment cTypeAssignment_0_1_1 = (Assignment)cGroup_0_1.eContents().get(1);
		private final RuleCall cTypeTypeIdentifierParserRuleCall_0_1_1_0 = (RuleCall)cTypeAssignment_0_1_1.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Assignment cSensorAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cSensorSensorParserRuleCall_1_0_0 = (RuleCall)cSensorAssignment_1_0.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cTypeAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cTypeTypeIdentifierParserRuleCall_1_2_0 = (RuleCall)cTypeAssignment_1_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_1_3 = (Keyword)cGroup_1.eContents().get(3);
		
		//SensorWithType:
		//	sensor=Sensor (":" type=TypeIdentifier) | sensor=Sensor "(" type=TypeIdentifier ")";
		@Override public ParserRule getRule() { return rule; }

		//sensor=Sensor (":" type=TypeIdentifier) | sensor=Sensor "(" type=TypeIdentifier ")"
		public Alternatives getAlternatives() { return cAlternatives; }

		//sensor=Sensor (":" type=TypeIdentifier)
		public Group getGroup_0() { return cGroup_0; }

		//sensor=Sensor
		public Assignment getSensorAssignment_0_0() { return cSensorAssignment_0_0; }

		//Sensor
		public RuleCall getSensorSensorParserRuleCall_0_0_0() { return cSensorSensorParserRuleCall_0_0_0; }

		//(":" type=TypeIdentifier)
		public Group getGroup_0_1() { return cGroup_0_1; }

		//":"
		public Keyword getColonKeyword_0_1_0() { return cColonKeyword_0_1_0; }

		//type=TypeIdentifier
		public Assignment getTypeAssignment_0_1_1() { return cTypeAssignment_0_1_1; }

		//TypeIdentifier
		public RuleCall getTypeTypeIdentifierParserRuleCall_0_1_1_0() { return cTypeTypeIdentifierParserRuleCall_0_1_1_0; }

		//sensor=Sensor "(" type=TypeIdentifier ")"
		public Group getGroup_1() { return cGroup_1; }

		//sensor=Sensor
		public Assignment getSensorAssignment_1_0() { return cSensorAssignment_1_0; }

		//Sensor
		public RuleCall getSensorSensorParserRuleCall_1_0_0() { return cSensorSensorParserRuleCall_1_0_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1_1() { return cLeftParenthesisKeyword_1_1; }

		//type=TypeIdentifier
		public Assignment getTypeAssignment_1_2() { return cTypeAssignment_1_2; }

		//TypeIdentifier
		public RuleCall getTypeTypeIdentifierParserRuleCall_1_2_0() { return cTypeTypeIdentifierParserRuleCall_1_2_0; }

		//")"
		public Keyword getRightParenthesisKeyword_1_3() { return cRightParenthesisKeyword_1_3; }
	}

	public class SensorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.Sensor");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_0 = (RuleCall)cNameAssignment.eContents().get(0);
		
		//Sensor kexpressions::ISignal:
		//	name=ID
		@Override public ParserRule getRule() { return rule; }

		//name=ID
		public Assignment getNameAssignment() { return cNameAssignment; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_0() { return cNameIDTerminalRuleCall_0; }
	}

	public class RelationDeclElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.RelationDecl");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cRelationAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cRelationKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cRelationsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cRelationsRelationTypeParserRuleCall_2_0 = (RuleCall)cRelationsAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cCommaKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cRelationsAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cRelationsRelationTypeParserRuleCall_3_1_0 = (RuleCall)cRelationsAssignment_3_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//// ==> Relations
		//// -------------------------------------
		//RelationDecl:
		//	{Relation} "relation" relations+=RelationType ("," relations+=RelationType)* ";";
		@Override public ParserRule getRule() { return rule; }

		//{Relation} "relation" relations+=RelationType ("," relations+=RelationType)* ";"
		public Group getGroup() { return cGroup; }

		//{Relation}
		public Action getRelationAction_0() { return cRelationAction_0; }

		//"relation"
		public Keyword getRelationKeyword_1() { return cRelationKeyword_1; }

		//relations+=RelationType
		public Assignment getRelationsAssignment_2() { return cRelationsAssignment_2; }

		//RelationType
		public RuleCall getRelationsRelationTypeParserRuleCall_2_0() { return cRelationsRelationTypeParserRuleCall_2_0; }

		//("," relations+=RelationType)*
		public Group getGroup_3() { return cGroup_3; }

		//","
		public Keyword getCommaKeyword_3_0() { return cCommaKeyword_3_0; }

		//relations+=RelationType
		public Assignment getRelationsAssignment_3_1() { return cRelationsAssignment_3_1; }

		//RelationType
		public RuleCall getRelationsRelationTypeParserRuleCall_3_1_0() { return cRelationsRelationTypeParserRuleCall_3_1_0; }

		//";"
		public Keyword getSemicolonKeyword_4() { return cSemicolonKeyword_4; }
	}

	public class RelationTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.RelationType");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cRelationImplicationParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cRelationIncompatibilityParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//RelationType:
		//	RelationImplication | RelationIncompatibility;
		@Override public ParserRule getRule() { return rule; }

		//RelationImplication | RelationIncompatibility
		public Alternatives getAlternatives() { return cAlternatives; }

		//RelationImplication
		public RuleCall getRelationImplicationParserRuleCall_0() { return cRelationImplicationParserRuleCall_0; }

		//RelationIncompatibility
		public RuleCall getRelationIncompatibilityParserRuleCall_1() { return cRelationIncompatibilityParserRuleCall_1; }
	}

	public class RelationImplicationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.RelationImplication");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cFirstAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cFirstISignalCrossReference_0_0 = (CrossReference)cFirstAssignment_0.eContents().get(0);
		private final RuleCall cFirstISignalIDTerminalRuleCall_0_0_1 = (RuleCall)cFirstISignalCrossReference_0_0.eContents().get(1);
		private final Assignment cTypeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Keyword cTypeEqualsSignGreaterThanSignKeyword_1_0 = (Keyword)cTypeAssignment_1.eContents().get(0);
		private final Assignment cSecondAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final CrossReference cSecondISignalCrossReference_2_0 = (CrossReference)cSecondAssignment_2.eContents().get(0);
		private final RuleCall cSecondISignalIDTerminalRuleCall_2_0_1 = (RuleCall)cSecondISignalCrossReference_2_0.eContents().get(1);
		
		//RelationImplication:
		//	first=[kexpressions::ISignal] type="=>" second=[kexpressions::ISignal];
		@Override public ParserRule getRule() { return rule; }

		//first=[kexpressions::ISignal] type="=>" second=[kexpressions::ISignal]
		public Group getGroup() { return cGroup; }

		//first=[kexpressions::ISignal]
		public Assignment getFirstAssignment_0() { return cFirstAssignment_0; }

		//[kexpressions::ISignal]
		public CrossReference getFirstISignalCrossReference_0_0() { return cFirstISignalCrossReference_0_0; }

		//ID
		public RuleCall getFirstISignalIDTerminalRuleCall_0_0_1() { return cFirstISignalIDTerminalRuleCall_0_0_1; }

		//type="=>"
		public Assignment getTypeAssignment_1() { return cTypeAssignment_1; }

		//"=>"
		public Keyword getTypeEqualsSignGreaterThanSignKeyword_1_0() { return cTypeEqualsSignGreaterThanSignKeyword_1_0; }

		//second=[kexpressions::ISignal]
		public Assignment getSecondAssignment_2() { return cSecondAssignment_2; }

		//[kexpressions::ISignal]
		public CrossReference getSecondISignalCrossReference_2_0() { return cSecondISignalCrossReference_2_0; }

		//ID
		public RuleCall getSecondISignalIDTerminalRuleCall_2_0_1() { return cSecondISignalIDTerminalRuleCall_2_0_1; }
	}

	public class RelationIncompatibilityElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.RelationIncompatibility");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cIncompAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cIncompISignalCrossReference_0_0 = (CrossReference)cIncompAssignment_0.eContents().get(0);
		private final RuleCall cIncompISignalIDTerminalRuleCall_0_0_1 = (RuleCall)cIncompISignalCrossReference_0_0.eContents().get(1);
		private final Assignment cTypeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Keyword cTypeNumberSignKeyword_1_0 = (Keyword)cTypeAssignment_1.eContents().get(0);
		private final Assignment cIncompAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final CrossReference cIncompISignalCrossReference_2_0 = (CrossReference)cIncompAssignment_2.eContents().get(0);
		private final RuleCall cIncompISignalIDTerminalRuleCall_2_0_1 = (RuleCall)cIncompISignalCrossReference_2_0.eContents().get(1);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cNumberSignKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cIncompAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final CrossReference cIncompISignalCrossReference_3_1_0 = (CrossReference)cIncompAssignment_3_1.eContents().get(0);
		private final RuleCall cIncompISignalIDTerminalRuleCall_3_1_0_1 = (RuleCall)cIncompISignalCrossReference_3_1_0.eContents().get(1);
		
		//RelationIncompatibility:
		//	incomp+=[kexpressions::ISignal] type="#" incomp+=[kexpressions::ISignal] ("#"
		//	incomp+=[kexpressions::ISignal])*;
		@Override public ParserRule getRule() { return rule; }

		//incomp+=[kexpressions::ISignal] type="#" incomp+=[kexpressions::ISignal] ("#" incomp+=[kexpressions::ISignal])*
		public Group getGroup() { return cGroup; }

		//incomp+=[kexpressions::ISignal]
		public Assignment getIncompAssignment_0() { return cIncompAssignment_0; }

		//[kexpressions::ISignal]
		public CrossReference getIncompISignalCrossReference_0_0() { return cIncompISignalCrossReference_0_0; }

		//ID
		public RuleCall getIncompISignalIDTerminalRuleCall_0_0_1() { return cIncompISignalIDTerminalRuleCall_0_0_1; }

		//type="#"
		public Assignment getTypeAssignment_1() { return cTypeAssignment_1; }

		//"#"
		public Keyword getTypeNumberSignKeyword_1_0() { return cTypeNumberSignKeyword_1_0; }

		//incomp+=[kexpressions::ISignal]
		public Assignment getIncompAssignment_2() { return cIncompAssignment_2; }

		//[kexpressions::ISignal]
		public CrossReference getIncompISignalCrossReference_2_0() { return cIncompISignalCrossReference_2_0; }

		//ID
		public RuleCall getIncompISignalIDTerminalRuleCall_2_0_1() { return cIncompISignalIDTerminalRuleCall_2_0_1; }

		//("#" incomp+=[kexpressions::ISignal])*
		public Group getGroup_3() { return cGroup_3; }

		//"#"
		public Keyword getNumberSignKeyword_3_0() { return cNumberSignKeyword_3_0; }

		//incomp+=[kexpressions::ISignal]
		public Assignment getIncompAssignment_3_1() { return cIncompAssignment_3_1; }

		//[kexpressions::ISignal]
		public CrossReference getIncompISignalCrossReference_3_1_0() { return cIncompISignalCrossReference_3_1_0; }

		//ID
		public RuleCall getIncompISignalIDTerminalRuleCall_3_1_0_1() { return cIncompISignalIDTerminalRuleCall_3_1_0_1; }
	}

	public class TypeDeclElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.TypeDecl");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cTypeKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cTypesAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cTypesTypeParserRuleCall_1_0 = (RuleCall)cTypesAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cCommaKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cTypesAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cTypesTypeParserRuleCall_2_1_0 = (RuleCall)cTypesAssignment_2_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//// ==> Types
		//// -------------------------------------
		//TypeDecl:
		//	"type" types+=Type ("," types+=Type)* ";";
		@Override public ParserRule getRule() { return rule; }

		//"type" types+=Type ("," types+=Type)* ";"
		public Group getGroup() { return cGroup; }

		//"type"
		public Keyword getTypeKeyword_0() { return cTypeKeyword_0; }

		//types+=Type
		public Assignment getTypesAssignment_1() { return cTypesAssignment_1; }

		//Type
		public RuleCall getTypesTypeParserRuleCall_1_0() { return cTypesTypeParserRuleCall_1_0; }

		//("," types+=Type)*
		public Group getGroup_2() { return cGroup_2; }

		//","
		public Keyword getCommaKeyword_2_0() { return cCommaKeyword_2_0; }

		//types+=Type
		public Assignment getTypesAssignment_2_1() { return cTypesAssignment_2_1; }

		//Type
		public RuleCall getTypesTypeParserRuleCall_2_1_0() { return cTypesTypeParserRuleCall_2_1_0; }

		//";"
		public Keyword getSemicolonKeyword_3() { return cSemicolonKeyword_3; }
	}

	public class TypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.Type");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_0 = (RuleCall)cNameAssignment.eContents().get(0);
		
		//Type:
		//	name=ID;
		@Override public ParserRule getRule() { return rule; }

		//name=ID
		public Assignment getNameAssignment() { return cNameAssignment; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_0() { return cNameIDTerminalRuleCall_0; }
	}

	public class ConstantDeclsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.ConstantDecls");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cConstantKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cConstantsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cConstantsOneTypeConstantDeclsParserRuleCall_1_0 = (RuleCall)cConstantsAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cCommaKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cConstantsAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cConstantsOneTypeConstantDeclsParserRuleCall_2_1_0 = (RuleCall)cConstantsAssignment_2_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//// ==> Constants
		//// -------------------------------------
		//ConstantDecls:
		//	"constant" constants+=OneTypeConstantDecls ("," constants+=OneTypeConstantDecls)* ";";
		@Override public ParserRule getRule() { return rule; }

		//"constant" constants+=OneTypeConstantDecls ("," constants+=OneTypeConstantDecls)* ";"
		public Group getGroup() { return cGroup; }

		//"constant"
		public Keyword getConstantKeyword_0() { return cConstantKeyword_0; }

		//constants+=OneTypeConstantDecls
		public Assignment getConstantsAssignment_1() { return cConstantsAssignment_1; }

		//OneTypeConstantDecls
		public RuleCall getConstantsOneTypeConstantDeclsParserRuleCall_1_0() { return cConstantsOneTypeConstantDeclsParserRuleCall_1_0; }

		//("," constants+=OneTypeConstantDecls)*
		public Group getGroup_2() { return cGroup_2; }

		//","
		public Keyword getCommaKeyword_2_0() { return cCommaKeyword_2_0; }

		//constants+=OneTypeConstantDecls
		public Assignment getConstantsAssignment_2_1() { return cConstantsAssignment_2_1; }

		//OneTypeConstantDecls
		public RuleCall getConstantsOneTypeConstantDeclsParserRuleCall_2_1_0() { return cConstantsOneTypeConstantDeclsParserRuleCall_2_1_0; }

		//";"
		public Keyword getSemicolonKeyword_3() { return cSemicolonKeyword_3; }
	}

	public class OneTypeConstantDeclsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.OneTypeConstantDecls");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cConstantsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cConstantsConstantWithValueParserRuleCall_0_0 = (RuleCall)cConstantsAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCommaKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cConstantsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cConstantsConstantWithValueParserRuleCall_1_1_0 = (RuleCall)cConstantsAssignment_1_1.eContents().get(0);
		private final Keyword cColonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cTypeAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cTypeTypeIdentifierParserRuleCall_3_0 = (RuleCall)cTypeAssignment_3.eContents().get(0);
		
		//OneTypeConstantDecls:
		//	constants+=ConstantWithValue ("," constants+=ConstantWithValue)* ":" type=TypeIdentifier;
		@Override public ParserRule getRule() { return rule; }

		//constants+=ConstantWithValue ("," constants+=ConstantWithValue)* ":" type=TypeIdentifier
		public Group getGroup() { return cGroup; }

		//constants+=ConstantWithValue
		public Assignment getConstantsAssignment_0() { return cConstantsAssignment_0; }

		//ConstantWithValue
		public RuleCall getConstantsConstantWithValueParserRuleCall_0_0() { return cConstantsConstantWithValueParserRuleCall_0_0; }

		//("," constants+=ConstantWithValue)*
		public Group getGroup_1() { return cGroup_1; }

		//","
		public Keyword getCommaKeyword_1_0() { return cCommaKeyword_1_0; }

		//constants+=ConstantWithValue
		public Assignment getConstantsAssignment_1_1() { return cConstantsAssignment_1_1; }

		//ConstantWithValue
		public RuleCall getConstantsConstantWithValueParserRuleCall_1_1_0() { return cConstantsConstantWithValueParserRuleCall_1_1_0; }

		//":"
		public Keyword getColonKeyword_2() { return cColonKeyword_2; }

		//type=TypeIdentifier
		public Assignment getTypeAssignment_3() { return cTypeAssignment_3; }

		//TypeIdentifier
		public RuleCall getTypeTypeIdentifierParserRuleCall_3_0() { return cTypeTypeIdentifierParserRuleCall_3_0; }
	}

	public class ConstantWithValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.ConstantWithValue");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cConstantAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cConstantConstantParserRuleCall_0_0 = (RuleCall)cConstantAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cEqualsSignKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cValueAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cValueConstantAtomParserRuleCall_1_1_0 = (RuleCall)cValueAssignment_1_1.eContents().get(0);
		
		//ConstantWithValue:
		//	constant=Constant ("=" value=ConstantAtom)?;
		@Override public ParserRule getRule() { return rule; }

		//constant=Constant ("=" value=ConstantAtom)?
		public Group getGroup() { return cGroup; }

		//constant=Constant
		public Assignment getConstantAssignment_0() { return cConstantAssignment_0; }

		//Constant
		public RuleCall getConstantConstantParserRuleCall_0_0() { return cConstantConstantParserRuleCall_0_0; }

		//("=" value=ConstantAtom)?
		public Group getGroup_1() { return cGroup_1; }

		//"="
		public Keyword getEqualsSignKeyword_1_0() { return cEqualsSignKeyword_1_0; }

		//value=ConstantAtom
		public Assignment getValueAssignment_1_1() { return cValueAssignment_1_1; }

		//ConstantAtom
		public RuleCall getValueConstantAtomParserRuleCall_1_1_0() { return cValueConstantAtomParserRuleCall_1_1_0; }
	}

	public class ConstantElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.Constant");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cConstantAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		
		//Constant kexpressions::ValuedObject:
		//	{Constant} name=ID
		@Override public ParserRule getRule() { return rule; }

		//{Constant} name=ID
		public Group getGroup() { return cGroup; }

		//{Constant}
		public Action getConstantAction_0() { return cConstantAction_0; }

		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
	}

	public class ConstantAtomElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.ConstantAtom");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cConstantLiteralParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//ConstantAtom:
		//	INT | ConstantLiteral;
		@Override public ParserRule getRule() { return rule; }

		//INT | ConstantLiteral
		public Alternatives getAlternatives() { return cAlternatives; }

		//INT
		public RuleCall getINTTerminalRuleCall_0() { return cINTTerminalRuleCall_0; }

		//ConstantLiteral
		public RuleCall getConstantLiteralParserRuleCall_1() { return cConstantLiteralParserRuleCall_1; }
	}

	public class ConstantLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.ConstantLiteral");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cFLOATTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cBOOLEANTerminalRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cIDTerminalRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cSTRINGTerminalRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//ConstantLiteral:
		//	FLOAT | BOOLEAN | ID | STRING;
		@Override public ParserRule getRule() { return rule; }

		//FLOAT | BOOLEAN | ID | STRING
		public Alternatives getAlternatives() { return cAlternatives; }

		//FLOAT
		public RuleCall getFLOATTerminalRuleCall_0() { return cFLOATTerminalRuleCall_0; }

		//BOOLEAN
		public RuleCall getBOOLEANTerminalRuleCall_1() { return cBOOLEANTerminalRuleCall_1; }

		//ID
		public RuleCall getIDTerminalRuleCall_2() { return cIDTerminalRuleCall_2; }

		//STRING
		public RuleCall getSTRINGTerminalRuleCall_3() { return cSTRINGTerminalRuleCall_3; }
	}

	public class FunctionDeclElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.FunctionDecl");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cFunctionKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cFunctionsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cFunctionsFunctionParserRuleCall_1_0 = (RuleCall)cFunctionsAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cCommaKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cFunctionsAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cFunctionsFunctionParserRuleCall_2_1_0 = (RuleCall)cFunctionsAssignment_2_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//// ==> Functions
		//// -------------------------------------
		//FunctionDecl:
		//	"function" functions+=Function ("," functions+=Function)* ";";
		@Override public ParserRule getRule() { return rule; }

		//"function" functions+=Function ("," functions+=Function)* ";"
		public Group getGroup() { return cGroup; }

		//"function"
		public Keyword getFunctionKeyword_0() { return cFunctionKeyword_0; }

		//functions+=Function
		public Assignment getFunctionsAssignment_1() { return cFunctionsAssignment_1; }

		//Function
		public RuleCall getFunctionsFunctionParserRuleCall_1_0() { return cFunctionsFunctionParserRuleCall_1_0; }

		//("," functions+=Function)*
		public Group getGroup_2() { return cGroup_2; }

		//","
		public Keyword getCommaKeyword_2_0() { return cCommaKeyword_2_0; }

		//functions+=Function
		public Assignment getFunctionsAssignment_2_1() { return cFunctionsAssignment_2_1; }

		//Function
		public RuleCall getFunctionsFunctionParserRuleCall_2_1_0() { return cFunctionsFunctionParserRuleCall_2_1_0; }

		//";"
		public Keyword getSemicolonKeyword_3() { return cSemicolonKeyword_3; }
	}

	public class FunctionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.Function");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIDTerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cIdListAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cIdListTypeIdentifierParserRuleCall_2_0_0 = (RuleCall)cIdListAssignment_2_0.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cGroup_2.eContents().get(1);
		private final Keyword cCommaKeyword_2_1_0 = (Keyword)cGroup_2_1.eContents().get(0);
		private final Assignment cIdListAssignment_2_1_1 = (Assignment)cGroup_2_1.eContents().get(1);
		private final RuleCall cIdListTypeIdentifierParserRuleCall_2_1_1_0 = (RuleCall)cIdListAssignment_2_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Keyword cColonKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cTypeAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cTypeTypeIdentifierParserRuleCall_5_0 = (RuleCall)cTypeAssignment_5.eContents().get(0);
		
		//Function:
		//	name=ID "(" (idList+=TypeIdentifier ("," idList+=TypeIdentifier)*)? ")" ":" type=TypeIdentifier;
		@Override public ParserRule getRule() { return rule; }

		//name=ID "(" (idList+=TypeIdentifier ("," idList+=TypeIdentifier)*)? ")" ":" type=TypeIdentifier
		public Group getGroup() { return cGroup; }

		//name=ID
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_0_0() { return cNameIDTerminalRuleCall_0_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//(idList+=TypeIdentifier ("," idList+=TypeIdentifier)*)?
		public Group getGroup_2() { return cGroup_2; }

		//idList+=TypeIdentifier
		public Assignment getIdListAssignment_2_0() { return cIdListAssignment_2_0; }

		//TypeIdentifier
		public RuleCall getIdListTypeIdentifierParserRuleCall_2_0_0() { return cIdListTypeIdentifierParserRuleCall_2_0_0; }

		//("," idList+=TypeIdentifier)*
		public Group getGroup_2_1() { return cGroup_2_1; }

		//","
		public Keyword getCommaKeyword_2_1_0() { return cCommaKeyword_2_1_0; }

		//idList+=TypeIdentifier
		public Assignment getIdListAssignment_2_1_1() { return cIdListAssignment_2_1_1; }

		//TypeIdentifier
		public RuleCall getIdListTypeIdentifierParserRuleCall_2_1_1_0() { return cIdListTypeIdentifierParserRuleCall_2_1_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }

		//":"
		public Keyword getColonKeyword_4() { return cColonKeyword_4; }

		//type=TypeIdentifier
		public Assignment getTypeAssignment_5() { return cTypeAssignment_5; }

		//TypeIdentifier
		public RuleCall getTypeTypeIdentifierParserRuleCall_5_0() { return cTypeTypeIdentifierParserRuleCall_5_0; }
	}

	public class ProcedureDeclElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.ProcedureDecl");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cProcedureKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cProceduresAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cProceduresProcedureParserRuleCall_1_0 = (RuleCall)cProceduresAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cCommaKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cProceduresAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cProceduresProcedureParserRuleCall_2_1_0 = (RuleCall)cProceduresAssignment_2_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//// ==> Procedures
		//ProcedureDecl:
		//	"procedure" procedures+=Procedure ("," procedures+=Procedure)* ";";
		@Override public ParserRule getRule() { return rule; }

		//"procedure" procedures+=Procedure ("," procedures+=Procedure)* ";"
		public Group getGroup() { return cGroup; }

		//"procedure"
		public Keyword getProcedureKeyword_0() { return cProcedureKeyword_0; }

		//procedures+=Procedure
		public Assignment getProceduresAssignment_1() { return cProceduresAssignment_1; }

		//Procedure
		public RuleCall getProceduresProcedureParserRuleCall_1_0() { return cProceduresProcedureParserRuleCall_1_0; }

		//("," procedures+=Procedure)*
		public Group getGroup_2() { return cGroup_2; }

		//","
		public Keyword getCommaKeyword_2_0() { return cCommaKeyword_2_0; }

		//procedures+=Procedure
		public Assignment getProceduresAssignment_2_1() { return cProceduresAssignment_2_1; }

		//Procedure
		public RuleCall getProceduresProcedureParserRuleCall_2_1_0() { return cProceduresProcedureParserRuleCall_2_1_0; }

		//";"
		public Keyword getSemicolonKeyword_3() { return cSemicolonKeyword_3; }
	}

	public class ProcedureElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.Procedure");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIDTerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cIdList1Assignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cIdList1TypeIdentifierParserRuleCall_2_0_0 = (RuleCall)cIdList1Assignment_2_0.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cGroup_2.eContents().get(1);
		private final Keyword cCommaKeyword_2_1_0 = (Keyword)cGroup_2_1.eContents().get(0);
		private final Assignment cIdList1Assignment_2_1_1 = (Assignment)cGroup_2_1.eContents().get(1);
		private final RuleCall cIdList1TypeIdentifierParserRuleCall_2_1_1_0 = (RuleCall)cIdList1Assignment_2_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Keyword cLeftParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
		private final Assignment cIdList2Assignment_5_0 = (Assignment)cGroup_5.eContents().get(0);
		private final RuleCall cIdList2TypeIdentifierParserRuleCall_5_0_0 = (RuleCall)cIdList2Assignment_5_0.eContents().get(0);
		private final Group cGroup_5_1 = (Group)cGroup_5.eContents().get(1);
		private final Keyword cCommaKeyword_5_1_0 = (Keyword)cGroup_5_1.eContents().get(0);
		private final Assignment cIdList2Assignment_5_1_1 = (Assignment)cGroup_5_1.eContents().get(1);
		private final RuleCall cIdList2TypeIdentifierParserRuleCall_5_1_1_0 = (RuleCall)cIdList2Assignment_5_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		//Procedure:
		//	name=ID "(" (idList1+=TypeIdentifier ("," idList1+=TypeIdentifier)*)? ")" "(" (idList2+=TypeIdentifier (","
		//	idList2+=TypeIdentifier)*)? ")";
		@Override public ParserRule getRule() { return rule; }

		//name=ID "(" (idList1+=TypeIdentifier ("," idList1+=TypeIdentifier)*)? ")" "(" (idList2+=TypeIdentifier (","
		//idList2+=TypeIdentifier)*)? ")"
		public Group getGroup() { return cGroup; }

		//name=ID
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_0_0() { return cNameIDTerminalRuleCall_0_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//(idList1+=TypeIdentifier ("," idList1+=TypeIdentifier)*)?
		public Group getGroup_2() { return cGroup_2; }

		//idList1+=TypeIdentifier
		public Assignment getIdList1Assignment_2_0() { return cIdList1Assignment_2_0; }

		//TypeIdentifier
		public RuleCall getIdList1TypeIdentifierParserRuleCall_2_0_0() { return cIdList1TypeIdentifierParserRuleCall_2_0_0; }

		//("," idList1+=TypeIdentifier)*
		public Group getGroup_2_1() { return cGroup_2_1; }

		//","
		public Keyword getCommaKeyword_2_1_0() { return cCommaKeyword_2_1_0; }

		//idList1+=TypeIdentifier
		public Assignment getIdList1Assignment_2_1_1() { return cIdList1Assignment_2_1_1; }

		//TypeIdentifier
		public RuleCall getIdList1TypeIdentifierParserRuleCall_2_1_1_0() { return cIdList1TypeIdentifierParserRuleCall_2_1_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }

		//"("
		public Keyword getLeftParenthesisKeyword_4() { return cLeftParenthesisKeyword_4; }

		//(idList2+=TypeIdentifier ("," idList2+=TypeIdentifier)*)?
		public Group getGroup_5() { return cGroup_5; }

		//idList2+=TypeIdentifier
		public Assignment getIdList2Assignment_5_0() { return cIdList2Assignment_5_0; }

		//TypeIdentifier
		public RuleCall getIdList2TypeIdentifierParserRuleCall_5_0_0() { return cIdList2TypeIdentifierParserRuleCall_5_0_0; }

		//("," idList2+=TypeIdentifier)*
		public Group getGroup_5_1() { return cGroup_5_1; }

		//","
		public Keyword getCommaKeyword_5_1_0() { return cCommaKeyword_5_1_0; }

		//idList2+=TypeIdentifier
		public Assignment getIdList2Assignment_5_1_1() { return cIdList2Assignment_5_1_1; }

		//TypeIdentifier
		public RuleCall getIdList2TypeIdentifierParserRuleCall_5_1_1_0() { return cIdList2TypeIdentifierParserRuleCall_5_1_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_6() { return cRightParenthesisKeyword_6; }
	}

	public class TaskDeclElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.TaskDecl");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cTaskKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cTasksAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cTasksTaskParserRuleCall_1_0 = (RuleCall)cTasksAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cCommaKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cTasksAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cTasksTaskParserRuleCall_2_1_0 = (RuleCall)cTasksAssignment_2_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//// ==> Tasks
		//TaskDecl:
		//	"task" tasks+=Task ("," tasks+=Task)* ";";
		@Override public ParserRule getRule() { return rule; }

		//"task" tasks+=Task ("," tasks+=Task)* ";"
		public Group getGroup() { return cGroup; }

		//"task"
		public Keyword getTaskKeyword_0() { return cTaskKeyword_0; }

		//tasks+=Task
		public Assignment getTasksAssignment_1() { return cTasksAssignment_1; }

		//Task
		public RuleCall getTasksTaskParserRuleCall_1_0() { return cTasksTaskParserRuleCall_1_0; }

		//("," tasks+=Task)*
		public Group getGroup_2() { return cGroup_2; }

		//","
		public Keyword getCommaKeyword_2_0() { return cCommaKeyword_2_0; }

		//tasks+=Task
		public Assignment getTasksAssignment_2_1() { return cTasksAssignment_2_1; }

		//Task
		public RuleCall getTasksTaskParserRuleCall_2_1_0() { return cTasksTaskParserRuleCall_2_1_0; }

		//";"
		public Keyword getSemicolonKeyword_3() { return cSemicolonKeyword_3; }
	}

	public class TaskElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.Task");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIDTerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cIdList1Assignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cIdList1TypeIdentifierParserRuleCall_2_0_0 = (RuleCall)cIdList1Assignment_2_0.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cGroup_2.eContents().get(1);
		private final Keyword cCommaKeyword_2_1_0 = (Keyword)cGroup_2_1.eContents().get(0);
		private final Assignment cIdList1Assignment_2_1_1 = (Assignment)cGroup_2_1.eContents().get(1);
		private final RuleCall cIdList1TypeIdentifierParserRuleCall_2_1_1_0 = (RuleCall)cIdList1Assignment_2_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Keyword cLeftParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
		private final Assignment cIdList2Assignment_5_0 = (Assignment)cGroup_5.eContents().get(0);
		private final RuleCall cIdList2TypeIdentifierParserRuleCall_5_0_0 = (RuleCall)cIdList2Assignment_5_0.eContents().get(0);
		private final Group cGroup_5_1 = (Group)cGroup_5.eContents().get(1);
		private final Keyword cCommaKeyword_5_1_0 = (Keyword)cGroup_5_1.eContents().get(0);
		private final Assignment cIdList2Assignment_5_1_1 = (Assignment)cGroup_5_1.eContents().get(1);
		private final RuleCall cIdList2TypeIdentifierParserRuleCall_5_1_1_0 = (RuleCall)cIdList2Assignment_5_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		//Task:
		//	name=ID "(" (idList1+=TypeIdentifier ("," idList1+=TypeIdentifier)*)? ")" "(" (idList2+=TypeIdentifier (","
		//	idList2+=TypeIdentifier)*)? ")";
		@Override public ParserRule getRule() { return rule; }

		//name=ID "(" (idList1+=TypeIdentifier ("," idList1+=TypeIdentifier)*)? ")" "(" (idList2+=TypeIdentifier (","
		//idList2+=TypeIdentifier)*)? ")"
		public Group getGroup() { return cGroup; }

		//name=ID
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_0_0() { return cNameIDTerminalRuleCall_0_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//(idList1+=TypeIdentifier ("," idList1+=TypeIdentifier)*)?
		public Group getGroup_2() { return cGroup_2; }

		//idList1+=TypeIdentifier
		public Assignment getIdList1Assignment_2_0() { return cIdList1Assignment_2_0; }

		//TypeIdentifier
		public RuleCall getIdList1TypeIdentifierParserRuleCall_2_0_0() { return cIdList1TypeIdentifierParserRuleCall_2_0_0; }

		//("," idList1+=TypeIdentifier)*
		public Group getGroup_2_1() { return cGroup_2_1; }

		//","
		public Keyword getCommaKeyword_2_1_0() { return cCommaKeyword_2_1_0; }

		//idList1+=TypeIdentifier
		public Assignment getIdList1Assignment_2_1_1() { return cIdList1Assignment_2_1_1; }

		//TypeIdentifier
		public RuleCall getIdList1TypeIdentifierParserRuleCall_2_1_1_0() { return cIdList1TypeIdentifierParserRuleCall_2_1_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }

		//"("
		public Keyword getLeftParenthesisKeyword_4() { return cLeftParenthesisKeyword_4; }

		//(idList2+=TypeIdentifier ("," idList2+=TypeIdentifier)*)?
		public Group getGroup_5() { return cGroup_5; }

		//idList2+=TypeIdentifier
		public Assignment getIdList2Assignment_5_0() { return cIdList2Assignment_5_0; }

		//TypeIdentifier
		public RuleCall getIdList2TypeIdentifierParserRuleCall_5_0_0() { return cIdList2TypeIdentifierParserRuleCall_5_0_0; }

		//("," idList2+=TypeIdentifier)*
		public Group getGroup_5_1() { return cGroup_5_1; }

		//","
		public Keyword getCommaKeyword_5_1_0() { return cCommaKeyword_5_1_0; }

		//idList2+=TypeIdentifier
		public Assignment getIdList2Assignment_5_1_1() { return cIdList2Assignment_5_1_1; }

		//TypeIdentifier
		public RuleCall getIdList2TypeIdentifierParserRuleCall_5_1_1_0() { return cIdList2TypeIdentifierParserRuleCall_5_1_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_6() { return cRightParenthesisKeyword_6; }
	}

	public class StatementContainerElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.StatementContainer");
		private final Assignment cStatementAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cStatementStatementParserRuleCall_0 = (RuleCall)cStatementAssignment.eContents().get(0);
		
		//StatementContainer:
		//	statement=Statement;
		@Override public ParserRule getRule() { return rule; }

		//statement=Statement
		public Assignment getStatementAssignment() { return cStatementAssignment; }

		//Statement
		public RuleCall getStatementStatementParserRuleCall_0() { return cStatementStatementParserRuleCall_0; }
	}

	public class StatementContainerInterfaceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.StatementContainerInterface");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cLocalSignalDeclParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cBlockParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cAbortParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cAbortInstanceParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cAbortCaseSingleParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cWeakAbortParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		private final RuleCall cWeakAbortInstanceParserRuleCall_6 = (RuleCall)cAlternatives.eContents().get(6);
		private final RuleCall cAwaitInstanceParserRuleCall_7 = (RuleCall)cAlternatives.eContents().get(7);
		private final RuleCall cDoParserRuleCall_8 = (RuleCall)cAlternatives.eContents().get(8);
		private final RuleCall cDoWatchingEndParserRuleCall_9 = (RuleCall)cAlternatives.eContents().get(9);
		private final RuleCall cEveryDoParserRuleCall_10 = (RuleCall)cAlternatives.eContents().get(10);
		private final RuleCall cThenPartParserRuleCall_11 = (RuleCall)cAlternatives.eContents().get(11);
		private final RuleCall cElsePartParserRuleCall_12 = (RuleCall)cAlternatives.eContents().get(12);
		private final RuleCall cLoopBodyParserRuleCall_13 = (RuleCall)cAlternatives.eContents().get(13);
		private final RuleCall cPresentCaseParserRuleCall_14 = (RuleCall)cAlternatives.eContents().get(14);
		private final RuleCall cRepeatParserRuleCall_15 = (RuleCall)cAlternatives.eContents().get(15);
		private final RuleCall cSuspendParserRuleCall_16 = (RuleCall)cAlternatives.eContents().get(16);
		private final RuleCall cWeakSuspendParserRuleCall_17 = (RuleCall)cAlternatives.eContents().get(17);
		private final RuleCall cTrapParserRuleCall_18 = (RuleCall)cAlternatives.eContents().get(18);
		private final RuleCall cTrapHandlerParserRuleCall_19 = (RuleCall)cAlternatives.eContents().get(19);
		private final RuleCall cLocalVariableParserRuleCall_20 = (RuleCall)cAlternatives.eContents().get(20);
		private final RuleCall cExecParserRuleCall_21 = (RuleCall)cAlternatives.eContents().get(21);
		private final RuleCall cExecCaseParserRuleCall_22 = (RuleCall)cAlternatives.eContents().get(22);
		
		//StatementContainerInterface StatementContainer:
		//	LocalSignalDecl | Block | Abort | AbortInstance | AbortCaseSingle | WeakAbort | WeakAbortInstance | AwaitInstance |
		//	Do | DoWatchingEnd | EveryDo | ThenPart | ElsePart | LoopBody | PresentCase | Repeat | Suspend | WeakSuspend | Trap |
		//	TrapHandler | LocalVariable | Exec | ExecCase
		@Override public ParserRule getRule() { return rule; }

		//LocalSignalDecl | Block | Abort | AbortInstance | AbortCaseSingle | WeakAbort | WeakAbortInstance | AwaitInstance | Do |
		//DoWatchingEnd | EveryDo | ThenPart | ElsePart | LoopBody | PresentCase | Repeat | Suspend | WeakSuspend | Trap |
		//TrapHandler | LocalVariable | Exec | ExecCase
		public Alternatives getAlternatives() { return cAlternatives; }

		//LocalSignalDecl
		public RuleCall getLocalSignalDeclParserRuleCall_0() { return cLocalSignalDeclParserRuleCall_0; }

		//Block
		public RuleCall getBlockParserRuleCall_1() { return cBlockParserRuleCall_1; }

		//Abort
		public RuleCall getAbortParserRuleCall_2() { return cAbortParserRuleCall_2; }

		//AbortInstance
		public RuleCall getAbortInstanceParserRuleCall_3() { return cAbortInstanceParserRuleCall_3; }

		//AbortCaseSingle
		public RuleCall getAbortCaseSingleParserRuleCall_4() { return cAbortCaseSingleParserRuleCall_4; }

		//WeakAbort
		public RuleCall getWeakAbortParserRuleCall_5() { return cWeakAbortParserRuleCall_5; }

		//WeakAbortInstance
		public RuleCall getWeakAbortInstanceParserRuleCall_6() { return cWeakAbortInstanceParserRuleCall_6; }

		//AwaitInstance
		public RuleCall getAwaitInstanceParserRuleCall_7() { return cAwaitInstanceParserRuleCall_7; }

		//Do
		public RuleCall getDoParserRuleCall_8() { return cDoParserRuleCall_8; }

		//DoWatchingEnd
		public RuleCall getDoWatchingEndParserRuleCall_9() { return cDoWatchingEndParserRuleCall_9; }

		//EveryDo
		public RuleCall getEveryDoParserRuleCall_10() { return cEveryDoParserRuleCall_10; }

		//ThenPart
		public RuleCall getThenPartParserRuleCall_11() { return cThenPartParserRuleCall_11; }

		//ElsePart
		public RuleCall getElsePartParserRuleCall_12() { return cElsePartParserRuleCall_12; }

		//LoopBody
		public RuleCall getLoopBodyParserRuleCall_13() { return cLoopBodyParserRuleCall_13; }

		//PresentCase
		public RuleCall getPresentCaseParserRuleCall_14() { return cPresentCaseParserRuleCall_14; }

		//Repeat
		public RuleCall getRepeatParserRuleCall_15() { return cRepeatParserRuleCall_15; }

		//Suspend
		public RuleCall getSuspendParserRuleCall_16() { return cSuspendParserRuleCall_16; }

		//WeakSuspend
		public RuleCall getWeakSuspendParserRuleCall_17() { return cWeakSuspendParserRuleCall_17; }

		//Trap
		public RuleCall getTrapParserRuleCall_18() { return cTrapParserRuleCall_18; }

		//TrapHandler
		public RuleCall getTrapHandlerParserRuleCall_19() { return cTrapHandlerParserRuleCall_19; }

		//LocalVariable
		public RuleCall getLocalVariableParserRuleCall_20() { return cLocalVariableParserRuleCall_20; }

		//Exec
		public RuleCall getExecParserRuleCall_21() { return cExecParserRuleCall_21; }

		//ExecCase
		public RuleCall getExecCaseParserRuleCall_22() { return cExecCaseParserRuleCall_22; }
	}

	public class StatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.Statement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cSequenceParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cParallelListAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cGroup_1.eContents().get(1);
		private final Keyword cVerticalLineVerticalLineKeyword_1_1_0 = (Keyword)cGroup_1_1.eContents().get(0);
		private final Assignment cListAssignment_1_1_1 = (Assignment)cGroup_1_1.eContents().get(1);
		private final RuleCall cListSequenceParserRuleCall_1_1_1_0 = (RuleCall)cListAssignment_1_1_1.eContents().get(0);
		
		//// ==============================================
		//// ===            B.4 Statements              ===
		//// ==============================================
		//// !-(parallel)
		//Statement:
		//	Sequence ({Parallel.list+=current} ("||" list+=Sequence)+)?;
		@Override public ParserRule getRule() { return rule; }

		////was Sequence ({Parallel.list+=current} "||" list+=Sequence)*; (uru)
		//Sequence ({Parallel.list+=current} ("||" list+=Sequence)+)?
		public Group getGroup() { return cGroup; }

		////was Sequence ({Parallel.list+=current} "||" list+=Sequence)*; (uru)
		//Sequence
		public RuleCall getSequenceParserRuleCall_0() { return cSequenceParserRuleCall_0; }

		//({Parallel.list+=current} ("||" list+=Sequence)+)?
		public Group getGroup_1() { return cGroup_1; }

		//{Parallel.list+=current}
		public Action getParallelListAction_1_0() { return cParallelListAction_1_0; }

		//("||" list+=Sequence)+
		public Group getGroup_1_1() { return cGroup_1_1; }

		//"||"
		public Keyword getVerticalLineVerticalLineKeyword_1_1_0() { return cVerticalLineVerticalLineKeyword_1_1_0; }

		//list+=Sequence
		public Assignment getListAssignment_1_1_1() { return cListAssignment_1_1_1; }

		//Sequence
		public RuleCall getListSequenceParserRuleCall_1_1_1_0() { return cListSequenceParserRuleCall_1_1_1_0; }
	}

	public class AtomicStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.AtomicStatement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cAbortParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cAssignmentParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cAwaitParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cBlockParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cProcCallParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cDoParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		private final RuleCall cEmitParserRuleCall_6 = (RuleCall)cAlternatives.eContents().get(6);
		private final RuleCall cUnEmitParserRuleCall_7 = (RuleCall)cAlternatives.eContents().get(7);
		private final RuleCall cResetParserRuleCall_8 = (RuleCall)cAlternatives.eContents().get(8);
		private final RuleCall cEveryDoParserRuleCall_9 = (RuleCall)cAlternatives.eContents().get(9);
		private final RuleCall cExitParserRuleCall_10 = (RuleCall)cAlternatives.eContents().get(10);
		private final RuleCall cExecParserRuleCall_11 = (RuleCall)cAlternatives.eContents().get(11);
		private final RuleCall cHaltParserRuleCall_12 = (RuleCall)cAlternatives.eContents().get(12);
		private final RuleCall cIfTestParserRuleCall_13 = (RuleCall)cAlternatives.eContents().get(13);
		private final RuleCall cLocalSignalDeclParserRuleCall_14 = (RuleCall)cAlternatives.eContents().get(14);
		private final RuleCall cLoopParserRuleCall_15 = (RuleCall)cAlternatives.eContents().get(15);
		private final RuleCall cNothingParserRuleCall_16 = (RuleCall)cAlternatives.eContents().get(16);
		private final RuleCall cPauseParserRuleCall_17 = (RuleCall)cAlternatives.eContents().get(17);
		private final RuleCall cPresentParserRuleCall_18 = (RuleCall)cAlternatives.eContents().get(18);
		private final RuleCall cRepeatParserRuleCall_19 = (RuleCall)cAlternatives.eContents().get(19);
		private final RuleCall cRunParserRuleCall_20 = (RuleCall)cAlternatives.eContents().get(20);
		private final RuleCall cSuspendParserRuleCall_21 = (RuleCall)cAlternatives.eContents().get(21);
		private final RuleCall cWeakSuspendParserRuleCall_22 = (RuleCall)cAlternatives.eContents().get(22);
		private final RuleCall cSustainParserRuleCall_23 = (RuleCall)cAlternatives.eContents().get(23);
		private final RuleCall cTrapParserRuleCall_24 = (RuleCall)cAlternatives.eContents().get(24);
		private final RuleCall cLocalVariableParserRuleCall_25 = (RuleCall)cAlternatives.eContents().get(25);
		private final RuleCall cWeakAbortParserRuleCall_26 = (RuleCall)cAlternatives.eContents().get(26);
		
		//// -!
		//AtomicStatement Statement:
		//	Abort | Assignment | Await | Block | ProcCall | Do | Emit | UnEmit | Reset | EveryDo | Exit | Exec | Halt | IfTest |
		//	LocalSignalDecl | Loop | Nothing | Pause | Present | Repeat | Run | Suspend | WeakSuspend | Sustain | Trap |
		//	LocalVariable | WeakAbort
		@Override public ParserRule getRule() { return rule; }

		//Abort | Assignment | Await | Block | ProcCall | Do | Emit | UnEmit | Reset | EveryDo | Exit | Exec | Halt | IfTest |
		//LocalSignalDecl | Loop | Nothing | Pause | Present | Repeat | Run | Suspend | WeakSuspend | Sustain | Trap |
		//LocalVariable | WeakAbort
		public Alternatives getAlternatives() { return cAlternatives; }

		//Abort
		public RuleCall getAbortParserRuleCall_0() { return cAbortParserRuleCall_0; }

		//Assignment
		public RuleCall getAssignmentParserRuleCall_1() { return cAssignmentParserRuleCall_1; }

		//Await
		public RuleCall getAwaitParserRuleCall_2() { return cAwaitParserRuleCall_2; }

		//Block
		public RuleCall getBlockParserRuleCall_3() { return cBlockParserRuleCall_3; }

		//ProcCall
		public RuleCall getProcCallParserRuleCall_4() { return cProcCallParserRuleCall_4; }

		//Do
		public RuleCall getDoParserRuleCall_5() { return cDoParserRuleCall_5; }

		//Emit
		public RuleCall getEmitParserRuleCall_6() { return cEmitParserRuleCall_6; }

		//UnEmit
		public RuleCall getUnEmitParserRuleCall_7() { return cUnEmitParserRuleCall_7; }

		//Reset
		public RuleCall getResetParserRuleCall_8() { return cResetParserRuleCall_8; }

		//EveryDo
		public RuleCall getEveryDoParserRuleCall_9() { return cEveryDoParserRuleCall_9; }

		//Exit
		public RuleCall getExitParserRuleCall_10() { return cExitParserRuleCall_10; }

		//Exec
		public RuleCall getExecParserRuleCall_11() { return cExecParserRuleCall_11; }

		//Halt
		public RuleCall getHaltParserRuleCall_12() { return cHaltParserRuleCall_12; }

		//IfTest
		public RuleCall getIfTestParserRuleCall_13() { return cIfTestParserRuleCall_13; }

		//LocalSignalDecl
		public RuleCall getLocalSignalDeclParserRuleCall_14() { return cLocalSignalDeclParserRuleCall_14; }

		//Loop
		public RuleCall getLoopParserRuleCall_15() { return cLoopParserRuleCall_15; }

		//Nothing
		public RuleCall getNothingParserRuleCall_16() { return cNothingParserRuleCall_16; }

		//Pause
		public RuleCall getPauseParserRuleCall_17() { return cPauseParserRuleCall_17; }

		//Present
		public RuleCall getPresentParserRuleCall_18() { return cPresentParserRuleCall_18; }

		//Repeat
		public RuleCall getRepeatParserRuleCall_19() { return cRepeatParserRuleCall_19; }

		//Run
		public RuleCall getRunParserRuleCall_20() { return cRunParserRuleCall_20; }

		//Suspend
		public RuleCall getSuspendParserRuleCall_21() { return cSuspendParserRuleCall_21; }

		//WeakSuspend
		public RuleCall getWeakSuspendParserRuleCall_22() { return cWeakSuspendParserRuleCall_22; }

		//Sustain
		public RuleCall getSustainParserRuleCall_23() { return cSustainParserRuleCall_23; }

		//Trap
		public RuleCall getTrapParserRuleCall_24() { return cTrapParserRuleCall_24; }

		//LocalVariable
		public RuleCall getLocalVariableParserRuleCall_25() { return cLocalVariableParserRuleCall_25; }

		//WeakAbort
		public RuleCall getWeakAbortParserRuleCall_26() { return cWeakAbortParserRuleCall_26; }
	}

	public class SequenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.Sequence");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAtomicStatementParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cSequenceListAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cGroup_1.eContents().get(1);
		private final Keyword cSemicolonKeyword_1_1_0 = (Keyword)cGroup_1_1.eContents().get(0);
		private final Assignment cListAssignment_1_1_1 = (Assignment)cGroup_1_1.eContents().get(1);
		private final RuleCall cListAtomicStatementParserRuleCall_1_1_1_0 = (RuleCall)cListAssignment_1_1_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//// --> B.4.1 Control Flow Operators <--	
		//// !-(sequence)
		//Sequence Statement:
		//	AtomicStatement ({Sequence.list+=current} (";" list+=AtomicStatement)+)? ";"?
		@Override public ParserRule getRule() { return rule; }

		//// was AtomicStatement ({Sequence.list+=current} ";" list+=AtomicStatement)* ";"?; (uru)
		//AtomicStatement ({Sequence.list+=current} (";" list+=AtomicStatement)+)? ";"?
		public Group getGroup() { return cGroup; }

		//// was AtomicStatement ({Sequence.list+=current} ";" list+=AtomicStatement)* ";"?; (uru)
		//AtomicStatement
		public RuleCall getAtomicStatementParserRuleCall_0() { return cAtomicStatementParserRuleCall_0; }

		//({Sequence.list+=current} (";" list+=AtomicStatement)+)?
		public Group getGroup_1() { return cGroup_1; }

		//{Sequence.list+=current}
		public Action getSequenceListAction_1_0() { return cSequenceListAction_1_0; }

		//(";" list+=AtomicStatement)+
		public Group getGroup_1_1() { return cGroup_1_1; }

		//";"
		public Keyword getSemicolonKeyword_1_1_0() { return cSemicolonKeyword_1_1_0; }

		//list+=AtomicStatement
		public Assignment getListAssignment_1_1_1() { return cListAssignment_1_1_1; }

		//AtomicStatement
		public RuleCall getListAtomicStatementParserRuleCall_1_1_1_0() { return cListAtomicStatementParserRuleCall_1_1_1_0; }

		//";"?
		public Keyword getSemicolonKeyword_2() { return cSemicolonKeyword_2; }
	}

	public class BlockElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.Block");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cStatementAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cStatementStatementParserRuleCall_1_0 = (RuleCall)cStatementAssignment_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//// -!
		//Block:
		//	"[" statement=Statement "]";
		@Override public ParserRule getRule() { return rule; }

		//"[" statement=Statement "]"
		public Group getGroup() { return cGroup; }

		//"["
		public Keyword getLeftSquareBracketKeyword_0() { return cLeftSquareBracketKeyword_0; }

		//statement=Statement
		public Assignment getStatementAssignment_1() { return cStatementAssignment_1; }

		//Statement
		public RuleCall getStatementStatementParserRuleCall_1_0() { return cStatementStatementParserRuleCall_1_0; }

		//"]"
		public Keyword getRightSquareBracketKeyword_2() { return cRightSquareBracketKeyword_2; }
	}

	public class AssignmentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.Assignment");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cVarAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cVarIVariableCrossReference_0_0 = (CrossReference)cVarAssignment_0.eContents().get(0);
		private final RuleCall cVarIVariableIDTerminalRuleCall_0_0_1 = (RuleCall)cVarIVariableCrossReference_0_0.eContents().get(1);
		private final Keyword cColonEqualsSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cExprAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cExprExpressionParserRuleCall_2_0 = (RuleCall)cExprAssignment_2.eContents().get(0);
		
		//// Assignment
		//// !-(assign) -------------------------------------
		//Assignment:
		//	var=[kexpressions::IVariable] ":=" expr=Expression;
		@Override public ParserRule getRule() { return rule; }

		//var=[kexpressions::IVariable] ":=" expr=Expression
		public Group getGroup() { return cGroup; }

		//var=[kexpressions::IVariable]
		public Assignment getVarAssignment_0() { return cVarAssignment_0; }

		//[kexpressions::IVariable]
		public CrossReference getVarIVariableCrossReference_0_0() { return cVarIVariableCrossReference_0_0; }

		//ID
		public RuleCall getVarIVariableIDTerminalRuleCall_0_0_1() { return cVarIVariableIDTerminalRuleCall_0_0_1; }

		//":="
		public Keyword getColonEqualsSignKeyword_1() { return cColonEqualsSignKeyword_1; }

		//expr=Expression
		public Assignment getExprAssignment_2() { return cExprAssignment_2; }

		//Expression
		public RuleCall getExprExpressionParserRuleCall_2_0() { return cExprExpressionParserRuleCall_2_0; }
	}

	public class AbortElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.Abort");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cAbortKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cStatementAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cStatementStatementParserRuleCall_1_0 = (RuleCall)cStatementAssignment_1.eContents().get(0);
		private final Keyword cWhenKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cBodyAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cBodyAbortBodyParserRuleCall_3_0 = (RuleCall)cBodyAssignment_3.eContents().get(0);
		
		//// -!
		//// !-(abort) --> B.4.2 abort: Strong Preemption
		//// -------------------------------------
		//Abort:
		//	"abort" statement=Statement "when" body=AbortBody;
		@Override public ParserRule getRule() { return rule; }

		//"abort" statement=Statement "when" body=AbortBody
		public Group getGroup() { return cGroup; }

		//"abort"
		public Keyword getAbortKeyword_0() { return cAbortKeyword_0; }

		//statement=Statement
		public Assignment getStatementAssignment_1() { return cStatementAssignment_1; }

		//Statement
		public RuleCall getStatementStatementParserRuleCall_1_0() { return cStatementStatementParserRuleCall_1_0; }

		//"when"
		public Keyword getWhenKeyword_2() { return cWhenKeyword_2; }

		//body=AbortBody
		public Assignment getBodyAssignment_3() { return cBodyAssignment_3; }

		//AbortBody
		public RuleCall getBodyAbortBodyParserRuleCall_3_0() { return cBodyAbortBodyParserRuleCall_3_0; }
	}

	public class AbortBodyElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.AbortBody");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cAbortInstanceParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cAbortCaseParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//AbortBody:
		//	AbortInstance | AbortCase;
		@Override public ParserRule getRule() { return rule; }

		//AbortInstance | AbortCase
		public Alternatives getAlternatives() { return cAlternatives; }

		//AbortInstance
		public RuleCall getAbortInstanceParserRuleCall_0() { return cAbortInstanceParserRuleCall_0; }

		//AbortCase
		public RuleCall getAbortCaseParserRuleCall_1() { return cAbortCaseParserRuleCall_1; }
	}

	public class AbortInstanceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.AbortInstance");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cDelayAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cDelayDelayExprParserRuleCall_0_0 = (RuleCall)cDelayAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cDoKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cStatementAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cStatementStatementParserRuleCall_1_1_0 = (RuleCall)cStatementAssignment_1_1.eContents().get(0);
		private final Keyword cEndKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		private final Assignment cOptEndAssignment_1_3 = (Assignment)cGroup_1.eContents().get(3);
		private final Keyword cOptEndAbortKeyword_1_3_0 = (Keyword)cOptEndAssignment_1_3.eContents().get(0);
		
		//AbortInstance:
		//	delay=DelayExpr ("do" statement=Statement "end" optEnd="abort"?)?;
		@Override public ParserRule getRule() { return rule; }

		//delay=DelayExpr ("do" statement=Statement "end" optEnd="abort"?)?
		public Group getGroup() { return cGroup; }

		//delay=DelayExpr
		public Assignment getDelayAssignment_0() { return cDelayAssignment_0; }

		//DelayExpr
		public RuleCall getDelayDelayExprParserRuleCall_0_0() { return cDelayDelayExprParserRuleCall_0_0; }

		//("do" statement=Statement "end" optEnd="abort"?)?
		public Group getGroup_1() { return cGroup_1; }

		//"do"
		public Keyword getDoKeyword_1_0() { return cDoKeyword_1_0; }

		//statement=Statement
		public Assignment getStatementAssignment_1_1() { return cStatementAssignment_1_1; }

		//Statement
		public RuleCall getStatementStatementParserRuleCall_1_1_0() { return cStatementStatementParserRuleCall_1_1_0; }

		//"end"
		public Keyword getEndKeyword_1_2() { return cEndKeyword_1_2; }

		//optEnd="abort"?
		public Assignment getOptEndAssignment_1_3() { return cOptEndAssignment_1_3; }

		//"abort"
		public Keyword getOptEndAbortKeyword_1_3_0() { return cOptEndAbortKeyword_1_3_0; }
	}

	public class AbortCaseElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.AbortCase");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cCasesAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cCasesAbortCaseSingleParserRuleCall_0_0 = (RuleCall)cCasesAssignment_0.eContents().get(0);
		private final Assignment cCasesAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cCasesAbortCaseSingleParserRuleCall_1_0 = (RuleCall)cCasesAssignment_1.eContents().get(0);
		private final Keyword cEndKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cOptEndAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final Keyword cOptEndAbortKeyword_3_0 = (Keyword)cOptEndAssignment_3.eContents().get(0);
		
		//AbortCase:
		//	cases+=AbortCaseSingle cases+=AbortCaseSingle* "end" optEnd="abort"?;
		@Override public ParserRule getRule() { return rule; }

		//cases+=AbortCaseSingle cases+=AbortCaseSingle* "end" optEnd="abort"?
		public Group getGroup() { return cGroup; }

		//cases+=AbortCaseSingle
		public Assignment getCasesAssignment_0() { return cCasesAssignment_0; }

		//AbortCaseSingle
		public RuleCall getCasesAbortCaseSingleParserRuleCall_0_0() { return cCasesAbortCaseSingleParserRuleCall_0_0; }

		//cases+=AbortCaseSingle*
		public Assignment getCasesAssignment_1() { return cCasesAssignment_1; }

		//AbortCaseSingle
		public RuleCall getCasesAbortCaseSingleParserRuleCall_1_0() { return cCasesAbortCaseSingleParserRuleCall_1_0; }

		//"end"
		public Keyword getEndKeyword_2() { return cEndKeyword_2; }

		//optEnd="abort"?
		public Assignment getOptEndAssignment_3() { return cOptEndAssignment_3; }

		//"abort"
		public Keyword getOptEndAbortKeyword_3_0() { return cOptEndAbortKeyword_3_0; }
	}

	public class AbortCaseSingleElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.AbortCaseSingle");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cCaseKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cDelayAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cDelayDelayExprParserRuleCall_1_0 = (RuleCall)cDelayAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cDoKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cStatementAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cStatementStatementParserRuleCall_2_1_0 = (RuleCall)cStatementAssignment_2_1.eContents().get(0);
		
		//AbortCaseSingle:
		//	"case" delay=DelayExpr ("do" statement=Statement)?;
		@Override public ParserRule getRule() { return rule; }

		//"case" delay=DelayExpr ("do" statement=Statement)?
		public Group getGroup() { return cGroup; }

		//"case"
		public Keyword getCaseKeyword_0() { return cCaseKeyword_0; }

		//delay=DelayExpr
		public Assignment getDelayAssignment_1() { return cDelayAssignment_1; }

		//DelayExpr
		public RuleCall getDelayDelayExprParserRuleCall_1_0() { return cDelayDelayExprParserRuleCall_1_0; }

		//("do" statement=Statement)?
		public Group getGroup_2() { return cGroup_2; }

		//"do"
		public Keyword getDoKeyword_2_0() { return cDoKeyword_2_0; }

		//statement=Statement
		public Assignment getStatementAssignment_2_1() { return cStatementAssignment_2_1; }

		//Statement
		public RuleCall getStatementStatementParserRuleCall_2_1_0() { return cStatementStatementParserRuleCall_2_1_0; }
	}

	public class WeakAbortElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.WeakAbort");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cWeakAbortAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cWeakKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cAbortKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cStatementAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cStatementStatementParserRuleCall_3_0 = (RuleCall)cStatementAssignment_3.eContents().get(0);
		private final Keyword cWhenKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cBodyAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cBodyWeakAbortBodyParserRuleCall_5_0 = (RuleCall)cBodyAssignment_5.eContents().get(0);
		
		//// -!
		//// --> B.4.25 weak abort: Weak Preemption
		//// -------------------------------------
		//WeakAbort Abort:
		//	{WeakAbort} "weak" "abort" statement=Statement "when" body=WeakAbortBody
		@Override public ParserRule getRule() { return rule; }

		//{WeakAbort} "weak" "abort" statement=Statement "when" body=WeakAbortBody
		public Group getGroup() { return cGroup; }

		//{WeakAbort}
		public Action getWeakAbortAction_0() { return cWeakAbortAction_0; }

		//"weak"
		public Keyword getWeakKeyword_1() { return cWeakKeyword_1; }

		//"abort"
		public Keyword getAbortKeyword_2() { return cAbortKeyword_2; }

		//statement=Statement
		public Assignment getStatementAssignment_3() { return cStatementAssignment_3; }

		//Statement
		public RuleCall getStatementStatementParserRuleCall_3_0() { return cStatementStatementParserRuleCall_3_0; }

		//"when"
		public Keyword getWhenKeyword_4() { return cWhenKeyword_4; }

		//body=WeakAbortBody
		public Assignment getBodyAssignment_5() { return cBodyAssignment_5; }

		//WeakAbortBody
		public RuleCall getBodyWeakAbortBodyParserRuleCall_5_0() { return cBodyWeakAbortBodyParserRuleCall_5_0; }
	}

	public class WeakAbortBodyElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.WeakAbortBody");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cWeakAbortInstanceParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cWeakAbortCaseParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//WeakAbortBody:
		//	WeakAbortInstance | WeakAbortCase;
		@Override public ParserRule getRule() { return rule; }

		//WeakAbortInstance | WeakAbortCase
		public Alternatives getAlternatives() { return cAlternatives; }

		//WeakAbortInstance
		public RuleCall getWeakAbortInstanceParserRuleCall_0() { return cWeakAbortInstanceParserRuleCall_0; }

		//WeakAbortCase
		public RuleCall getWeakAbortCaseParserRuleCall_1() { return cWeakAbortCaseParserRuleCall_1; }
	}

	public class WeakAbortEndElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.WeakAbortEnd");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cWeakAbortEndAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cEndKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cOptEndAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cOptEndWeakAbortEndAltParserRuleCall_2_0 = (RuleCall)cOptEndAssignment_2.eContents().get(0);
		
		//WeakAbortEnd:
		//	{WeakAbortEnd} "end" optEnd=WeakAbortEndAlt?;
		@Override public ParserRule getRule() { return rule; }

		//{WeakAbortEnd} "end" optEnd=WeakAbortEndAlt?
		public Group getGroup() { return cGroup; }

		//{WeakAbortEnd}
		public Action getWeakAbortEndAction_0() { return cWeakAbortEndAction_0; }

		//"end"
		public Keyword getEndKeyword_1() { return cEndKeyword_1; }

		//optEnd=WeakAbortEndAlt?
		public Assignment getOptEndAssignment_2() { return cOptEndAssignment_2; }

		//WeakAbortEndAlt
		public RuleCall getOptEndWeakAbortEndAltParserRuleCall_2_0() { return cOptEndWeakAbortEndAltParserRuleCall_2_0; }
	}

	public class WeakAbortEndAltElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.WeakAbortEndAlt");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cEndAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cEndWeakKeyword_0_0 = (Keyword)cEndAssignment_0.eContents().get(0);
		private final Assignment cEndAAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Keyword cEndAAbortKeyword_1_0 = (Keyword)cEndAAssignment_1.eContents().get(0);
		
		//WeakAbortEndAlt:
		//	end="weak"? endA="abort";
		@Override public ParserRule getRule() { return rule; }

		//end="weak"? endA="abort"
		public Group getGroup() { return cGroup; }

		//end="weak"?
		public Assignment getEndAssignment_0() { return cEndAssignment_0; }

		//"weak"
		public Keyword getEndWeakKeyword_0_0() { return cEndWeakKeyword_0_0; }

		//endA="abort"
		public Assignment getEndAAssignment_1() { return cEndAAssignment_1; }

		//"abort"
		public Keyword getEndAAbortKeyword_1_0() { return cEndAAbortKeyword_1_0; }
	}

	public class WeakAbortInstanceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.WeakAbortInstance");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cWeakAbortInstanceAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cDelayAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cDelayDelayExprParserRuleCall_1_0 = (RuleCall)cDelayAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cDoKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cStatementAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cStatementStatementParserRuleCall_2_1_0 = (RuleCall)cStatementAssignment_2_1.eContents().get(0);
		private final Assignment cEndAssignment_2_2 = (Assignment)cGroup_2.eContents().get(2);
		private final RuleCall cEndWeakAbortEndParserRuleCall_2_2_0 = (RuleCall)cEndAssignment_2_2.eContents().get(0);
		
		//WeakAbortInstance AbortInstance:
		//	{WeakAbortInstance} delay=DelayExpr ("do" statement=Statement end=WeakAbortEnd)?
		@Override public ParserRule getRule() { return rule; }

		//{WeakAbortInstance} delay=DelayExpr ("do" statement=Statement end=WeakAbortEnd)?
		public Group getGroup() { return cGroup; }

		//{WeakAbortInstance}
		public Action getWeakAbortInstanceAction_0() { return cWeakAbortInstanceAction_0; }

		//delay=DelayExpr
		public Assignment getDelayAssignment_1() { return cDelayAssignment_1; }

		//DelayExpr
		public RuleCall getDelayDelayExprParserRuleCall_1_0() { return cDelayDelayExprParserRuleCall_1_0; }

		//("do" statement=Statement end=WeakAbortEnd)?
		public Group getGroup_2() { return cGroup_2; }

		//"do"
		public Keyword getDoKeyword_2_0() { return cDoKeyword_2_0; }

		//statement=Statement
		public Assignment getStatementAssignment_2_1() { return cStatementAssignment_2_1; }

		//Statement
		public RuleCall getStatementStatementParserRuleCall_2_1_0() { return cStatementStatementParserRuleCall_2_1_0; }

		//end=WeakAbortEnd
		public Assignment getEndAssignment_2_2() { return cEndAssignment_2_2; }

		//WeakAbortEnd
		public RuleCall getEndWeakAbortEndParserRuleCall_2_2_0() { return cEndWeakAbortEndParserRuleCall_2_2_0; }
	}

	public class WeakAbortCaseElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.WeakAbortCase");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cWeakAbortCaseAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cCasesAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cCasesAbortCaseSingleParserRuleCall_1_0 = (RuleCall)cCasesAssignment_1.eContents().get(0);
		private final Assignment cCasesAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cCasesAbortCaseSingleParserRuleCall_2_0 = (RuleCall)cCasesAssignment_2.eContents().get(0);
		private final Assignment cEndAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cEndWeakAbortEndParserRuleCall_3_0 = (RuleCall)cEndAssignment_3.eContents().get(0);
		
		//WeakAbortCase AbortCase:
		//	{WeakAbortCase} cases+=AbortCaseSingle cases+=AbortCaseSingle* end=WeakAbortEnd
		@Override public ParserRule getRule() { return rule; }

		//{WeakAbortCase} cases+=AbortCaseSingle cases+=AbortCaseSingle* end=WeakAbortEnd
		public Group getGroup() { return cGroup; }

		//{WeakAbortCase}
		public Action getWeakAbortCaseAction_0() { return cWeakAbortCaseAction_0; }

		//cases+=AbortCaseSingle
		public Assignment getCasesAssignment_1() { return cCasesAssignment_1; }

		//AbortCaseSingle
		public RuleCall getCasesAbortCaseSingleParserRuleCall_1_0() { return cCasesAbortCaseSingleParserRuleCall_1_0; }

		//cases+=AbortCaseSingle*
		public Assignment getCasesAssignment_2() { return cCasesAssignment_2; }

		//AbortCaseSingle
		public RuleCall getCasesAbortCaseSingleParserRuleCall_2_0() { return cCasesAbortCaseSingleParserRuleCall_2_0; }

		//end=WeakAbortEnd
		public Assignment getEndAssignment_3() { return cEndAssignment_3; }

		//WeakAbortEnd
		public RuleCall getEndWeakAbortEndParserRuleCall_3_0() { return cEndWeakAbortEndParserRuleCall_3_0; }
	}

	public class AwaitElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.Await");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cAwaitKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cBodyAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cBodyAwaitBodyParserRuleCall_1_0 = (RuleCall)cBodyAssignment_1.eContents().get(0);
		
		//// --> B.4.3 await: Strong Preemption
		//// !-(await) -------------------------------------
		//Await:
		//	"await" body=AwaitBody;
		@Override public ParserRule getRule() { return rule; }

		//"await" body=AwaitBody
		public Group getGroup() { return cGroup; }

		//"await"
		public Keyword getAwaitKeyword_0() { return cAwaitKeyword_0; }

		//body=AwaitBody
		public Assignment getBodyAssignment_1() { return cBodyAssignment_1; }

		//AwaitBody
		public RuleCall getBodyAwaitBodyParserRuleCall_1_0() { return cBodyAwaitBodyParserRuleCall_1_0; }
	}

	public class AwaitBodyElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.AwaitBody");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cAwaitInstanceParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cAwaitCaseParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//AwaitBody:
		//	AwaitInstance | AwaitCase;
		@Override public ParserRule getRule() { return rule; }

		//AwaitInstance | AwaitCase
		public Alternatives getAlternatives() { return cAlternatives; }

		//AwaitInstance
		public RuleCall getAwaitInstanceParserRuleCall_0() { return cAwaitInstanceParserRuleCall_0; }

		//AwaitCase
		public RuleCall getAwaitCaseParserRuleCall_1() { return cAwaitCaseParserRuleCall_1; }
	}

	public class AwaitInstanceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.AwaitInstance");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cDelayAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cDelayDelayExprParserRuleCall_0_0 = (RuleCall)cDelayAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cDoKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cStatementAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cStatementStatementParserRuleCall_1_1_0 = (RuleCall)cStatementAssignment_1_1.eContents().get(0);
		private final Assignment cEndAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cEndAwaitEndParserRuleCall_1_2_0 = (RuleCall)cEndAssignment_1_2.eContents().get(0);
		
		//AwaitInstance:
		//	delay=DelayExpr ("do" statement=Statement end=AwaitEnd)?;
		@Override public ParserRule getRule() { return rule; }

		//delay=DelayExpr ("do" statement=Statement end=AwaitEnd)?
		public Group getGroup() { return cGroup; }

		//delay=DelayExpr
		public Assignment getDelayAssignment_0() { return cDelayAssignment_0; }

		//DelayExpr
		public RuleCall getDelayDelayExprParserRuleCall_0_0() { return cDelayDelayExprParserRuleCall_0_0; }

		//("do" statement=Statement end=AwaitEnd)?
		public Group getGroup_1() { return cGroup_1; }

		//"do"
		public Keyword getDoKeyword_1_0() { return cDoKeyword_1_0; }

		//statement=Statement
		public Assignment getStatementAssignment_1_1() { return cStatementAssignment_1_1; }

		//Statement
		public RuleCall getStatementStatementParserRuleCall_1_1_0() { return cStatementStatementParserRuleCall_1_1_0; }

		//end=AwaitEnd
		public Assignment getEndAssignment_1_2() { return cEndAssignment_1_2; }

		//AwaitEnd
		public RuleCall getEndAwaitEndParserRuleCall_1_2_0() { return cEndAwaitEndParserRuleCall_1_2_0; }
	}

	public class AwaitCaseElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.AwaitCase");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cCasesAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cCasesAbortCaseSingleParserRuleCall_0_0 = (RuleCall)cCasesAssignment_0.eContents().get(0);
		private final Assignment cCasesAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cCasesAbortCaseSingleParserRuleCall_1_0 = (RuleCall)cCasesAssignment_1.eContents().get(0);
		private final Assignment cEndAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cEndAwaitEndParserRuleCall_2_0 = (RuleCall)cEndAssignment_2.eContents().get(0);
		
		//AwaitCase:
		//	cases+=AbortCaseSingle cases+=AbortCaseSingle* end=AwaitEnd;
		@Override public ParserRule getRule() { return rule; }

		//cases+=AbortCaseSingle cases+=AbortCaseSingle* end=AwaitEnd
		public Group getGroup() { return cGroup; }

		//cases+=AbortCaseSingle
		public Assignment getCasesAssignment_0() { return cCasesAssignment_0; }

		//AbortCaseSingle
		public RuleCall getCasesAbortCaseSingleParserRuleCall_0_0() { return cCasesAbortCaseSingleParserRuleCall_0_0; }

		//cases+=AbortCaseSingle*
		public Assignment getCasesAssignment_1() { return cCasesAssignment_1; }

		//AbortCaseSingle
		public RuleCall getCasesAbortCaseSingleParserRuleCall_1_0() { return cCasesAbortCaseSingleParserRuleCall_1_0; }

		//end=AwaitEnd
		public Assignment getEndAssignment_2() { return cEndAssignment_2; }

		//AwaitEnd
		public RuleCall getEndAwaitEndParserRuleCall_2_0() { return cEndAwaitEndParserRuleCall_2_0; }
	}

	public class AwaitEndElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.AwaitEnd");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cEndKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cAwaitKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//AwaitEnd:
		//	"end" "await"?;
		@Override public ParserRule getRule() { return rule; }

		//"end" "await"?
		public Group getGroup() { return cGroup; }

		//"end"
		public Keyword getEndKeyword_0() { return cEndKeyword_0; }

		//"await"?
		public Keyword getAwaitKeyword_1() { return cAwaitKeyword_1; }
	}

	public class ProcCallElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.ProcCall");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cCallKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cProcAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cProcProcedureCrossReference_1_0 = (CrossReference)cProcAssignment_1.eContents().get(0);
		private final RuleCall cProcProcedureIDTerminalRuleCall_1_0_1 = (RuleCall)cProcProcedureCrossReference_1_0.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Assignment cVarListAssignment_3_0 = (Assignment)cGroup_3.eContents().get(0);
		private final CrossReference cVarListIVariableCrossReference_3_0_0 = (CrossReference)cVarListAssignment_3_0.eContents().get(0);
		private final RuleCall cVarListIVariableIDTerminalRuleCall_3_0_0_1 = (RuleCall)cVarListIVariableCrossReference_3_0_0.eContents().get(1);
		private final Group cGroup_3_1 = (Group)cGroup_3.eContents().get(1);
		private final Keyword cCommaKeyword_3_1_0 = (Keyword)cGroup_3_1.eContents().get(0);
		private final Assignment cVarListAssignment_3_1_1 = (Assignment)cGroup_3_1.eContents().get(1);
		private final CrossReference cVarListIVariableCrossReference_3_1_1_0 = (CrossReference)cVarListAssignment_3_1_1.eContents().get(0);
		private final RuleCall cVarListIVariableIDTerminalRuleCall_3_1_1_0_1 = (RuleCall)cVarListIVariableCrossReference_3_1_1_0.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Keyword cLeftParenthesisKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Group cGroup_6 = (Group)cGroup.eContents().get(6);
		private final Assignment cKexpressionsAssignment_6_0 = (Assignment)cGroup_6.eContents().get(0);
		private final RuleCall cKexpressionsExpressionParserRuleCall_6_0_0 = (RuleCall)cKexpressionsAssignment_6_0.eContents().get(0);
		private final Group cGroup_6_1 = (Group)cGroup_6.eContents().get(1);
		private final Keyword cCommaKeyword_6_1_0 = (Keyword)cGroup_6_1.eContents().get(0);
		private final Assignment cKexpressionsAssignment_6_1_1 = (Assignment)cGroup_6_1.eContents().get(1);
		private final RuleCall cKexpressionsExpressionParserRuleCall_6_1_1_0 = (RuleCall)cKexpressionsAssignment_6_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_7 = (Keyword)cGroup.eContents().get(7);
		
		//// -!
		//// --> B.4.4 call: Procedure Call
		//// -------------------------------------
		//ProcCall:
		//	"call" proc=[Procedure] "(" (varList+=[kexpressions::IVariable] ("," varList+=[kexpressions::IVariable])*)?
		//	")"
		//	"(" (kexpressions+=Expression ("," kexpressions+=Expression)*)? ")";
		@Override public ParserRule getRule() { return rule; }

		//"call" proc=[Procedure] "(" (varList+=[kexpressions::IVariable] ("," varList+=[kexpressions::IVariable])*)? ")" "("
		//(kexpressions+=Expression ("," kexpressions+=Expression)*)? ")"
		public Group getGroup() { return cGroup; }

		//"call"
		public Keyword getCallKeyword_0() { return cCallKeyword_0; }

		//proc=[Procedure]
		public Assignment getProcAssignment_1() { return cProcAssignment_1; }

		//[Procedure]
		public CrossReference getProcProcedureCrossReference_1_0() { return cProcProcedureCrossReference_1_0; }

		//ID
		public RuleCall getProcProcedureIDTerminalRuleCall_1_0_1() { return cProcProcedureIDTerminalRuleCall_1_0_1; }

		//"("
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }

		//(varList+=[kexpressions::IVariable] ("," varList+=[kexpressions::IVariable])*)?
		public Group getGroup_3() { return cGroup_3; }

		//varList+=[kexpressions::IVariable]
		public Assignment getVarListAssignment_3_0() { return cVarListAssignment_3_0; }

		//[kexpressions::IVariable]
		public CrossReference getVarListIVariableCrossReference_3_0_0() { return cVarListIVariableCrossReference_3_0_0; }

		//ID
		public RuleCall getVarListIVariableIDTerminalRuleCall_3_0_0_1() { return cVarListIVariableIDTerminalRuleCall_3_0_0_1; }

		//("," varList+=[kexpressions::IVariable])*
		public Group getGroup_3_1() { return cGroup_3_1; }

		//","
		public Keyword getCommaKeyword_3_1_0() { return cCommaKeyword_3_1_0; }

		//varList+=[kexpressions::IVariable]
		public Assignment getVarListAssignment_3_1_1() { return cVarListAssignment_3_1_1; }

		//[kexpressions::IVariable]
		public CrossReference getVarListIVariableCrossReference_3_1_1_0() { return cVarListIVariableCrossReference_3_1_1_0; }

		//ID
		public RuleCall getVarListIVariableIDTerminalRuleCall_3_1_1_0_1() { return cVarListIVariableIDTerminalRuleCall_3_1_1_0_1; }

		//")"
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }

		//"("
		public Keyword getLeftParenthesisKeyword_5() { return cLeftParenthesisKeyword_5; }

		//(kexpressions+=Expression ("," kexpressions+=Expression)*)?
		public Group getGroup_6() { return cGroup_6; }

		//kexpressions+=Expression
		public Assignment getKexpressionsAssignment_6_0() { return cKexpressionsAssignment_6_0; }

		//Expression
		public RuleCall getKexpressionsExpressionParserRuleCall_6_0_0() { return cKexpressionsExpressionParserRuleCall_6_0_0; }

		//("," kexpressions+=Expression)*
		public Group getGroup_6_1() { return cGroup_6_1; }

		//","
		public Keyword getCommaKeyword_6_1_0() { return cCommaKeyword_6_1_0; }

		//kexpressions+=Expression
		public Assignment getKexpressionsAssignment_6_1_1() { return cKexpressionsAssignment_6_1_1; }

		//Expression
		public RuleCall getKexpressionsExpressionParserRuleCall_6_1_1_0() { return cKexpressionsExpressionParserRuleCall_6_1_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_7() { return cRightParenthesisKeyword_7; }
	}

	public class DoElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.Do");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cDoKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cStatementAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cStatementStatementParserRuleCall_1_0 = (RuleCall)cStatementAssignment_1.eContents().get(0);
		private final Alternatives cAlternatives_2 = (Alternatives)cGroup.eContents().get(2);
		private final Assignment cEndAssignment_2_0 = (Assignment)cAlternatives_2.eContents().get(0);
		private final RuleCall cEndDoUptoParserRuleCall_2_0_0 = (RuleCall)cEndAssignment_2_0.eContents().get(0);
		private final Assignment cEndAssignment_2_1 = (Assignment)cAlternatives_2.eContents().get(1);
		private final RuleCall cEndDoWatchingParserRuleCall_2_1_0 = (RuleCall)cEndAssignment_2_1.eContents().get(0);
		
		//// --> B.4.5 do-upto: Conditional Iteration (deprecated)
		//// --> B.4.6 do-watching: Strong Preemption (deprecated)
		//// !-(doupto) -------------------------------------
		//Do:
		//	"do" statement=Statement (end=DoUpto | end=DoWatching);
		@Override public ParserRule getRule() { return rule; }

		//"do" statement=Statement (end=DoUpto | end=DoWatching)
		public Group getGroup() { return cGroup; }

		//"do"
		public Keyword getDoKeyword_0() { return cDoKeyword_0; }

		//statement=Statement
		public Assignment getStatementAssignment_1() { return cStatementAssignment_1; }

		//Statement
		public RuleCall getStatementStatementParserRuleCall_1_0() { return cStatementStatementParserRuleCall_1_0; }

		//(end=DoUpto | end=DoWatching)
		public Alternatives getAlternatives_2() { return cAlternatives_2; }

		//end=DoUpto
		public Assignment getEndAssignment_2_0() { return cEndAssignment_2_0; }

		//DoUpto
		public RuleCall getEndDoUptoParserRuleCall_2_0_0() { return cEndDoUptoParserRuleCall_2_0_0; }

		//end=DoWatching
		public Assignment getEndAssignment_2_1() { return cEndAssignment_2_1; }

		//DoWatching
		public RuleCall getEndDoWatchingParserRuleCall_2_1_0() { return cEndDoWatchingParserRuleCall_2_1_0; }
	}

	public class DoUptoElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.DoUpto");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cUptoKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cExprAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cExprDelayExprParserRuleCall_1_0 = (RuleCall)cExprAssignment_1.eContents().get(0);
		
		//DoUpto:
		//	"upto" expr=DelayExpr;
		@Override public ParserRule getRule() { return rule; }

		//"upto" expr=DelayExpr
		public Group getGroup() { return cGroup; }

		//"upto"
		public Keyword getUptoKeyword_0() { return cUptoKeyword_0; }

		//expr=DelayExpr
		public Assignment getExprAssignment_1() { return cExprAssignment_1; }

		//DelayExpr
		public RuleCall getExprDelayExprParserRuleCall_1_0() { return cExprDelayExprParserRuleCall_1_0; }
	}

	public class DoWatchingElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.DoWatching");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cWatchingKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cDelayAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cDelayDelayExprParserRuleCall_1_0 = (RuleCall)cDelayAssignment_1.eContents().get(0);
		private final Assignment cEndAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cEndDoWatchingEndParserRuleCall_2_0 = (RuleCall)cEndAssignment_2.eContents().get(0);
		
		//DoWatching:
		//	"watching" delay=DelayExpr end=DoWatchingEnd?;
		@Override public ParserRule getRule() { return rule; }

		//"watching" delay=DelayExpr end=DoWatchingEnd?
		public Group getGroup() { return cGroup; }

		//"watching"
		public Keyword getWatchingKeyword_0() { return cWatchingKeyword_0; }

		//delay=DelayExpr
		public Assignment getDelayAssignment_1() { return cDelayAssignment_1; }

		//DelayExpr
		public RuleCall getDelayDelayExprParserRuleCall_1_0() { return cDelayDelayExprParserRuleCall_1_0; }

		//end=DoWatchingEnd?
		public Assignment getEndAssignment_2() { return cEndAssignment_2; }

		//DoWatchingEnd
		public RuleCall getEndDoWatchingEndParserRuleCall_2_0() { return cEndDoWatchingEndParserRuleCall_2_0; }
	}

	public class DoWatchingEndElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.DoWatchingEnd");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cTimeoutKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cStatementAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cStatementStatementParserRuleCall_1_0 = (RuleCall)cStatementAssignment_1.eContents().get(0);
		private final Keyword cEndKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cOptEndAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final Keyword cOptEndTimeoutKeyword_3_0 = (Keyword)cOptEndAssignment_3.eContents().get(0);
		
		//DoWatchingEnd:
		//	"timeout" statement=Statement "end" optEnd="timeout"?;
		@Override public ParserRule getRule() { return rule; }

		//"timeout" statement=Statement "end" optEnd="timeout"?
		public Group getGroup() { return cGroup; }

		//"timeout"
		public Keyword getTimeoutKeyword_0() { return cTimeoutKeyword_0; }

		//statement=Statement
		public Assignment getStatementAssignment_1() { return cStatementAssignment_1; }

		//Statement
		public RuleCall getStatementStatementParserRuleCall_1_0() { return cStatementStatementParserRuleCall_1_0; }

		//"end"
		public Keyword getEndKeyword_2() { return cEndKeyword_2; }

		//optEnd="timeout"?
		public Assignment getOptEndAssignment_3() { return cOptEndAssignment_3; }

		//"timeout"
		public Keyword getOptEndTimeoutKeyword_3_0() { return cOptEndTimeoutKeyword_3_0; }
	}

	public class EmitElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.Emit");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cEmitKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Assignment cSignalAssignment_1_0 = (Assignment)cAlternatives_1.eContents().get(0);
		private final CrossReference cSignalISignalCrossReference_1_0_0 = (CrossReference)cSignalAssignment_1_0.eContents().get(0);
		private final RuleCall cSignalISignalIDTerminalRuleCall_1_0_0_1 = (RuleCall)cSignalISignalCrossReference_1_0_0.eContents().get(1);
		private final Assignment cTickAssignment_1_1 = (Assignment)cAlternatives_1.eContents().get(1);
		private final RuleCall cTickTickParserRuleCall_1_1_0 = (RuleCall)cTickAssignment_1_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cLeftParenthesisKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cExprAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cExprExpressionParserRuleCall_2_1_0 = (RuleCall)cExprAssignment_2_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_2_2 = (Keyword)cGroup_2.eContents().get(2);
		
		//// -!
		//// --> B.4.7 emit: Signal Emission <--
		//// !-(emit)2 -------------------------------------
		//Emit:
		//	"emit" (signal=[kexpressions::ISignal] | tick=Tick) ("(" expr=Expression ")")?;
		@Override public ParserRule getRule() { return rule; }

		//"emit" (signal=[kexpressions::ISignal] | tick=Tick) ("(" expr=Expression ")")?
		public Group getGroup() { return cGroup; }

		//"emit"
		public Keyword getEmitKeyword_0() { return cEmitKeyword_0; }

		//(signal=[kexpressions::ISignal] | tick=Tick)
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//signal=[kexpressions::ISignal]
		public Assignment getSignalAssignment_1_0() { return cSignalAssignment_1_0; }

		//[kexpressions::ISignal]
		public CrossReference getSignalISignalCrossReference_1_0_0() { return cSignalISignalCrossReference_1_0_0; }

		//ID
		public RuleCall getSignalISignalIDTerminalRuleCall_1_0_0_1() { return cSignalISignalIDTerminalRuleCall_1_0_0_1; }

		//tick=Tick
		public Assignment getTickAssignment_1_1() { return cTickAssignment_1_1; }

		//Tick
		public RuleCall getTickTickParserRuleCall_1_1_0() { return cTickTickParserRuleCall_1_1_0; }

		//("(" expr=Expression ")")?
		public Group getGroup_2() { return cGroup_2; }

		//"("
		public Keyword getLeftParenthesisKeyword_2_0() { return cLeftParenthesisKeyword_2_0; }

		//expr=Expression
		public Assignment getExprAssignment_2_1() { return cExprAssignment_2_1; }

		//Expression
		public RuleCall getExprExpressionParserRuleCall_2_1_0() { return cExprExpressionParserRuleCall_2_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_2_2() { return cRightParenthesisKeyword_2_2; }
	}

	public class UnEmitElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.UnEmit");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cUnemitKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Assignment cSignalAssignment_1_0 = (Assignment)cAlternatives_1.eContents().get(0);
		private final CrossReference cSignalISignalCrossReference_1_0_0 = (CrossReference)cSignalAssignment_1_0.eContents().get(0);
		private final RuleCall cSignalISignalIDTerminalRuleCall_1_0_0_1 = (RuleCall)cSignalISignalCrossReference_1_0_0.eContents().get(1);
		private final Assignment cTickAssignment_1_1 = (Assignment)cAlternatives_1.eContents().get(1);
		private final RuleCall cTickTickParserRuleCall_1_1_0 = (RuleCall)cTickAssignment_1_1.eContents().get(0);
		
		//// -!
		//// --> SCEst only! unemit: Signal UnEmission <--
		//// !-(unemit)2 -------------------------------------
		//UnEmit:
		//	"unemit" (signal=[kexpressions::ISignal] | tick=Tick);
		@Override public ParserRule getRule() { return rule; }

		//"unemit" (signal=[kexpressions::ISignal] | tick=Tick)
		public Group getGroup() { return cGroup; }

		//"unemit"
		public Keyword getUnemitKeyword_0() { return cUnemitKeyword_0; }

		//(signal=[kexpressions::ISignal] | tick=Tick)
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//signal=[kexpressions::ISignal]
		public Assignment getSignalAssignment_1_0() { return cSignalAssignment_1_0; }

		//[kexpressions::ISignal]
		public CrossReference getSignalISignalCrossReference_1_0_0() { return cSignalISignalCrossReference_1_0_0; }

		//ID
		public RuleCall getSignalISignalIDTerminalRuleCall_1_0_0_1() { return cSignalISignalIDTerminalRuleCall_1_0_0_1; }

		//tick=Tick
		public Assignment getTickAssignment_1_1() { return cTickAssignment_1_1; }

		//Tick
		public RuleCall getTickTickParserRuleCall_1_1_0() { return cTickTickParserRuleCall_1_1_0; }
	}

	public class ResetElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.Reset");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cResetKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Assignment cSignalAssignment_1_0 = (Assignment)cAlternatives_1.eContents().get(0);
		private final CrossReference cSignalISignalCrossReference_1_0_0 = (CrossReference)cSignalAssignment_1_0.eContents().get(0);
		private final RuleCall cSignalISignalIDTerminalRuleCall_1_0_0_1 = (RuleCall)cSignalISignalCrossReference_1_0_0.eContents().get(1);
		private final Assignment cTickAssignment_1_1 = (Assignment)cAlternatives_1.eContents().get(1);
		private final RuleCall cTickTickParserRuleCall_1_1_0 = (RuleCall)cTickAssignment_1_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cLeftParenthesisKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cExprAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cExprExpressionParserRuleCall_2_1_0 = (RuleCall)cExprAssignment_2_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_2_2 = (Keyword)cGroup_2.eContents().get(2);
		
		//// -!
		//// --> SCEst only! reset: Signal value reset (absolute write) <--
		//// !-(emit)2 -------------------------------------
		//Reset:
		//	"reset" (signal=[kexpressions::ISignal] | tick=Tick) ("(" expr=Expression ")");
		@Override public ParserRule getRule() { return rule; }

		//"reset" (signal=[kexpressions::ISignal] | tick=Tick) ("(" expr=Expression ")")
		public Group getGroup() { return cGroup; }

		//"reset"
		public Keyword getResetKeyword_0() { return cResetKeyword_0; }

		//(signal=[kexpressions::ISignal] | tick=Tick)
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//signal=[kexpressions::ISignal]
		public Assignment getSignalAssignment_1_0() { return cSignalAssignment_1_0; }

		//[kexpressions::ISignal]
		public CrossReference getSignalISignalCrossReference_1_0_0() { return cSignalISignalCrossReference_1_0_0; }

		//ID
		public RuleCall getSignalISignalIDTerminalRuleCall_1_0_0_1() { return cSignalISignalIDTerminalRuleCall_1_0_0_1; }

		//tick=Tick
		public Assignment getTickAssignment_1_1() { return cTickAssignment_1_1; }

		//Tick
		public RuleCall getTickTickParserRuleCall_1_1_0() { return cTickTickParserRuleCall_1_1_0; }

		//("(" expr=Expression ")")
		public Group getGroup_2() { return cGroup_2; }

		//"("
		public Keyword getLeftParenthesisKeyword_2_0() { return cLeftParenthesisKeyword_2_0; }

		//expr=Expression
		public Assignment getExprAssignment_2_1() { return cExprAssignment_2_1; }

		//Expression
		public RuleCall getExprExpressionParserRuleCall_2_1_0() { return cExprExpressionParserRuleCall_2_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_2_2() { return cRightParenthesisKeyword_2_2; }
	}

	public class EveryDoElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.EveryDo");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cEveryKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cDelayAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cDelayDelayExprParserRuleCall_1_0 = (RuleCall)cDelayAssignment_1.eContents().get(0);
		private final Keyword cDoKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cStatementAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cStatementStatementParserRuleCall_3_0 = (RuleCall)cStatementAssignment_3.eContents().get(0);
		private final Keyword cEndKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cOptEndAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final Keyword cOptEndEveryKeyword_5_0 = (Keyword)cOptEndAssignment_5.eContents().get(0);
		
		//// -!
		//// --> B.4.8 every-do: Conditional Iteration
		//// !-(every)-------------------------------------
		//EveryDo:
		//	"every" delay=DelayExpr "do" statement=Statement "end" optEnd="every"?;
		@Override public ParserRule getRule() { return rule; }

		//"every" delay=DelayExpr "do" statement=Statement "end" optEnd="every"?
		public Group getGroup() { return cGroup; }

		//"every"
		public Keyword getEveryKeyword_0() { return cEveryKeyword_0; }

		//delay=DelayExpr
		public Assignment getDelayAssignment_1() { return cDelayAssignment_1; }

		//DelayExpr
		public RuleCall getDelayDelayExprParserRuleCall_1_0() { return cDelayDelayExprParserRuleCall_1_0; }

		//"do"
		public Keyword getDoKeyword_2() { return cDoKeyword_2; }

		//statement=Statement
		public Assignment getStatementAssignment_3() { return cStatementAssignment_3; }

		//Statement
		public RuleCall getStatementStatementParserRuleCall_3_0() { return cStatementStatementParserRuleCall_3_0; }

		//"end"
		public Keyword getEndKeyword_4() { return cEndKeyword_4; }

		//optEnd="every"?
		public Assignment getOptEndAssignment_5() { return cOptEndAssignment_5; }

		//"every"
		public Keyword getOptEndEveryKeyword_5_0() { return cOptEndEveryKeyword_5_0; }
	}

	public class ExitElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.Exit");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cExitKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cTrapAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cTrapTrapDeclCrossReference_1_0 = (CrossReference)cTrapAssignment_1.eContents().get(0);
		private final RuleCall cTrapTrapDeclIDTerminalRuleCall_1_0_1 = (RuleCall)cTrapTrapDeclCrossReference_1_0.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cLeftParenthesisKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cExpressionAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cExpressionExpressionParserRuleCall_2_1_0 = (RuleCall)cExpressionAssignment_2_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_2_2 = (Keyword)cGroup_2.eContents().get(2);
		
		//// -!
		//// --> B.4.10 exit: Trap Exit
		//// !-(exit) -------------------------------------
		//Exit:
		//	"exit" trap=[TrapDecl] ("(" expression=Expression ")")?;
		@Override public ParserRule getRule() { return rule; }

		//"exit" trap=[TrapDecl] ("(" expression=Expression ")")?
		public Group getGroup() { return cGroup; }

		//"exit"
		public Keyword getExitKeyword_0() { return cExitKeyword_0; }

		//trap=[TrapDecl]
		public Assignment getTrapAssignment_1() { return cTrapAssignment_1; }

		//[TrapDecl]
		public CrossReference getTrapTrapDeclCrossReference_1_0() { return cTrapTrapDeclCrossReference_1_0; }

		//ID
		public RuleCall getTrapTrapDeclIDTerminalRuleCall_1_0_1() { return cTrapTrapDeclIDTerminalRuleCall_1_0_1; }

		//("(" expression=Expression ")")?
		public Group getGroup_2() { return cGroup_2; }

		//"("
		public Keyword getLeftParenthesisKeyword_2_0() { return cLeftParenthesisKeyword_2_0; }

		//expression=Expression
		public Assignment getExpressionAssignment_2_1() { return cExpressionAssignment_2_1; }

		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_2_1_0() { return cExpressionExpressionParserRuleCall_2_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_2_2() { return cRightParenthesisKeyword_2_2; }
	}

	public class HaltElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.Halt");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cHaltAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cHaltKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//// -!
		//// --> B.4.11 halt: Wait Forever
		//// !-(halt) -------------------------------------
		//Halt:
		//	{Halt} "halt";
		@Override public ParserRule getRule() { return rule; }

		//{Halt} "halt"
		public Group getGroup() { return cGroup; }

		//{Halt}
		public Action getHaltAction_0() { return cHaltAction_0; }

		//"halt"
		public Keyword getHaltKeyword_1() { return cHaltKeyword_1; }
	}

	public class IfTestElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.IfTest");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cIfKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cExprAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cExprExpressionParserRuleCall_1_0 = (RuleCall)cExprAssignment_1.eContents().get(0);
		private final Assignment cThenPartAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cThenPartThenPartParserRuleCall_2_0 = (RuleCall)cThenPartAssignment_2.eContents().get(0);
		private final Assignment cElsifAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cElsifElsIfParserRuleCall_3_0 = (RuleCall)cElsifAssignment_3.eContents().get(0);
		private final Assignment cElsePartAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cElsePartElsePartParserRuleCall_4_0 = (RuleCall)cElsePartAssignment_4.eContents().get(0);
		private final Keyword cEndKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cOptEndAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final Keyword cOptEndIfKeyword_6_0 = (Keyword)cOptEndAssignment_6.eContents().get(0);
		
		//// -!
		//// --> B.4.12: if: Conditional for Data
		//// !-(if)-------------------------------------
		//IfTest:
		//	"if" expr=Expression thenPart=ThenPart? elsif+=ElsIf* elsePart=ElsePart? "end" optEnd="if"?;
		@Override public ParserRule getRule() { return rule; }

		//"if" expr=Expression thenPart=ThenPart? elsif+=ElsIf* elsePart=ElsePart? "end" optEnd="if"?
		public Group getGroup() { return cGroup; }

		//"if"
		public Keyword getIfKeyword_0() { return cIfKeyword_0; }

		//expr=Expression
		public Assignment getExprAssignment_1() { return cExprAssignment_1; }

		//Expression
		public RuleCall getExprExpressionParserRuleCall_1_0() { return cExprExpressionParserRuleCall_1_0; }

		//thenPart=ThenPart?
		public Assignment getThenPartAssignment_2() { return cThenPartAssignment_2; }

		//ThenPart
		public RuleCall getThenPartThenPartParserRuleCall_2_0() { return cThenPartThenPartParserRuleCall_2_0; }

		//elsif+=ElsIf*
		public Assignment getElsifAssignment_3() { return cElsifAssignment_3; }

		//ElsIf
		public RuleCall getElsifElsIfParserRuleCall_3_0() { return cElsifElsIfParserRuleCall_3_0; }

		//elsePart=ElsePart?
		public Assignment getElsePartAssignment_4() { return cElsePartAssignment_4; }

		//ElsePart
		public RuleCall getElsePartElsePartParserRuleCall_4_0() { return cElsePartElsePartParserRuleCall_4_0; }

		//"end"
		public Keyword getEndKeyword_5() { return cEndKeyword_5; }

		//optEnd="if"?
		public Assignment getOptEndAssignment_6() { return cOptEndAssignment_6; }

		//"if"
		public Keyword getOptEndIfKeyword_6_0() { return cOptEndIfKeyword_6_0; }
	}

	public class ElsIfElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.ElsIf");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cElsifKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cExprAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cExprExpressionParserRuleCall_1_0 = (RuleCall)cExprAssignment_1.eContents().get(0);
		private final Assignment cThenPartAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cThenPartThenPartParserRuleCall_2_0 = (RuleCall)cThenPartAssignment_2.eContents().get(0);
		
		//ElsIf:
		//	"elsif" expr=Expression thenPart=ThenPart?;
		@Override public ParserRule getRule() { return rule; }

		//"elsif" expr=Expression thenPart=ThenPart?
		public Group getGroup() { return cGroup; }

		//"elsif"
		public Keyword getElsifKeyword_0() { return cElsifKeyword_0; }

		//expr=Expression
		public Assignment getExprAssignment_1() { return cExprAssignment_1; }

		//Expression
		public RuleCall getExprExpressionParserRuleCall_1_0() { return cExprExpressionParserRuleCall_1_0; }

		//thenPart=ThenPart?
		public Assignment getThenPartAssignment_2() { return cThenPartAssignment_2; }

		//ThenPart
		public RuleCall getThenPartThenPartParserRuleCall_2_0() { return cThenPartThenPartParserRuleCall_2_0; }
	}

	public class ThenPartElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.ThenPart");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cThenKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cStatementAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cStatementStatementParserRuleCall_1_0 = (RuleCall)cStatementAssignment_1.eContents().get(0);
		
		//ThenPart:
		//	"then" statement=Statement;
		@Override public ParserRule getRule() { return rule; }

		//"then" statement=Statement
		public Group getGroup() { return cGroup; }

		//"then"
		public Keyword getThenKeyword_0() { return cThenKeyword_0; }

		//statement=Statement
		public Assignment getStatementAssignment_1() { return cStatementAssignment_1; }

		//Statement
		public RuleCall getStatementStatementParserRuleCall_1_0() { return cStatementStatementParserRuleCall_1_0; }
	}

	public class ElsePartElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.ElsePart");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cElseKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cStatementAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cStatementStatementParserRuleCall_1_0 = (RuleCall)cStatementAssignment_1.eContents().get(0);
		
		//ElsePart:
		//	"else" statement=Statement;
		@Override public ParserRule getRule() { return rule; }

		//"else" statement=Statement
		public Group getGroup() { return cGroup; }

		//"else"
		public Keyword getElseKeyword_0() { return cElseKeyword_0; }

		//statement=Statement
		public Assignment getStatementAssignment_1() { return cStatementAssignment_1; }

		//Statement
		public RuleCall getStatementStatementParserRuleCall_1_0() { return cStatementStatementParserRuleCall_1_0; }
	}

	public class LoopElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.Loop");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLoopKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cBodyAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cBodyLoopBodyParserRuleCall_1_0 = (RuleCall)cBodyAssignment_1.eContents().get(0);
		private final Alternatives cAlternatives_2 = (Alternatives)cGroup.eContents().get(2);
		private final Assignment cEnd1Assignment_2_0 = (Assignment)cAlternatives_2.eContents().get(0);
		private final RuleCall cEnd1EndLoopParserRuleCall_2_0_0 = (RuleCall)cEnd1Assignment_2_0.eContents().get(0);
		private final Assignment cEndAssignment_2_1 = (Assignment)cAlternatives_2.eContents().get(1);
		private final RuleCall cEndLoopEachParserRuleCall_2_1_0 = (RuleCall)cEndAssignment_2_1.eContents().get(0);
		
		//// -!
		//// --> B.4.13 loop: Infinite Loop
		//// --> B.4.14 loop-each: Condition Iteration
		//// !-(loop)-------------------------------------
		//Loop:
		//	"loop" body=LoopBody (end1=EndLoop | end=LoopEach);
		@Override public ParserRule getRule() { return rule; }

		//"loop" body=LoopBody (end1=EndLoop | end=LoopEach)
		public Group getGroup() { return cGroup; }

		//"loop"
		public Keyword getLoopKeyword_0() { return cLoopKeyword_0; }

		//body=LoopBody
		public Assignment getBodyAssignment_1() { return cBodyAssignment_1; }

		//LoopBody
		public RuleCall getBodyLoopBodyParserRuleCall_1_0() { return cBodyLoopBodyParserRuleCall_1_0; }

		//(end1=EndLoop | end=LoopEach)
		public Alternatives getAlternatives_2() { return cAlternatives_2; }

		//end1=EndLoop
		public Assignment getEnd1Assignment_2_0() { return cEnd1Assignment_2_0; }

		//EndLoop
		public RuleCall getEnd1EndLoopParserRuleCall_2_0_0() { return cEnd1EndLoopParserRuleCall_2_0_0; }

		//end=LoopEach
		public Assignment getEndAssignment_2_1() { return cEndAssignment_2_1; }

		//LoopEach
		public RuleCall getEndLoopEachParserRuleCall_2_1_0() { return cEndLoopEachParserRuleCall_2_1_0; }
	}

	public class EndLoopElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.EndLoop");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cEndLoopAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cEndKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cEndOptAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Keyword cEndOptLoopKeyword_2_0 = (Keyword)cEndOptAssignment_2.eContents().get(0);
		
		//EndLoop:
		//	{EndLoop} "end" endOpt="loop"?;
		@Override public ParserRule getRule() { return rule; }

		//{EndLoop} "end" endOpt="loop"?
		public Group getGroup() { return cGroup; }

		//{EndLoop}
		public Action getEndLoopAction_0() { return cEndLoopAction_0; }

		//"end"
		public Keyword getEndKeyword_1() { return cEndKeyword_1; }

		//endOpt="loop"?
		public Assignment getEndOptAssignment_2() { return cEndOptAssignment_2; }

		//"loop"
		public Keyword getEndOptLoopKeyword_2_0() { return cEndOptLoopKeyword_2_0; }
	}

	public class LoopEachElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.LoopEach");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cEachKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cLoopDelayParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		//LoopEach:
		//	"each" LoopDelay;
		@Override public ParserRule getRule() { return rule; }

		//"each" LoopDelay
		public Group getGroup() { return cGroup; }

		//"each"
		public Keyword getEachKeyword_0() { return cEachKeyword_0; }

		//LoopDelay
		public RuleCall getLoopDelayParserRuleCall_1() { return cLoopDelayParserRuleCall_1; }
	}

	public class LoopDelayElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.LoopDelay");
		private final Assignment cDelayAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cDelayDelayExprParserRuleCall_0 = (RuleCall)cDelayAssignment.eContents().get(0);
		
		//LoopDelay:
		//	delay=DelayExpr;
		@Override public ParserRule getRule() { return rule; }

		//delay=DelayExpr
		public Assignment getDelayAssignment() { return cDelayAssignment; }

		//DelayExpr
		public RuleCall getDelayDelayExprParserRuleCall_0() { return cDelayDelayExprParserRuleCall_0; }
	}

	public class LoopBodyElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.LoopBody");
		private final Assignment cStatementAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cStatementStatementParserRuleCall_0 = (RuleCall)cStatementAssignment.eContents().get(0);
		
		//LoopBody:
		//	statement=Statement;
		@Override public ParserRule getRule() { return rule; }

		//statement=Statement
		public Assignment getStatementAssignment() { return cStatementAssignment; }

		//Statement
		public RuleCall getStatementStatementParserRuleCall_0() { return cStatementStatementParserRuleCall_0; }
	}

	public class NothingElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.Nothing");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cNothingKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Action cNothingAction_1 = (Action)cGroup.eContents().get(1);
		
		//// -!
		//// --> B.4.15 nothing: No Operation
		//// !-(nothing) -------------------------------------
		//Nothing:
		//	"nothing" {Nothing};
		@Override public ParserRule getRule() { return rule; }

		//"nothing" {Nothing}
		public Group getGroup() { return cGroup; }

		//"nothing"
		public Keyword getNothingKeyword_0() { return cNothingKeyword_0; }

		//{Nothing}
		public Action getNothingAction_1() { return cNothingAction_1; }
	}

	public class PauseElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.Pause");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cPauseKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Action cPauseAction_1 = (Action)cGroup.eContents().get(1);
		
		//// -!
		//// --> B.4.16 pause: Unit Delay
		//// !-(pause) -------------------------------------
		//Pause:
		//	"pause" {Pause};
		@Override public ParserRule getRule() { return rule; }

		//"pause" {Pause}
		public Group getGroup() { return cGroup; }

		//"pause"
		public Keyword getPauseKeyword_0() { return cPauseKeyword_0; }

		//{Pause}
		public Action getPauseAction_1() { return cPauseAction_1; }
	}

	public class PresentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.Present");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cPresentKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cBodyAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cBodyPresentBodyParserRuleCall_1_0 = (RuleCall)cBodyAssignment_1.eContents().get(0);
		private final Assignment cElsePartAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cElsePartElsePartParserRuleCall_2_0 = (RuleCall)cElsePartAssignment_2.eContents().get(0);
		private final Keyword cEndKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cOptEndAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final Keyword cOptEndPresentKeyword_4_0 = (Keyword)cOptEndAssignment_4.eContents().get(0);
		
		//// -!
		//// --> B.4.17 present: Conditional for Signals
		//// !-(present) -------------------------------------
		//Present:
		//	"present" body=PresentBody elsePart=ElsePart? "end" optEnd="present"?;
		@Override public ParserRule getRule() { return rule; }

		//"present" body=PresentBody elsePart=ElsePart? "end" optEnd="present"?
		public Group getGroup() { return cGroup; }

		//"present"
		public Keyword getPresentKeyword_0() { return cPresentKeyword_0; }

		//body=PresentBody
		public Assignment getBodyAssignment_1() { return cBodyAssignment_1; }

		//PresentBody
		public RuleCall getBodyPresentBodyParserRuleCall_1_0() { return cBodyPresentBodyParserRuleCall_1_0; }

		//elsePart=ElsePart?
		public Assignment getElsePartAssignment_2() { return cElsePartAssignment_2; }

		//ElsePart
		public RuleCall getElsePartElsePartParserRuleCall_2_0() { return cElsePartElsePartParserRuleCall_2_0; }

		//"end"
		public Keyword getEndKeyword_3() { return cEndKeyword_3; }

		//optEnd="present"?
		public Assignment getOptEndAssignment_4() { return cOptEndAssignment_4; }

		//"present"
		public Keyword getOptEndPresentKeyword_4_0() { return cOptEndPresentKeyword_4_0; }
	}

	public class PresentBodyElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.PresentBody");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cPresentEventBodyParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cPresentCaseListParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//PresentBody:
		//	PresentEventBody | PresentCaseList;
		@Override public ParserRule getRule() { return rule; }

		//PresentEventBody | PresentCaseList
		public Alternatives getAlternatives() { return cAlternatives; }

		//PresentEventBody
		public RuleCall getPresentEventBodyParserRuleCall_0() { return cPresentEventBodyParserRuleCall_0; }

		//PresentCaseList
		public RuleCall getPresentCaseListParserRuleCall_1() { return cPresentCaseListParserRuleCall_1; }
	}

	public class PresentEventBodyElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.PresentEventBody");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cEventAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cEventPresentEventParserRuleCall_0_0 = (RuleCall)cEventAssignment_0.eContents().get(0);
		private final Assignment cThenPartAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cThenPartThenPartParserRuleCall_1_0 = (RuleCall)cThenPartAssignment_1.eContents().get(0);
		
		//PresentEventBody:
		//	event=PresentEvent thenPart=ThenPart?;
		@Override public ParserRule getRule() { return rule; }

		//event=PresentEvent thenPart=ThenPart?
		public Group getGroup() { return cGroup; }

		//event=PresentEvent
		public Assignment getEventAssignment_0() { return cEventAssignment_0; }

		//PresentEvent
		public RuleCall getEventPresentEventParserRuleCall_0_0() { return cEventPresentEventParserRuleCall_0_0; }

		//thenPart=ThenPart?
		public Assignment getThenPartAssignment_1() { return cThenPartAssignment_1; }

		//ThenPart
		public RuleCall getThenPartThenPartParserRuleCall_1_0() { return cThenPartThenPartParserRuleCall_1_0; }
	}

	public class PresentCaseListElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.PresentCaseList");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cCasesAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cCasesPresentCaseParserRuleCall_0_0 = (RuleCall)cCasesAssignment_0.eContents().get(0);
		private final Assignment cCasesAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cCasesPresentCaseParserRuleCall_1_0 = (RuleCall)cCasesAssignment_1.eContents().get(0);
		
		//PresentCaseList:
		//	cases+=PresentCase cases+=PresentCase*;
		@Override public ParserRule getRule() { return rule; }

		//cases+=PresentCase cases+=PresentCase*
		public Group getGroup() { return cGroup; }

		//cases+=PresentCase
		public Assignment getCasesAssignment_0() { return cCasesAssignment_0; }

		//PresentCase
		public RuleCall getCasesPresentCaseParserRuleCall_0_0() { return cCasesPresentCaseParserRuleCall_0_0; }

		//cases+=PresentCase*
		public Assignment getCasesAssignment_1() { return cCasesAssignment_1; }

		//PresentCase
		public RuleCall getCasesPresentCaseParserRuleCall_1_0() { return cCasesPresentCaseParserRuleCall_1_0; }
	}

	public class PresentCaseElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.PresentCase");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cCaseKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cEventAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cEventPresentEventParserRuleCall_1_0 = (RuleCall)cEventAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cDoKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cStatementAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cStatementStatementParserRuleCall_2_1_0 = (RuleCall)cStatementAssignment_2_1.eContents().get(0);
		
		//PresentCase:
		//	"case" event=PresentEvent ("do" statement=Statement)?;
		@Override public ParserRule getRule() { return rule; }

		//"case" event=PresentEvent ("do" statement=Statement)?
		public Group getGroup() { return cGroup; }

		//"case"
		public Keyword getCaseKeyword_0() { return cCaseKeyword_0; }

		//event=PresentEvent
		public Assignment getEventAssignment_1() { return cEventAssignment_1; }

		//PresentEvent
		public RuleCall getEventPresentEventParserRuleCall_1_0() { return cEventPresentEventParserRuleCall_1_0; }

		//("do" statement=Statement)?
		public Group getGroup_2() { return cGroup_2; }

		//"do"
		public Keyword getDoKeyword_2_0() { return cDoKeyword_2_0; }

		//statement=Statement
		public Assignment getStatementAssignment_2_1() { return cStatementAssignment_2_1; }

		//Statement
		public RuleCall getStatementStatementParserRuleCall_2_1_0() { return cStatementStatementParserRuleCall_2_1_0; }
	}

	public class PresentEventElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.PresentEvent");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cExpressionAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cExpressionSignalExpressionParserRuleCall_0_0 = (RuleCall)cExpressionAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Assignment cFBAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final Keyword cFBLeftSquareBracketKeyword_1_0_0 = (Keyword)cFBAssignment_1_0.eContents().get(0);
		private final Assignment cExpressionAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cExpressionSignalExpressionParserRuleCall_1_1_0 = (RuleCall)cExpressionAssignment_1_1.eContents().get(0);
		private final Assignment cEBAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final Keyword cEBRightSquareBracketKeyword_1_2_0 = (Keyword)cEBAssignment_1_2.eContents().get(0);
		private final Assignment cTickAssignment_2 = (Assignment)cAlternatives.eContents().get(2);
		private final RuleCall cTickTickParserRuleCall_2_0 = (RuleCall)cTickAssignment_2.eContents().get(0);
		
		//PresentEvent:
		//	expression=SignalExpression | fB="[" expression=SignalExpression eB="]" | tick=Tick;
		@Override public ParserRule getRule() { return rule; }

		//expression=SignalExpression | fB="[" expression=SignalExpression eB="]" | tick=Tick
		public Alternatives getAlternatives() { return cAlternatives; }

		//expression=SignalExpression
		public Assignment getExpressionAssignment_0() { return cExpressionAssignment_0; }

		//SignalExpression
		public RuleCall getExpressionSignalExpressionParserRuleCall_0_0() { return cExpressionSignalExpressionParserRuleCall_0_0; }

		//fB="[" expression=SignalExpression eB="]"
		public Group getGroup_1() { return cGroup_1; }

		//fB="["
		public Assignment getFBAssignment_1_0() { return cFBAssignment_1_0; }

		//"["
		public Keyword getFBLeftSquareBracketKeyword_1_0_0() { return cFBLeftSquareBracketKeyword_1_0_0; }

		//expression=SignalExpression
		public Assignment getExpressionAssignment_1_1() { return cExpressionAssignment_1_1; }

		//SignalExpression
		public RuleCall getExpressionSignalExpressionParserRuleCall_1_1_0() { return cExpressionSignalExpressionParserRuleCall_1_1_0; }

		//eB="]"
		public Assignment getEBAssignment_1_2() { return cEBAssignment_1_2; }

		//"]"
		public Keyword getEBRightSquareBracketKeyword_1_2_0() { return cEBRightSquareBracketKeyword_1_2_0; }

		//tick=Tick
		public Assignment getTickAssignment_2() { return cTickAssignment_2; }

		//Tick
		public RuleCall getTickTickParserRuleCall_2_0() { return cTickTickParserRuleCall_2_0; }
	}

	public class RepeatElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.Repeat");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cPositiveAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cPositivePositiveKeyword_0_0 = (Keyword)cPositiveAssignment_0.eContents().get(0);
		private final Keyword cRepeatKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cExpressionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cExpressionExpressionParserRuleCall_2_0 = (RuleCall)cExpressionAssignment_2.eContents().get(0);
		private final Keyword cTimesKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cStatementAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cStatementStatementParserRuleCall_4_0 = (RuleCall)cStatementAssignment_4.eContents().get(0);
		private final Keyword cEndKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cOptEndAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final Keyword cOptEndRepeatKeyword_6_0 = (Keyword)cOptEndAssignment_6.eContents().get(0);
		
		//// -!
		//// --> B.4.18 repeat: Iterate a Fixed Number of Times
		//// -------------------------------------
		//Repeat:
		//	positive?="positive"? "repeat" expression=Expression "times" statement=Statement "end" optEnd="repeat"?;
		@Override public ParserRule getRule() { return rule; }

		//positive?="positive"? "repeat" expression=Expression "times" statement=Statement "end" optEnd="repeat"?
		public Group getGroup() { return cGroup; }

		//positive?="positive"?
		public Assignment getPositiveAssignment_0() { return cPositiveAssignment_0; }

		//"positive"
		public Keyword getPositivePositiveKeyword_0_0() { return cPositivePositiveKeyword_0_0; }

		//"repeat"
		public Keyword getRepeatKeyword_1() { return cRepeatKeyword_1; }

		//expression=Expression
		public Assignment getExpressionAssignment_2() { return cExpressionAssignment_2; }

		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_2_0() { return cExpressionExpressionParserRuleCall_2_0; }

		//"times"
		public Keyword getTimesKeyword_3() { return cTimesKeyword_3; }

		//statement=Statement
		public Assignment getStatementAssignment_4() { return cStatementAssignment_4; }

		//Statement
		public RuleCall getStatementStatementParserRuleCall_4_0() { return cStatementStatementParserRuleCall_4_0; }

		//"end"
		public Keyword getEndKeyword_5() { return cEndKeyword_5; }

		//optEnd="repeat"?
		public Assignment getOptEndAssignment_6() { return cOptEndAssignment_6; }

		//"repeat"
		public Keyword getOptEndRepeatKeyword_6_0() { return cOptEndRepeatKeyword_6_0; }
	}

	public class RunElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.Run");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cRunKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final Assignment cModuleAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cModuleModuleRenamingParserRuleCall_0_1_0 = (RuleCall)cModuleAssignment_0_1.eContents().get(0);
		private final Group cGroup_0_2 = (Group)cGroup_0.eContents().get(2);
		private final Keyword cLeftSquareBracketKeyword_0_2_0 = (Keyword)cGroup_0_2.eContents().get(0);
		private final Assignment cListAssignment_0_2_1 = (Assignment)cGroup_0_2.eContents().get(1);
		private final RuleCall cListRenamingListParserRuleCall_0_2_1_0 = (RuleCall)cListAssignment_0_2_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_0_2_2 = (Keyword)cGroup_0_2.eContents().get(2);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cCopymoduleKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cModuleAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cModuleModuleRenamingParserRuleCall_1_1_0 = (RuleCall)cModuleAssignment_1_1.eContents().get(0);
		private final Group cGroup_1_2 = (Group)cGroup_1.eContents().get(2);
		private final Keyword cLeftSquareBracketKeyword_1_2_0 = (Keyword)cGroup_1_2.eContents().get(0);
		private final Assignment cListAssignment_1_2_1 = (Assignment)cGroup_1_2.eContents().get(1);
		private final RuleCall cListRenamingListParserRuleCall_1_2_1_0 = (RuleCall)cListAssignment_1_2_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_1_2_2 = (Keyword)cGroup_1_2.eContents().get(2);
		
		//// --> B.4.19 run: Module Instantiation
		//// -------------------------------------
		//Run:
		//	"run" module=ModuleRenaming ("[" list=RenamingList "]")? | "copymodule" module=ModuleRenaming ("[" list=RenamingList
		//	"]")?;
		@Override public ParserRule getRule() { return rule; }

		//"run" module=ModuleRenaming ("[" list=RenamingList "]")? | "copymodule" module=ModuleRenaming ("[" list=RenamingList
		//"]")?
		public Alternatives getAlternatives() { return cAlternatives; }

		//"run" module=ModuleRenaming ("[" list=RenamingList "]")?
		public Group getGroup_0() { return cGroup_0; }

		//"run"
		public Keyword getRunKeyword_0_0() { return cRunKeyword_0_0; }

		//module=ModuleRenaming
		public Assignment getModuleAssignment_0_1() { return cModuleAssignment_0_1; }

		//ModuleRenaming
		public RuleCall getModuleModuleRenamingParserRuleCall_0_1_0() { return cModuleModuleRenamingParserRuleCall_0_1_0; }

		//("[" list=RenamingList "]")?
		public Group getGroup_0_2() { return cGroup_0_2; }

		//"["
		public Keyword getLeftSquareBracketKeyword_0_2_0() { return cLeftSquareBracketKeyword_0_2_0; }

		//list=RenamingList
		public Assignment getListAssignment_0_2_1() { return cListAssignment_0_2_1; }

		//RenamingList
		public RuleCall getListRenamingListParserRuleCall_0_2_1_0() { return cListRenamingListParserRuleCall_0_2_1_0; }

		//"]"
		public Keyword getRightSquareBracketKeyword_0_2_2() { return cRightSquareBracketKeyword_0_2_2; }

		//"copymodule" module=ModuleRenaming ("[" list=RenamingList "]")?
		public Group getGroup_1() { return cGroup_1; }

		//"copymodule"
		public Keyword getCopymoduleKeyword_1_0() { return cCopymoduleKeyword_1_0; }

		//module=ModuleRenaming
		public Assignment getModuleAssignment_1_1() { return cModuleAssignment_1_1; }

		//ModuleRenaming
		public RuleCall getModuleModuleRenamingParserRuleCall_1_1_0() { return cModuleModuleRenamingParserRuleCall_1_1_0; }

		//("[" list=RenamingList "]")?
		public Group getGroup_1_2() { return cGroup_1_2; }

		//"["
		public Keyword getLeftSquareBracketKeyword_1_2_0() { return cLeftSquareBracketKeyword_1_2_0; }

		//list=RenamingList
		public Assignment getListAssignment_1_2_1() { return cListAssignment_1_2_1; }

		//RenamingList
		public RuleCall getListRenamingListParserRuleCall_1_2_1_0() { return cListRenamingListParserRuleCall_1_2_1_0; }

		//"]"
		public Keyword getRightSquareBracketKeyword_1_2_2() { return cRightSquareBracketKeyword_1_2_2; }
	}

	public class ModuleRenamingElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.ModuleRenaming");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cModuleAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final CrossReference cModuleModuleCrossReference_0_0 = (CrossReference)cModuleAssignment_0.eContents().get(0);
		private final RuleCall cModuleModuleIDTerminalRuleCall_0_0_1 = (RuleCall)cModuleModuleCrossReference_0_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Assignment cNewNameAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cNewNameIDTerminalRuleCall_1_0_0 = (RuleCall)cNewNameAssignment_1_0.eContents().get(0);
		private final Keyword cSolidusKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cModuleAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final CrossReference cModuleModuleCrossReference_1_2_0 = (CrossReference)cModuleAssignment_1_2.eContents().get(0);
		private final RuleCall cModuleModuleIDTerminalRuleCall_1_2_0_1 = (RuleCall)cModuleModuleCrossReference_1_2_0.eContents().get(1);
		
		////deprecated
		//// Renamings
		//// -------------------------------------
		//ModuleRenaming:
		//	module=[Module] | newName=ID "/" module=[Module];
		@Override public ParserRule getRule() { return rule; }

		//module=[Module] | newName=ID "/" module=[Module]
		public Alternatives getAlternatives() { return cAlternatives; }

		//module=[Module]
		public Assignment getModuleAssignment_0() { return cModuleAssignment_0; }

		//[Module]
		public CrossReference getModuleModuleCrossReference_0_0() { return cModuleModuleCrossReference_0_0; }

		//ID
		public RuleCall getModuleModuleIDTerminalRuleCall_0_0_1() { return cModuleModuleIDTerminalRuleCall_0_0_1; }

		//newName=ID "/" module=[Module]
		public Group getGroup_1() { return cGroup_1; }

		//newName=ID
		public Assignment getNewNameAssignment_1_0() { return cNewNameAssignment_1_0; }

		//ID
		public RuleCall getNewNameIDTerminalRuleCall_1_0_0() { return cNewNameIDTerminalRuleCall_1_0_0; }

		//"/"
		public Keyword getSolidusKeyword_1_1() { return cSolidusKeyword_1_1; }

		//module=[Module]
		public Assignment getModuleAssignment_1_2() { return cModuleAssignment_1_2; }

		//[Module]
		public CrossReference getModuleModuleCrossReference_1_2_0() { return cModuleModuleCrossReference_1_2_0; }

		//ID
		public RuleCall getModuleModuleIDTerminalRuleCall_1_2_0_1() { return cModuleModuleIDTerminalRuleCall_1_2_0_1; }
	}

	public class RenamingListElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.RenamingList");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cListAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cListRenamingParserRuleCall_0_0 = (RuleCall)cListAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cSemicolonKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cListAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cListRenamingParserRuleCall_1_1_0 = (RuleCall)cListAssignment_1_1.eContents().get(0);
		
		//RenamingList:
		//	list+=Renaming (";" list+=Renaming)*;
		@Override public ParserRule getRule() { return rule; }

		//list+=Renaming (";" list+=Renaming)*
		public Group getGroup() { return cGroup; }

		//list+=Renaming
		public Assignment getListAssignment_0() { return cListAssignment_0; }

		//Renaming
		public RuleCall getListRenamingParserRuleCall_0_0() { return cListRenamingParserRuleCall_0_0; }

		//(";" list+=Renaming)*
		public Group getGroup_1() { return cGroup_1; }

		//";"
		public Keyword getSemicolonKeyword_1_0() { return cSemicolonKeyword_1_0; }

		//list+=Renaming
		public Assignment getListAssignment_1_1() { return cListAssignment_1_1; }

		//Renaming
		public RuleCall getListRenamingParserRuleCall_1_1_0() { return cListRenamingParserRuleCall_1_1_0; }
	}

	public class RenamingElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.Renaming");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cTypeKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final Assignment cRenamingsAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cRenamingsTypeRenamingParserRuleCall_0_1_0 = (RuleCall)cRenamingsAssignment_0_1.eContents().get(0);
		private final Group cGroup_0_2 = (Group)cGroup_0.eContents().get(2);
		private final Keyword cCommaKeyword_0_2_0 = (Keyword)cGroup_0_2.eContents().get(0);
		private final Assignment cRenamingsAssignment_0_2_1 = (Assignment)cGroup_0_2.eContents().get(1);
		private final RuleCall cRenamingsTypeRenamingParserRuleCall_0_2_1_0 = (RuleCall)cRenamingsAssignment_0_2_1.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cConstantKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cRenamingsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRenamingsConstantRenamingParserRuleCall_1_1_0 = (RuleCall)cRenamingsAssignment_1_1.eContents().get(0);
		private final Group cGroup_1_2 = (Group)cGroup_1.eContents().get(2);
		private final Keyword cCommaKeyword_1_2_0 = (Keyword)cGroup_1_2.eContents().get(0);
		private final Assignment cRenamingsAssignment_1_2_1 = (Assignment)cGroup_1_2.eContents().get(1);
		private final RuleCall cRenamingsConstantRenamingParserRuleCall_1_2_1_0 = (RuleCall)cRenamingsAssignment_1_2_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Keyword cFunctionKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cRenamingsAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cRenamingsFunctionRenamingParserRuleCall_2_1_0 = (RuleCall)cRenamingsAssignment_2_1.eContents().get(0);
		private final Group cGroup_2_2 = (Group)cGroup_2.eContents().get(2);
		private final Keyword cCommaKeyword_2_2_0 = (Keyword)cGroup_2_2.eContents().get(0);
		private final Assignment cRenamingsAssignment_2_2_1 = (Assignment)cGroup_2_2.eContents().get(1);
		private final RuleCall cRenamingsFunctionRenamingParserRuleCall_2_2_1_0 = (RuleCall)cRenamingsAssignment_2_2_1.eContents().get(0);
		private final Group cGroup_3 = (Group)cAlternatives.eContents().get(3);
		private final Keyword cProcedureKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cRenamingsAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cRenamingsProcedureRenamingParserRuleCall_3_1_0 = (RuleCall)cRenamingsAssignment_3_1.eContents().get(0);
		private final Group cGroup_3_2 = (Group)cGroup_3.eContents().get(2);
		private final Keyword cCommaKeyword_3_2_0 = (Keyword)cGroup_3_2.eContents().get(0);
		private final Assignment cRenamingsAssignment_3_2_1 = (Assignment)cGroup_3_2.eContents().get(1);
		private final RuleCall cRenamingsProcedureRenamingParserRuleCall_3_2_1_0 = (RuleCall)cRenamingsAssignment_3_2_1.eContents().get(0);
		private final Group cGroup_4 = (Group)cAlternatives.eContents().get(4);
		private final Keyword cTaskKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final Assignment cRenamingsAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cRenamingsTaskRenamingParserRuleCall_4_1_0 = (RuleCall)cRenamingsAssignment_4_1.eContents().get(0);
		private final Group cGroup_4_2 = (Group)cGroup_4.eContents().get(2);
		private final Keyword cCommaKeyword_4_2_0 = (Keyword)cGroup_4_2.eContents().get(0);
		private final Assignment cRenamingsAssignment_4_2_1 = (Assignment)cGroup_4_2.eContents().get(1);
		private final RuleCall cRenamingsTaskRenamingParserRuleCall_4_2_1_0 = (RuleCall)cRenamingsAssignment_4_2_1.eContents().get(0);
		private final Group cGroup_5 = (Group)cAlternatives.eContents().get(5);
		private final Keyword cSignalKeyword_5_0 = (Keyword)cGroup_5.eContents().get(0);
		private final Assignment cRenamingsAssignment_5_1 = (Assignment)cGroup_5.eContents().get(1);
		private final RuleCall cRenamingsSignalRenamingParserRuleCall_5_1_0 = (RuleCall)cRenamingsAssignment_5_1.eContents().get(0);
		private final Group cGroup_5_2 = (Group)cGroup_5.eContents().get(2);
		private final Keyword cCommaKeyword_5_2_0 = (Keyword)cGroup_5_2.eContents().get(0);
		private final Assignment cRenamingsAssignment_5_2_1 = (Assignment)cGroup_5_2.eContents().get(1);
		private final RuleCall cRenamingsSignalRenamingParserRuleCall_5_2_1_0 = (RuleCall)cRenamingsAssignment_5_2_1.eContents().get(0);
		
		//Renaming:
		//	"type" renamings+=TypeRenaming ("," renamings+=TypeRenaming)*
		//	| "constant" renamings+=ConstantRenaming ("," renamings+=ConstantRenaming)*
		//	| "function" renamings+=FunctionRenaming ("," renamings+=FunctionRenaming)*
		//	| "procedure" renamings+=ProcedureRenaming ("," renamings+=ProcedureRenaming)*
		//	| "task" renamings+=TaskRenaming ("," renamings+=TaskRenaming)*
		//	| "signal" renamings+=SignalRenaming ("," renamings+=SignalRenaming)*;
		@Override public ParserRule getRule() { return rule; }

		//"type" renamings+=TypeRenaming ("," renamings+=TypeRenaming)* | "constant" renamings+=ConstantRenaming (","
		//renamings+=ConstantRenaming)* | "function" renamings+=FunctionRenaming ("," renamings+=FunctionRenaming)* |
		//"procedure" renamings+=ProcedureRenaming ("," renamings+=ProcedureRenaming)* | "task" renamings+=TaskRenaming (","
		//renamings+=TaskRenaming)* | "signal" renamings+=SignalRenaming ("," renamings+=SignalRenaming)*
		public Alternatives getAlternatives() { return cAlternatives; }

		//"type" renamings+=TypeRenaming ("," renamings+=TypeRenaming)*
		public Group getGroup_0() { return cGroup_0; }

		//"type"
		public Keyword getTypeKeyword_0_0() { return cTypeKeyword_0_0; }

		//renamings+=TypeRenaming
		public Assignment getRenamingsAssignment_0_1() { return cRenamingsAssignment_0_1; }

		//TypeRenaming
		public RuleCall getRenamingsTypeRenamingParserRuleCall_0_1_0() { return cRenamingsTypeRenamingParserRuleCall_0_1_0; }

		//("," renamings+=TypeRenaming)*
		public Group getGroup_0_2() { return cGroup_0_2; }

		//","
		public Keyword getCommaKeyword_0_2_0() { return cCommaKeyword_0_2_0; }

		//renamings+=TypeRenaming
		public Assignment getRenamingsAssignment_0_2_1() { return cRenamingsAssignment_0_2_1; }

		//TypeRenaming
		public RuleCall getRenamingsTypeRenamingParserRuleCall_0_2_1_0() { return cRenamingsTypeRenamingParserRuleCall_0_2_1_0; }

		//"constant" renamings+=ConstantRenaming ("," renamings+=ConstantRenaming)*
		public Group getGroup_1() { return cGroup_1; }

		//"constant"
		public Keyword getConstantKeyword_1_0() { return cConstantKeyword_1_0; }

		//renamings+=ConstantRenaming
		public Assignment getRenamingsAssignment_1_1() { return cRenamingsAssignment_1_1; }

		//ConstantRenaming
		public RuleCall getRenamingsConstantRenamingParserRuleCall_1_1_0() { return cRenamingsConstantRenamingParserRuleCall_1_1_0; }

		//("," renamings+=ConstantRenaming)*
		public Group getGroup_1_2() { return cGroup_1_2; }

		//","
		public Keyword getCommaKeyword_1_2_0() { return cCommaKeyword_1_2_0; }

		//renamings+=ConstantRenaming
		public Assignment getRenamingsAssignment_1_2_1() { return cRenamingsAssignment_1_2_1; }

		//ConstantRenaming
		public RuleCall getRenamingsConstantRenamingParserRuleCall_1_2_1_0() { return cRenamingsConstantRenamingParserRuleCall_1_2_1_0; }

		//"function" renamings+=FunctionRenaming ("," renamings+=FunctionRenaming)*
		public Group getGroup_2() { return cGroup_2; }

		//"function"
		public Keyword getFunctionKeyword_2_0() { return cFunctionKeyword_2_0; }

		//renamings+=FunctionRenaming
		public Assignment getRenamingsAssignment_2_1() { return cRenamingsAssignment_2_1; }

		//FunctionRenaming
		public RuleCall getRenamingsFunctionRenamingParserRuleCall_2_1_0() { return cRenamingsFunctionRenamingParserRuleCall_2_1_0; }

		//("," renamings+=FunctionRenaming)*
		public Group getGroup_2_2() { return cGroup_2_2; }

		//","
		public Keyword getCommaKeyword_2_2_0() { return cCommaKeyword_2_2_0; }

		//renamings+=FunctionRenaming
		public Assignment getRenamingsAssignment_2_2_1() { return cRenamingsAssignment_2_2_1; }

		//FunctionRenaming
		public RuleCall getRenamingsFunctionRenamingParserRuleCall_2_2_1_0() { return cRenamingsFunctionRenamingParserRuleCall_2_2_1_0; }

		//"procedure" renamings+=ProcedureRenaming ("," renamings+=ProcedureRenaming)*
		public Group getGroup_3() { return cGroup_3; }

		//"procedure"
		public Keyword getProcedureKeyword_3_0() { return cProcedureKeyword_3_0; }

		//renamings+=ProcedureRenaming
		public Assignment getRenamingsAssignment_3_1() { return cRenamingsAssignment_3_1; }

		//ProcedureRenaming
		public RuleCall getRenamingsProcedureRenamingParserRuleCall_3_1_0() { return cRenamingsProcedureRenamingParserRuleCall_3_1_0; }

		//("," renamings+=ProcedureRenaming)*
		public Group getGroup_3_2() { return cGroup_3_2; }

		//","
		public Keyword getCommaKeyword_3_2_0() { return cCommaKeyword_3_2_0; }

		//renamings+=ProcedureRenaming
		public Assignment getRenamingsAssignment_3_2_1() { return cRenamingsAssignment_3_2_1; }

		//ProcedureRenaming
		public RuleCall getRenamingsProcedureRenamingParserRuleCall_3_2_1_0() { return cRenamingsProcedureRenamingParserRuleCall_3_2_1_0; }

		//"task" renamings+=TaskRenaming ("," renamings+=TaskRenaming)*
		public Group getGroup_4() { return cGroup_4; }

		//"task"
		public Keyword getTaskKeyword_4_0() { return cTaskKeyword_4_0; }

		//renamings+=TaskRenaming
		public Assignment getRenamingsAssignment_4_1() { return cRenamingsAssignment_4_1; }

		//TaskRenaming
		public RuleCall getRenamingsTaskRenamingParserRuleCall_4_1_0() { return cRenamingsTaskRenamingParserRuleCall_4_1_0; }

		//("," renamings+=TaskRenaming)*
		public Group getGroup_4_2() { return cGroup_4_2; }

		//","
		public Keyword getCommaKeyword_4_2_0() { return cCommaKeyword_4_2_0; }

		//renamings+=TaskRenaming
		public Assignment getRenamingsAssignment_4_2_1() { return cRenamingsAssignment_4_2_1; }

		//TaskRenaming
		public RuleCall getRenamingsTaskRenamingParserRuleCall_4_2_1_0() { return cRenamingsTaskRenamingParserRuleCall_4_2_1_0; }

		//"signal" renamings+=SignalRenaming ("," renamings+=SignalRenaming)*
		public Group getGroup_5() { return cGroup_5; }

		//"signal"
		public Keyword getSignalKeyword_5_0() { return cSignalKeyword_5_0; }

		//renamings+=SignalRenaming
		public Assignment getRenamingsAssignment_5_1() { return cRenamingsAssignment_5_1; }

		//SignalRenaming
		public RuleCall getRenamingsSignalRenamingParserRuleCall_5_1_0() { return cRenamingsSignalRenamingParserRuleCall_5_1_0; }

		//("," renamings+=SignalRenaming)*
		public Group getGroup_5_2() { return cGroup_5_2; }

		//","
		public Keyword getCommaKeyword_5_2_0() { return cCommaKeyword_5_2_0; }

		//renamings+=SignalRenaming
		public Assignment getRenamingsAssignment_5_2_1() { return cRenamingsAssignment_5_2_1; }

		//SignalRenaming
		public RuleCall getRenamingsSignalRenamingParserRuleCall_5_2_1_0() { return cRenamingsSignalRenamingParserRuleCall_5_2_1_0; }
	}

	public class TypeRenamingElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.TypeRenaming");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Assignment cNewNameAssignment_0_0 = (Assignment)cAlternatives_0.eContents().get(0);
		private final CrossReference cNewNameTypeCrossReference_0_0_0 = (CrossReference)cNewNameAssignment_0_0.eContents().get(0);
		private final RuleCall cNewNameTypeIDTerminalRuleCall_0_0_0_1 = (RuleCall)cNewNameTypeCrossReference_0_0_0.eContents().get(1);
		private final Assignment cNewTypeAssignment_0_1 = (Assignment)cAlternatives_0.eContents().get(1);
		private final RuleCall cNewTypeValueTypeEnumRuleCall_0_1_0 = (RuleCall)cNewTypeAssignment_0_1.eContents().get(0);
		private final Keyword cSolidusKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cOldNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final CrossReference cOldNameTypeCrossReference_2_0 = (CrossReference)cOldNameAssignment_2.eContents().get(0);
		private final RuleCall cOldNameTypeIDTerminalRuleCall_2_0_1 = (RuleCall)cOldNameTypeCrossReference_2_0.eContents().get(1);
		
		//TypeRenaming:
		//	(newName=[Type] | newType=ValueType) "/" oldName=[Type];
		@Override public ParserRule getRule() { return rule; }

		//(newName=[Type] | newType=ValueType) "/" oldName=[Type]
		public Group getGroup() { return cGroup; }

		//(newName=[Type] | newType=ValueType)
		public Alternatives getAlternatives_0() { return cAlternatives_0; }

		//newName=[Type]
		public Assignment getNewNameAssignment_0_0() { return cNewNameAssignment_0_0; }

		//[Type]
		public CrossReference getNewNameTypeCrossReference_0_0_0() { return cNewNameTypeCrossReference_0_0_0; }

		//ID
		public RuleCall getNewNameTypeIDTerminalRuleCall_0_0_0_1() { return cNewNameTypeIDTerminalRuleCall_0_0_0_1; }

		//newType=ValueType
		public Assignment getNewTypeAssignment_0_1() { return cNewTypeAssignment_0_1; }

		//ValueType
		public RuleCall getNewTypeValueTypeEnumRuleCall_0_1_0() { return cNewTypeValueTypeEnumRuleCall_0_1_0; }

		//"/"
		public Keyword getSolidusKeyword_1() { return cSolidusKeyword_1; }

		//oldName=[Type]
		public Assignment getOldNameAssignment_2() { return cOldNameAssignment_2; }

		//[Type]
		public CrossReference getOldNameTypeCrossReference_2_0() { return cOldNameTypeCrossReference_2_0; }

		//ID
		public RuleCall getOldNameTypeIDTerminalRuleCall_2_0_1() { return cOldNameTypeIDTerminalRuleCall_2_0_1; }
	}

	public class ConstantRenamingElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.ConstantRenaming");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Assignment cNewNameAssignment_0_0 = (Assignment)cAlternatives_0.eContents().get(0);
		private final CrossReference cNewNameValuedObjectCrossReference_0_0_0 = (CrossReference)cNewNameAssignment_0_0.eContents().get(0);
		private final RuleCall cNewNameValuedObjectIDTerminalRuleCall_0_0_0_1 = (RuleCall)cNewNameValuedObjectCrossReference_0_0_0.eContents().get(1);
		private final Assignment cNewValueAssignment_0_1 = (Assignment)cAlternatives_0.eContents().get(1);
		private final RuleCall cNewValueConstantAtomParserRuleCall_0_1_0 = (RuleCall)cNewValueAssignment_0_1.eContents().get(0);
		private final Keyword cSolidusKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cOldNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final CrossReference cOldNameValuedObjectCrossReference_2_0 = (CrossReference)cOldNameAssignment_2.eContents().get(0);
		private final RuleCall cOldNameValuedObjectIDTerminalRuleCall_2_0_1 = (RuleCall)cOldNameValuedObjectCrossReference_2_0.eContents().get(1);
		
		//ConstantRenaming:
		//	(newName=[kexpressions::ValuedObject] | newValue=ConstantAtom) "/" oldName=[kexpressions::ValuedObject];
		@Override public ParserRule getRule() { return rule; }

		//(newName=[kexpressions::ValuedObject] | newValue=ConstantAtom) "/" oldName=[kexpressions::ValuedObject]
		public Group getGroup() { return cGroup; }

		//(newName=[kexpressions::ValuedObject] | newValue=ConstantAtom)
		public Alternatives getAlternatives_0() { return cAlternatives_0; }

		//newName=[kexpressions::ValuedObject]
		public Assignment getNewNameAssignment_0_0() { return cNewNameAssignment_0_0; }

		//[kexpressions::ValuedObject]
		public CrossReference getNewNameValuedObjectCrossReference_0_0_0() { return cNewNameValuedObjectCrossReference_0_0_0; }

		//ID
		public RuleCall getNewNameValuedObjectIDTerminalRuleCall_0_0_0_1() { return cNewNameValuedObjectIDTerminalRuleCall_0_0_0_1; }

		//newValue=ConstantAtom
		public Assignment getNewValueAssignment_0_1() { return cNewValueAssignment_0_1; }

		//ConstantAtom
		public RuleCall getNewValueConstantAtomParserRuleCall_0_1_0() { return cNewValueConstantAtomParserRuleCall_0_1_0; }

		//"/"
		public Keyword getSolidusKeyword_1() { return cSolidusKeyword_1; }

		//oldName=[kexpressions::ValuedObject]
		public Assignment getOldNameAssignment_2() { return cOldNameAssignment_2; }

		//[kexpressions::ValuedObject]
		public CrossReference getOldNameValuedObjectCrossReference_2_0() { return cOldNameValuedObjectCrossReference_2_0; }

		//ID
		public RuleCall getOldNameValuedObjectIDTerminalRuleCall_2_0_1() { return cOldNameValuedObjectIDTerminalRuleCall_2_0_1; }
	}

	public class FunctionRenamingElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.FunctionRenaming");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Assignment cNewNameAssignment_0_0 = (Assignment)cAlternatives_0.eContents().get(0);
		private final CrossReference cNewNameFunctionCrossReference_0_0_0 = (CrossReference)cNewNameAssignment_0_0.eContents().get(0);
		private final RuleCall cNewNameFunctionIDTerminalRuleCall_0_0_0_1 = (RuleCall)cNewNameFunctionCrossReference_0_0_0.eContents().get(1);
		private final Assignment cNewFuncAssignment_0_1 = (Assignment)cAlternatives_0.eContents().get(1);
		private final RuleCall cNewFuncBuildInFunctionParserRuleCall_0_1_0 = (RuleCall)cNewFuncAssignment_0_1.eContents().get(0);
		private final Keyword cSolidusKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cOldNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final CrossReference cOldNameFunctionCrossReference_2_0 = (CrossReference)cOldNameAssignment_2.eContents().get(0);
		private final RuleCall cOldNameFunctionIDTerminalRuleCall_2_0_1 = (RuleCall)cOldNameFunctionCrossReference_2_0.eContents().get(1);
		
		//FunctionRenaming:
		//	(newName=[Function] | newFunc=BuildInFunction) "/" oldName=[Function];
		@Override public ParserRule getRule() { return rule; }

		//(newName=[Function] | newFunc=BuildInFunction) "/" oldName=[Function]
		public Group getGroup() { return cGroup; }

		//(newName=[Function] | newFunc=BuildInFunction)
		public Alternatives getAlternatives_0() { return cAlternatives_0; }

		//newName=[Function]
		public Assignment getNewNameAssignment_0_0() { return cNewNameAssignment_0_0; }

		//[Function]
		public CrossReference getNewNameFunctionCrossReference_0_0_0() { return cNewNameFunctionCrossReference_0_0_0; }

		//ID
		public RuleCall getNewNameFunctionIDTerminalRuleCall_0_0_0_1() { return cNewNameFunctionIDTerminalRuleCall_0_0_0_1; }

		//newFunc=BuildInFunction
		public Assignment getNewFuncAssignment_0_1() { return cNewFuncAssignment_0_1; }

		//BuildInFunction
		public RuleCall getNewFuncBuildInFunctionParserRuleCall_0_1_0() { return cNewFuncBuildInFunctionParserRuleCall_0_1_0; }

		//"/"
		public Keyword getSolidusKeyword_1() { return cSolidusKeyword_1; }

		//oldName=[Function]
		public Assignment getOldNameAssignment_2() { return cOldNameAssignment_2; }

		//[Function]
		public CrossReference getOldNameFunctionCrossReference_2_0() { return cOldNameFunctionCrossReference_2_0; }

		//ID
		public RuleCall getOldNameFunctionIDTerminalRuleCall_2_0_1() { return cOldNameFunctionIDTerminalRuleCall_2_0_1; }
	}

	public class ProcedureRenamingElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.ProcedureRenaming");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNewNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cNewNameProcedureCrossReference_0_0 = (CrossReference)cNewNameAssignment_0.eContents().get(0);
		private final RuleCall cNewNameProcedureIDTerminalRuleCall_0_0_1 = (RuleCall)cNewNameProcedureCrossReference_0_0.eContents().get(1);
		private final Keyword cSolidusKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cOldNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final CrossReference cOldNameProcedureCrossReference_2_0 = (CrossReference)cOldNameAssignment_2.eContents().get(0);
		private final RuleCall cOldNameProcedureIDTerminalRuleCall_2_0_1 = (RuleCall)cOldNameProcedureCrossReference_2_0.eContents().get(1);
		
		//ProcedureRenaming:
		//	newName=[Procedure] "/" oldName=[Procedure];
		@Override public ParserRule getRule() { return rule; }

		//newName=[Procedure] "/" oldName=[Procedure]
		public Group getGroup() { return cGroup; }

		//newName=[Procedure]
		public Assignment getNewNameAssignment_0() { return cNewNameAssignment_0; }

		//[Procedure]
		public CrossReference getNewNameProcedureCrossReference_0_0() { return cNewNameProcedureCrossReference_0_0; }

		//ID
		public RuleCall getNewNameProcedureIDTerminalRuleCall_0_0_1() { return cNewNameProcedureIDTerminalRuleCall_0_0_1; }

		//"/"
		public Keyword getSolidusKeyword_1() { return cSolidusKeyword_1; }

		//oldName=[Procedure]
		public Assignment getOldNameAssignment_2() { return cOldNameAssignment_2; }

		//[Procedure]
		public CrossReference getOldNameProcedureCrossReference_2_0() { return cOldNameProcedureCrossReference_2_0; }

		//ID
		public RuleCall getOldNameProcedureIDTerminalRuleCall_2_0_1() { return cOldNameProcedureIDTerminalRuleCall_2_0_1; }
	}

	public class TaskRenamingElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.TaskRenaming");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNewNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cNewNameTaskCrossReference_0_0 = (CrossReference)cNewNameAssignment_0.eContents().get(0);
		private final RuleCall cNewNameTaskIDTerminalRuleCall_0_0_1 = (RuleCall)cNewNameTaskCrossReference_0_0.eContents().get(1);
		private final Keyword cSolidusKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cOldNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final CrossReference cOldNameTaskCrossReference_2_0 = (CrossReference)cOldNameAssignment_2.eContents().get(0);
		private final RuleCall cOldNameTaskIDTerminalRuleCall_2_0_1 = (RuleCall)cOldNameTaskCrossReference_2_0.eContents().get(1);
		
		//TaskRenaming:
		//	newName=[Task] "/" oldName=[Task];
		@Override public ParserRule getRule() { return rule; }

		//newName=[Task] "/" oldName=[Task]
		public Group getGroup() { return cGroup; }

		//newName=[Task]
		public Assignment getNewNameAssignment_0() { return cNewNameAssignment_0; }

		//[Task]
		public CrossReference getNewNameTaskCrossReference_0_0() { return cNewNameTaskCrossReference_0_0; }

		//ID
		public RuleCall getNewNameTaskIDTerminalRuleCall_0_0_1() { return cNewNameTaskIDTerminalRuleCall_0_0_1; }

		//"/"
		public Keyword getSolidusKeyword_1() { return cSolidusKeyword_1; }

		//oldName=[Task]
		public Assignment getOldNameAssignment_2() { return cOldNameAssignment_2; }

		//[Task]
		public CrossReference getOldNameTaskCrossReference_2_0() { return cOldNameTaskCrossReference_2_0; }

		//ID
		public RuleCall getOldNameTaskIDTerminalRuleCall_2_0_1() { return cOldNameTaskIDTerminalRuleCall_2_0_1; }
	}

	public class SignalRenamingElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.SignalRenaming");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Assignment cNewNameAssignment_0_0 = (Assignment)cAlternatives_0.eContents().get(0);
		private final CrossReference cNewNameISignalCrossReference_0_0_0 = (CrossReference)cNewNameAssignment_0_0.eContents().get(0);
		private final RuleCall cNewNameISignalIDTerminalRuleCall_0_0_0_1 = (RuleCall)cNewNameISignalCrossReference_0_0_0.eContents().get(1);
		private final Keyword cTickKeyword_0_1 = (Keyword)cAlternatives_0.eContents().get(1);
		private final Keyword cSolidusKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cOldNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final CrossReference cOldNameISignalCrossReference_2_0 = (CrossReference)cOldNameAssignment_2.eContents().get(0);
		private final RuleCall cOldNameISignalIDTerminalRuleCall_2_0_1 = (RuleCall)cOldNameISignalCrossReference_2_0.eContents().get(1);
		
		//SignalRenaming:
		//	(newName=[kexpressions::ISignal] | "tick") "/" oldName=[kexpressions::ISignal];
		@Override public ParserRule getRule() { return rule; }

		//(newName=[kexpressions::ISignal] | "tick") "/" oldName=[kexpressions::ISignal]
		public Group getGroup() { return cGroup; }

		//(newName=[kexpressions::ISignal] | "tick")
		public Alternatives getAlternatives_0() { return cAlternatives_0; }

		//newName=[kexpressions::ISignal]
		public Assignment getNewNameAssignment_0_0() { return cNewNameAssignment_0_0; }

		//[kexpressions::ISignal]
		public CrossReference getNewNameISignalCrossReference_0_0_0() { return cNewNameISignalCrossReference_0_0_0; }

		//ID
		public RuleCall getNewNameISignalIDTerminalRuleCall_0_0_0_1() { return cNewNameISignalIDTerminalRuleCall_0_0_0_1; }

		//"tick"
		public Keyword getTickKeyword_0_1() { return cTickKeyword_0_1; }

		//"/"
		public Keyword getSolidusKeyword_1() { return cSolidusKeyword_1; }

		//oldName=[kexpressions::ISignal]
		public Assignment getOldNameAssignment_2() { return cOldNameAssignment_2; }

		//[kexpressions::ISignal]
		public CrossReference getOldNameISignalCrossReference_2_0() { return cOldNameISignalCrossReference_2_0; }

		//ID
		public RuleCall getOldNameISignalIDTerminalRuleCall_2_0_1() { return cOldNameISignalIDTerminalRuleCall_2_0_1; }
	}

	public class BuildInFunctionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.BuildInFunction");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cAsteriskKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cSolidusKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cPlusSignKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cHyphenMinusKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cModKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		private final Keyword cEqualsSignKeyword_5 = (Keyword)cAlternatives.eContents().get(5);
		private final Keyword cLessThanSignGreaterThanSignKeyword_6 = (Keyword)cAlternatives.eContents().get(6);
		private final Keyword cGreaterThanSignKeyword_7 = (Keyword)cAlternatives.eContents().get(7);
		private final Keyword cLessThanSignKeyword_8 = (Keyword)cAlternatives.eContents().get(8);
		private final Keyword cLessThanSignEqualsSignKeyword_9 = (Keyword)cAlternatives.eContents().get(9);
		private final Keyword cGreaterThanSignEqualsSignKeyword_10 = (Keyword)cAlternatives.eContents().get(10);
		private final Keyword cNotKeyword_11 = (Keyword)cAlternatives.eContents().get(11);
		private final Keyword cAndKeyword_12 = (Keyword)cAlternatives.eContents().get(12);
		private final Keyword cOrKeyword_13 = (Keyword)cAlternatives.eContents().get(13);
		
		//// renamings can also rename build in types and functions
		//BuildInFunction:
		//	"*" | "/" | "+" | "-" | "mod" | "=" | "<>" | ">" | "<" | "<=" | ">=" | "not" | "and" | "or";
		@Override public ParserRule getRule() { return rule; }

		//"*" | "/" | "+" | "-" | "mod" | "=" | "<>" | ">" | "<" | "<=" | ">=" | "not" | "and" | "or"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"*"
		public Keyword getAsteriskKeyword_0() { return cAsteriskKeyword_0; }

		//"/"
		public Keyword getSolidusKeyword_1() { return cSolidusKeyword_1; }

		//"+"
		public Keyword getPlusSignKeyword_2() { return cPlusSignKeyword_2; }

		//"-"
		public Keyword getHyphenMinusKeyword_3() { return cHyphenMinusKeyword_3; }

		//"mod"
		public Keyword getModKeyword_4() { return cModKeyword_4; }

		//"="
		public Keyword getEqualsSignKeyword_5() { return cEqualsSignKeyword_5; }

		//"<>"
		public Keyword getLessThanSignGreaterThanSignKeyword_6() { return cLessThanSignGreaterThanSignKeyword_6; }

		//">"
		public Keyword getGreaterThanSignKeyword_7() { return cGreaterThanSignKeyword_7; }

		//"<"
		public Keyword getLessThanSignKeyword_8() { return cLessThanSignKeyword_8; }

		//"<="
		public Keyword getLessThanSignEqualsSignKeyword_9() { return cLessThanSignEqualsSignKeyword_9; }

		//">="
		public Keyword getGreaterThanSignEqualsSignKeyword_10() { return cGreaterThanSignEqualsSignKeyword_10; }

		//"not"
		public Keyword getNotKeyword_11() { return cNotKeyword_11; }

		//"and"
		public Keyword getAndKeyword_12() { return cAndKeyword_12; }

		//"or"
		public Keyword getOrKeyword_13() { return cOrKeyword_13; }
	}

	public class SuspendElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.Suspend");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cSuspendKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cStatementAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cStatementStatementParserRuleCall_1_0 = (RuleCall)cStatementAssignment_1.eContents().get(0);
		private final Keyword cWhenKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cDelayAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cDelayDelayExprParserRuleCall_3_0 = (RuleCall)cDelayAssignment_3.eContents().get(0);
		
		//// --> B.4.21 suspend: Preemption with State Freeze
		//// !-(suspend)-------------------------------------
		//Suspend:
		//	"suspend" statement=Statement "when" delay=DelayExpr;
		@Override public ParserRule getRule() { return rule; }

		//"suspend" statement=Statement "when" delay=DelayExpr
		public Group getGroup() { return cGroup; }

		//"suspend"
		public Keyword getSuspendKeyword_0() { return cSuspendKeyword_0; }

		//statement=Statement
		public Assignment getStatementAssignment_1() { return cStatementAssignment_1; }

		//Statement
		public RuleCall getStatementStatementParserRuleCall_1_0() { return cStatementStatementParserRuleCall_1_0; }

		//"when"
		public Keyword getWhenKeyword_2() { return cWhenKeyword_2; }

		//delay=DelayExpr
		public Assignment getDelayAssignment_3() { return cDelayAssignment_3; }

		//DelayExpr
		public RuleCall getDelayDelayExprParserRuleCall_3_0() { return cDelayDelayExprParserRuleCall_3_0; }
	}

	public class WeakSuspendElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.WeakSuspend");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cWeakKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cSuspendKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cStatementAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cStatementStatementParserRuleCall_2_0 = (RuleCall)cStatementAssignment_2.eContents().get(0);
		private final Keyword cWhenKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cDelayAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cDelayDelayExprParserRuleCall_4_0 = (RuleCall)cDelayAssignment_4.eContents().get(0);
		
		//// !-(weak suspend)-------------------------------------
		//WeakSuspend:
		//	"weak" "suspend" statement=Statement "when" delay=DelayExpr;
		@Override public ParserRule getRule() { return rule; }

		//"weak" "suspend" statement=Statement "when" delay=DelayExpr
		public Group getGroup() { return cGroup; }

		//"weak"
		public Keyword getWeakKeyword_0() { return cWeakKeyword_0; }

		//"suspend"
		public Keyword getSuspendKeyword_1() { return cSuspendKeyword_1; }

		//statement=Statement
		public Assignment getStatementAssignment_2() { return cStatementAssignment_2; }

		//Statement
		public RuleCall getStatementStatementParserRuleCall_2_0() { return cStatementStatementParserRuleCall_2_0; }

		//"when"
		public Keyword getWhenKeyword_3() { return cWhenKeyword_3; }

		//delay=DelayExpr
		public Assignment getDelayAssignment_4() { return cDelayAssignment_4; }

		//DelayExpr
		public RuleCall getDelayDelayExprParserRuleCall_4_0() { return cDelayDelayExprParserRuleCall_4_0; }
	}

	public class SustainElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.Sustain");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cSustainKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Assignment cSignalAssignment_1_0 = (Assignment)cAlternatives_1.eContents().get(0);
		private final CrossReference cSignalISignalCrossReference_1_0_0 = (CrossReference)cSignalAssignment_1_0.eContents().get(0);
		private final RuleCall cSignalISignalIDTerminalRuleCall_1_0_0_1 = (RuleCall)cSignalISignalCrossReference_1_0_0.eContents().get(1);
		private final Assignment cTickAssignment_1_1 = (Assignment)cAlternatives_1.eContents().get(1);
		private final RuleCall cTickTickParserRuleCall_1_1_0 = (RuleCall)cTickAssignment_1_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cLeftParenthesisKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cExpressionAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cExpressionExpressionParserRuleCall_2_1_0 = (RuleCall)cExpressionAssignment_2_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_2_2 = (Keyword)cGroup_2.eContents().get(2);
		
		//// -!
		//// --> B.4.22 sustain: Emit a Signal Indefinitely
		//// !-(sustain) -------------------------------------
		//Sustain:
		//	"sustain" (signal=[kexpressions::ISignal] | tick=Tick) ("(" expression=Expression ")")?;
		@Override public ParserRule getRule() { return rule; }

		//"sustain" (signal=[kexpressions::ISignal] | tick=Tick) ("(" expression=Expression ")")?
		public Group getGroup() { return cGroup; }

		//"sustain"
		public Keyword getSustainKeyword_0() { return cSustainKeyword_0; }

		//(signal=[kexpressions::ISignal] | tick=Tick)
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//signal=[kexpressions::ISignal]
		public Assignment getSignalAssignment_1_0() { return cSignalAssignment_1_0; }

		//[kexpressions::ISignal]
		public CrossReference getSignalISignalCrossReference_1_0_0() { return cSignalISignalCrossReference_1_0_0; }

		//ID
		public RuleCall getSignalISignalIDTerminalRuleCall_1_0_0_1() { return cSignalISignalIDTerminalRuleCall_1_0_0_1; }

		//tick=Tick
		public Assignment getTickAssignment_1_1() { return cTickAssignment_1_1; }

		//Tick
		public RuleCall getTickTickParserRuleCall_1_1_0() { return cTickTickParserRuleCall_1_1_0; }

		//("(" expression=Expression ")")?
		public Group getGroup_2() { return cGroup_2; }

		//"("
		public Keyword getLeftParenthesisKeyword_2_0() { return cLeftParenthesisKeyword_2_0; }

		//expression=Expression
		public Assignment getExpressionAssignment_2_1() { return cExpressionAssignment_2_1; }

		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_2_1_0() { return cExpressionExpressionParserRuleCall_2_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_2_2() { return cRightParenthesisKeyword_2_2; }
	}

	public class TrapElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.Trap");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cTrapKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cTrapDeclListAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cTrapDeclListTrapDeclListParserRuleCall_1_0 = (RuleCall)cTrapDeclListAssignment_1.eContents().get(0);
		private final Keyword cInKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cStatementAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cStatementStatementParserRuleCall_3_0 = (RuleCall)cStatementAssignment_3.eContents().get(0);
		private final Assignment cTrapHandlerAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cTrapHandlerTrapHandlerParserRuleCall_4_0 = (RuleCall)cTrapHandlerAssignment_4.eContents().get(0);
		private final Keyword cEndKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cOptEndAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final Keyword cOptEndTrapKeyword_6_0 = (Keyword)cOptEndAssignment_6.eContents().get(0);
		
		//// -!
		//// --> B.4.23 trap: TrapDeclaration and Handling
		//// !-(trap)-------------------------------------
		//Trap:
		//	"trap" trapDeclList=TrapDeclList "in" statement=Statement
		//	trapHandler+=TrapHandler* "end" optEnd="trap"?;
		@Override public ParserRule getRule() { return rule; }

		//"trap" trapDeclList=TrapDeclList "in" statement=Statement trapHandler+=TrapHandler* "end" optEnd="trap"?
		public Group getGroup() { return cGroup; }

		//"trap"
		public Keyword getTrapKeyword_0() { return cTrapKeyword_0; }

		//trapDeclList=TrapDeclList
		public Assignment getTrapDeclListAssignment_1() { return cTrapDeclListAssignment_1; }

		//TrapDeclList
		public RuleCall getTrapDeclListTrapDeclListParserRuleCall_1_0() { return cTrapDeclListTrapDeclListParserRuleCall_1_0; }

		//"in"
		public Keyword getInKeyword_2() { return cInKeyword_2; }

		//statement=Statement
		public Assignment getStatementAssignment_3() { return cStatementAssignment_3; }

		//Statement
		public RuleCall getStatementStatementParserRuleCall_3_0() { return cStatementStatementParserRuleCall_3_0; }

		//trapHandler+=TrapHandler*
		public Assignment getTrapHandlerAssignment_4() { return cTrapHandlerAssignment_4; }

		//TrapHandler
		public RuleCall getTrapHandlerTrapHandlerParserRuleCall_4_0() { return cTrapHandlerTrapHandlerParserRuleCall_4_0; }

		//"end"
		public Keyword getEndKeyword_5() { return cEndKeyword_5; }

		//optEnd="trap"?
		public Assignment getOptEndAssignment_6() { return cOptEndAssignment_6; }

		//"trap"
		public Keyword getOptEndTrapKeyword_6_0() { return cOptEndTrapKeyword_6_0; }
	}

	public class TrapDeclListElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.TrapDeclList");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTrapDeclsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cTrapDeclsTrapDeclParserRuleCall_0_0 = (RuleCall)cTrapDeclsAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCommaKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cTrapDeclsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cTrapDeclsTrapDeclParserRuleCall_1_1_0 = (RuleCall)cTrapDeclsAssignment_1_1.eContents().get(0);
		
		//TrapDeclList:
		//	trapDecls+=TrapDecl ("," trapDecls+=TrapDecl)*;
		@Override public ParserRule getRule() { return rule; }

		//trapDecls+=TrapDecl ("," trapDecls+=TrapDecl)*
		public Group getGroup() { return cGroup; }

		//trapDecls+=TrapDecl
		public Assignment getTrapDeclsAssignment_0() { return cTrapDeclsAssignment_0; }

		//TrapDecl
		public RuleCall getTrapDeclsTrapDeclParserRuleCall_0_0() { return cTrapDeclsTrapDeclParserRuleCall_0_0; }

		//("," trapDecls+=TrapDecl)*
		public Group getGroup_1() { return cGroup_1; }

		//","
		public Keyword getCommaKeyword_1_0() { return cCommaKeyword_1_0; }

		//trapDecls+=TrapDecl
		public Assignment getTrapDeclsAssignment_1_1() { return cTrapDeclsAssignment_1_1; }

		//TrapDecl
		public RuleCall getTrapDeclsTrapDeclParserRuleCall_1_1_0() { return cTrapDeclsTrapDeclParserRuleCall_1_1_0; }
	}

	public class TrapDeclElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.TrapDecl");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cTrapDeclAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Assignment cChannelDescrAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cChannelDescrChannelDescriptionParserRuleCall_2_0 = (RuleCall)cChannelDescrAssignment_2.eContents().get(0);
		
		//TrapDecl kexpressions::ISignal:
		//	{TrapDecl} name=ID channelDescr=ChannelDescription?
		@Override public ParserRule getRule() { return rule; }

		//{TrapDecl} name=ID channelDescr=ChannelDescription?
		public Group getGroup() { return cGroup; }

		//{TrapDecl}
		public Action getTrapDeclAction_0() { return cTrapDeclAction_0; }

		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }

		//channelDescr=ChannelDescription?
		public Assignment getChannelDescrAssignment_2() { return cChannelDescrAssignment_2; }

		//ChannelDescription
		public RuleCall getChannelDescrChannelDescriptionParserRuleCall_2_0() { return cChannelDescrChannelDescriptionParserRuleCall_2_0; }
	}

	public class TrapHandlerElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.TrapHandler");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cHandleKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cTrapExprAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cTrapExprTrapExprParserRuleCall_1_0 = (RuleCall)cTrapExprAssignment_1.eContents().get(0);
		private final Keyword cDoKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cStatementAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cStatementStatementParserRuleCall_3_0 = (RuleCall)cStatementAssignment_3.eContents().get(0);
		
		//TrapHandler:
		//	"handle" trapExpr=TrapExpr "do" statement=Statement;
		@Override public ParserRule getRule() { return rule; }

		//"handle" trapExpr=TrapExpr "do" statement=Statement
		public Group getGroup() { return cGroup; }

		//"handle"
		public Keyword getHandleKeyword_0() { return cHandleKeyword_0; }

		//trapExpr=TrapExpr
		public Assignment getTrapExprAssignment_1() { return cTrapExprAssignment_1; }

		//TrapExpr
		public RuleCall getTrapExprTrapExprParserRuleCall_1_0() { return cTrapExprTrapExprParserRuleCall_1_0; }

		//"do"
		public Keyword getDoKeyword_2() { return cDoKeyword_2; }

		//statement=Statement
		public Assignment getStatementAssignment_3() { return cStatementAssignment_3; }

		//Statement
		public RuleCall getStatementStatementParserRuleCall_3_0() { return cStatementStatementParserRuleCall_3_0; }
	}

	public class LocalVariableElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.LocalVariable");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cVarAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cVarInterfaceVariableDeclParserRuleCall_0_0 = (RuleCall)cVarAssignment_0.eContents().get(0);
		private final Keyword cInKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cStatementAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cStatementStatementParserRuleCall_2_0 = (RuleCall)cStatementAssignment_2.eContents().get(0);
		private final Keyword cEndKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cOptEndAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final Keyword cOptEndVarKeyword_4_0 = (Keyword)cOptEndAssignment_4.eContents().get(0);
		
		//// -!
		//// --> B.4.24 var: Local Variable Declaration
		//// !-(localvariable) -------------------------------------
		//LocalVariable:
		//	var=InterfaceVariableDecl "in" statement=Statement "end" optEnd="var"?;
		@Override public ParserRule getRule() { return rule; }

		//var=InterfaceVariableDecl "in" statement=Statement "end" optEnd="var"?
		public Group getGroup() { return cGroup; }

		//var=InterfaceVariableDecl
		public Assignment getVarAssignment_0() { return cVarAssignment_0; }

		//InterfaceVariableDecl
		public RuleCall getVarInterfaceVariableDeclParserRuleCall_0_0() { return cVarInterfaceVariableDeclParserRuleCall_0_0; }

		//"in"
		public Keyword getInKeyword_1() { return cInKeyword_1; }

		//statement=Statement
		public Assignment getStatementAssignment_2() { return cStatementAssignment_2; }

		//Statement
		public RuleCall getStatementStatementParserRuleCall_2_0() { return cStatementStatementParserRuleCall_2_0; }

		//"end"
		public Keyword getEndKeyword_3() { return cEndKeyword_3; }

		//optEnd="var"?
		public Assignment getOptEndAssignment_4() { return cOptEndAssignment_4; }

		//"var"
		public Keyword getOptEndVarKeyword_4_0() { return cOptEndVarKeyword_4_0; }
	}

	public class GotoElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.Goto");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cGotoKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cTargetLabelAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cTargetLabelIDTerminalRuleCall_1_0 = (RuleCall)cTargetLabelAssignment_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//// -!
		//// ==============================================
		//// ===            B.2.5 SCL             ===
		//// ==============================================
		//// goto -------------------------------------
		//Goto:
		//	"goto" targetLabel=ID ";";
		@Override public ParserRule getRule() { return rule; }

		//"goto" targetLabel=ID ";"
		public Group getGroup() { return cGroup; }

		//"goto"
		public Keyword getGotoKeyword_0() { return cGotoKeyword_0; }

		//targetLabel=ID
		public Assignment getTargetLabelAssignment_1() { return cTargetLabelAssignment_1; }

		//ID
		public RuleCall getTargetLabelIDTerminalRuleCall_1_0() { return cTargetLabelIDTerminalRuleCall_1_0; }

		//";"
		public Keyword getSemicolonKeyword_2() { return cSemicolonKeyword_2; }
	}

	public class LabelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.Label");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cLabelAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cLabelIDTerminalRuleCall_0_0 = (RuleCall)cLabelAssignment_0.eContents().get(0);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//Label:
		//	label=ID ':';
		@Override public ParserRule getRule() { return rule; }

		//label=ID ':'
		public Group getGroup() { return cGroup; }

		//label=ID
		public Assignment getLabelAssignment_0() { return cLabelAssignment_0; }

		//ID
		public RuleCall getLabelIDTerminalRuleCall_0_0() { return cLabelIDTerminalRuleCall_0_0; }

		//':'
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }
	}

	public class AtomicExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.AtomicExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cFunctionExpressionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cTrapExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cBooleanValueParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cValuedObjectTestExpressionParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cTextExpressionParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final Group cGroup_5 = (Group)cAlternatives.eContents().get(5);
		private final Keyword cLeftParenthesisKeyword_5_0 = (Keyword)cGroup_5.eContents().get(0);
		private final RuleCall cBooleanExpressionParserRuleCall_5_1 = (RuleCall)cGroup_5.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_5_2 = (Keyword)cGroup_5.eContents().get(2);
		private final RuleCall cConstantExpressionParserRuleCall_6 = (RuleCall)cAlternatives.eContents().get(6);
		
		//// ==============================================
		//// ===            B.3 Expressions             ===
		//// ==============================================
		//// esterel is a bit richer than what is provided by kexpressions. These rules are introduced here
		//// care about order of the rules! 
		//AtomicExpression kexpressions::Expression:
		//	FunctionExpression
		//	| TrapExpression
		//	| BooleanValue
		//	| ValuedObjectTestExpression
		//	| TextExpression
		//	| '(' BooleanExpression ')'
		//	| ConstantExpression
		@Override public ParserRule getRule() { return rule; }

		//FunctionExpression | TrapExpression | BooleanValue | ValuedObjectTestExpression | TextExpression | '(' BooleanExpression
		//')' | ConstantExpression
		public Alternatives getAlternatives() { return cAlternatives; }

		//FunctionExpression
		public RuleCall getFunctionExpressionParserRuleCall_0() { return cFunctionExpressionParserRuleCall_0; }

		//TrapExpression
		public RuleCall getTrapExpressionParserRuleCall_1() { return cTrapExpressionParserRuleCall_1; }

		//BooleanValue
		public RuleCall getBooleanValueParserRuleCall_2() { return cBooleanValueParserRuleCall_2; }

		//ValuedObjectTestExpression
		public RuleCall getValuedObjectTestExpressionParserRuleCall_3() { return cValuedObjectTestExpressionParserRuleCall_3; }

		//TextExpression
		public RuleCall getTextExpressionParserRuleCall_4() { return cTextExpressionParserRuleCall_4; }

		//'(' BooleanExpression ')'
		public Group getGroup_5() { return cGroup_5; }

		//'('
		public Keyword getLeftParenthesisKeyword_5_0() { return cLeftParenthesisKeyword_5_0; }

		//BooleanExpression
		public RuleCall getBooleanExpressionParserRuleCall_5_1() { return cBooleanExpressionParserRuleCall_5_1; }

		//')'
		public Keyword getRightParenthesisKeyword_5_2() { return cRightParenthesisKeyword_5_2; }

		//ConstantExpression
		public RuleCall getConstantExpressionParserRuleCall_6() { return cConstantExpressionParserRuleCall_6; }
	}

	public class TrapExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.TrapExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cTrapExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cQuestionMarkQuestionMarkKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTrapAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final CrossReference cTrapISignalCrossReference_2_0 = (CrossReference)cTrapAssignment_2.eContents().get(0);
		private final RuleCall cTrapISignalIDTerminalRuleCall_2_0_1 = (RuleCall)cTrapISignalCrossReference_2_0.eContents().get(1);
		
		//TrapExpression kexpressions::Expression:
		//	{TrapExpression} "??" trap=[kexpressions::ISignal]
		@Override public ParserRule getRule() { return rule; }

		//{TrapExpression} "??" trap=[kexpressions::ISignal]
		public Group getGroup() { return cGroup; }

		//{TrapExpression}
		public Action getTrapExpressionAction_0() { return cTrapExpressionAction_0; }

		//"??"
		public Keyword getQuestionMarkQuestionMarkKeyword_1() { return cQuestionMarkQuestionMarkKeyword_1; }

		//trap=[kexpressions::ISignal]
		public Assignment getTrapAssignment_2() { return cTrapAssignment_2; }

		//[kexpressions::ISignal]
		public CrossReference getTrapISignalCrossReference_2_0() { return cTrapISignalCrossReference_2_0; }

		//ID
		public RuleCall getTrapISignalIDTerminalRuleCall_2_0_1() { return cTrapISignalIDTerminalRuleCall_2_0_1; }
	}

	public class FunctionExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.FunctionExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cFunctionExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cFunctionAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cFunctionFunctionCrossReference_1_0 = (CrossReference)cFunctionAssignment_1.eContents().get(0);
		private final RuleCall cFunctionFunctionIDTerminalRuleCall_1_0_1 = (RuleCall)cFunctionFunctionCrossReference_1_0.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Assignment cKexpressionsAssignment_3_0 = (Assignment)cGroup_3.eContents().get(0);
		private final RuleCall cKexpressionsExpressionParserRuleCall_3_0_0 = (RuleCall)cKexpressionsAssignment_3_0.eContents().get(0);
		private final Group cGroup_3_1 = (Group)cGroup_3.eContents().get(1);
		private final Keyword cCommaKeyword_3_1_0 = (Keyword)cGroup_3_1.eContents().get(0);
		private final Assignment cKexpressionsAssignment_3_1_1 = (Assignment)cGroup_3_1.eContents().get(1);
		private final RuleCall cKexpressionsExpressionParserRuleCall_3_1_1_0 = (RuleCall)cKexpressionsAssignment_3_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//FunctionExpression kexpressions::Expression:
		//	{FunctionExpression} function=[Function] "(" (kexpressions+=Expression ("," kexpressions+=Expression)*)? ")"
		@Override public ParserRule getRule() { return rule; }

		//{FunctionExpression} function=[Function] "(" (kexpressions+=Expression ("," kexpressions+=Expression)*)? ")"
		public Group getGroup() { return cGroup; }

		//{FunctionExpression}
		public Action getFunctionExpressionAction_0() { return cFunctionExpressionAction_0; }

		//function=[Function]
		public Assignment getFunctionAssignment_1() { return cFunctionAssignment_1; }

		//[Function]
		public CrossReference getFunctionFunctionCrossReference_1_0() { return cFunctionFunctionCrossReference_1_0; }

		//ID
		public RuleCall getFunctionFunctionIDTerminalRuleCall_1_0_1() { return cFunctionFunctionIDTerminalRuleCall_1_0_1; }

		//"("
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }

		//(kexpressions+=Expression ("," kexpressions+=Expression)*)?
		public Group getGroup_3() { return cGroup_3; }

		//kexpressions+=Expression
		public Assignment getKexpressionsAssignment_3_0() { return cKexpressionsAssignment_3_0; }

		//Expression
		public RuleCall getKexpressionsExpressionParserRuleCall_3_0_0() { return cKexpressionsExpressionParserRuleCall_3_0_0; }

		//("," kexpressions+=Expression)*
		public Group getGroup_3_1() { return cGroup_3_1; }

		//","
		public Keyword getCommaKeyword_3_1_0() { return cCommaKeyword_3_1_0; }

		//kexpressions+=Expression
		public Assignment getKexpressionsAssignment_3_1_1() { return cKexpressionsAssignment_3_1_1; }

		//Expression
		public RuleCall getKexpressionsExpressionParserRuleCall_3_1_1_0() { return cKexpressionsExpressionParserRuleCall_3_1_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
	}

	public class ConstantExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.ConstantExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cConstantExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Assignment cConstantAssignment_1_0 = (Assignment)cAlternatives_1.eContents().get(0);
		private final CrossReference cConstantConstantCrossReference_1_0_0 = (CrossReference)cConstantAssignment_1_0.eContents().get(0);
		private final RuleCall cConstantConstantIDTerminalRuleCall_1_0_0_1 = (RuleCall)cConstantConstantCrossReference_1_0_0.eContents().get(1);
		private final Assignment cValueAssignment_1_1 = (Assignment)cAlternatives_1.eContents().get(1);
		private final RuleCall cValueConstantAtomParserRuleCall_1_1_0 = (RuleCall)cValueAssignment_1_1.eContents().get(0);
		
		//ConstantExpression kexpressions::Expression:
		//	{ConstantExpression} (constant=[Constant] | value=ConstantAtom)
		@Override public ParserRule getRule() { return rule; }

		//{ConstantExpression} (constant=[Constant] | value=ConstantAtom)
		public Group getGroup() { return cGroup; }

		//{ConstantExpression}
		public Action getConstantExpressionAction_0() { return cConstantExpressionAction_0; }

		//(constant=[Constant] | value=ConstantAtom)
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//constant=[Constant]
		public Assignment getConstantAssignment_1_0() { return cConstantAssignment_1_0; }

		//[Constant]
		public CrossReference getConstantConstantCrossReference_1_0_0() { return cConstantConstantCrossReference_1_0_0; }

		//ID
		public RuleCall getConstantConstantIDTerminalRuleCall_1_0_0_1() { return cConstantConstantIDTerminalRuleCall_1_0_0_1; }

		//value=ConstantAtom
		public Assignment getValueAssignment_1_1() { return cValueAssignment_1_1; }

		//ConstantAtom
		public RuleCall getValueConstantAtomParserRuleCall_1_1_0() { return cValueConstantAtomParserRuleCall_1_1_0; }
	}

	public class TrapExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.TrapExpr");
		private final RuleCall cSignalExpressionParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//// --> B.3.5 Trap Expressions <--
		//// -------------------------------------
		//TrapExpr kexpressions::Expression:
		//	SignalExpression
		@Override public ParserRule getRule() { return rule; }

		//SignalExpression
		public RuleCall getSignalExpressionParserRuleCall() { return cSignalExpressionParserRuleCall; }
	}

	public class SignalExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.SignalExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cSignalAndExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cOperatorExpressionSubExpressionsAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOperatorOrOperatorEnumRuleCall_1_1_0 = (RuleCall)cOperatorAssignment_1_1.eContents().get(0);
		private final Assignment cSubExpressionsAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cSubExpressionsSignalAndExpressionParserRuleCall_1_2_0 = (RuleCall)cSubExpressionsAssignment_1_2.eContents().get(0);
		
		//// --> B.3.3 Signal Expressions <--
		//// -------------------------------------
		//SignalExpression kexpressions::Expression:
		//	SignalAndExpression ({kexpressions::OperatorExpression.subExpressions+=current} operator=OrOperator
		//	subExpressions+=SignalAndExpression)*
		@Override public ParserRule getRule() { return rule; }

		//SignalAndExpression ({kexpressions::OperatorExpression.subExpressions+=current} operator=OrOperator
		//subExpressions+=SignalAndExpression)*
		public Group getGroup() { return cGroup; }

		//SignalAndExpression
		public RuleCall getSignalAndExpressionParserRuleCall_0() { return cSignalAndExpressionParserRuleCall_0; }

		//({kexpressions::OperatorExpression.subExpressions+=current} operator=OrOperator subExpressions+=SignalAndExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{kexpressions::OperatorExpression.subExpressions+=current}
		public Action getOperatorExpressionSubExpressionsAction_1_0() { return cOperatorExpressionSubExpressionsAction_1_0; }

		//operator=OrOperator
		public Assignment getOperatorAssignment_1_1() { return cOperatorAssignment_1_1; }

		//OrOperator
		public RuleCall getOperatorOrOperatorEnumRuleCall_1_1_0() { return cOperatorOrOperatorEnumRuleCall_1_1_0; }

		//subExpressions+=SignalAndExpression
		public Assignment getSubExpressionsAssignment_1_2() { return cSubExpressionsAssignment_1_2; }

		//SignalAndExpression
		public RuleCall getSubExpressionsSignalAndExpressionParserRuleCall_1_2_0() { return cSubExpressionsSignalAndExpressionParserRuleCall_1_2_0; }
	}

	public class SignalAndExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.SignalAndExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cSignalNotExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cOperatorExpressionSubExpressionsAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOperatorAndOperatorEnumRuleCall_1_1_0 = (RuleCall)cOperatorAssignment_1_1.eContents().get(0);
		private final Assignment cSubExpressionsAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cSubExpressionsSignalNotExpressionParserRuleCall_1_2_0 = (RuleCall)cSubExpressionsAssignment_1_2.eContents().get(0);
		
		//SignalAndExpression kexpressions::Expression:
		//	SignalNotExpression ({kexpressions::OperatorExpression.subExpressions+=current} operator=AndOperator
		//	subExpressions+=SignalNotExpression)*
		@Override public ParserRule getRule() { return rule; }

		//SignalNotExpression ({kexpressions::OperatorExpression.subExpressions+=current} operator=AndOperator
		//subExpressions+=SignalNotExpression)*
		public Group getGroup() { return cGroup; }

		//SignalNotExpression
		public RuleCall getSignalNotExpressionParserRuleCall_0() { return cSignalNotExpressionParserRuleCall_0; }

		//({kexpressions::OperatorExpression.subExpressions+=current} operator=AndOperator subExpressions+=SignalNotExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{kexpressions::OperatorExpression.subExpressions+=current}
		public Action getOperatorExpressionSubExpressionsAction_1_0() { return cOperatorExpressionSubExpressionsAction_1_0; }

		//operator=AndOperator
		public Assignment getOperatorAssignment_1_1() { return cOperatorAssignment_1_1; }

		//AndOperator
		public RuleCall getOperatorAndOperatorEnumRuleCall_1_1_0() { return cOperatorAndOperatorEnumRuleCall_1_1_0; }

		//subExpressions+=SignalNotExpression
		public Assignment getSubExpressionsAssignment_1_2() { return cSubExpressionsAssignment_1_2; }

		//SignalNotExpression
		public RuleCall getSubExpressionsSignalNotExpressionParserRuleCall_1_2_0() { return cSubExpressionsSignalNotExpressionParserRuleCall_1_2_0; }
	}

	public class SignalNotExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.SignalNotExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cOperatorExpressionAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Assignment cOperatorAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cOperatorNotOperatorEnumRuleCall_0_1_0 = (RuleCall)cOperatorAssignment_0_1.eContents().get(0);
		private final Assignment cSubExpressionsAssignment_0_2 = (Assignment)cGroup_0.eContents().get(2);
		private final RuleCall cSubExpressionsSignalNotExpressionParserRuleCall_0_2_0 = (RuleCall)cSubExpressionsAssignment_0_2.eContents().get(0);
		private final RuleCall cSignalAtomicExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//SignalNotExpression kexpressions::Expression:
		//	{kexpressions::OperatorExpression} operator=NotOperator subExpressions+=SignalNotExpression | SignalAtomicExpression
		@Override public ParserRule getRule() { return rule; }

		//{kexpressions::OperatorExpression} operator=NotOperator subExpressions+=SignalNotExpression | SignalAtomicExpression
		public Alternatives getAlternatives() { return cAlternatives; }

		//{kexpressions::OperatorExpression} operator=NotOperator subExpressions+=SignalNotExpression
		public Group getGroup_0() { return cGroup_0; }

		//{kexpressions::OperatorExpression}
		public Action getOperatorExpressionAction_0_0() { return cOperatorExpressionAction_0_0; }

		//operator=NotOperator
		public Assignment getOperatorAssignment_0_1() { return cOperatorAssignment_0_1; }

		//NotOperator
		public RuleCall getOperatorNotOperatorEnumRuleCall_0_1_0() { return cOperatorNotOperatorEnumRuleCall_0_1_0; }

		//subExpressions+=SignalNotExpression
		public Assignment getSubExpressionsAssignment_0_2() { return cSubExpressionsAssignment_0_2; }

		//SignalNotExpression
		public RuleCall getSubExpressionsSignalNotExpressionParserRuleCall_0_2_0() { return cSubExpressionsSignalNotExpressionParserRuleCall_0_2_0; }

		//SignalAtomicExpression
		public RuleCall getSignalAtomicExpressionParserRuleCall_1() { return cSignalAtomicExpressionParserRuleCall_1; }
	}

	public class SignalAtomicExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.SignalAtomicExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cSignalReferenceExprParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cSignalExpressionParserRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		private final RuleCall cSignalPreExprParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cTrapReferenceExprParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//SignalAtomicExpression kexpressions::Expression:
		//	SignalReferenceExpr
		//	| "(" SignalExpression ")"
		//	| SignalPreExpr
		//	| TrapReferenceExpr
		@Override public ParserRule getRule() { return rule; }

		//SignalReferenceExpr | "(" SignalExpression ")" | SignalPreExpr | TrapReferenceExpr
		public Alternatives getAlternatives() { return cAlternatives; }

		//SignalReferenceExpr
		public RuleCall getSignalReferenceExprParserRuleCall_0() { return cSignalReferenceExprParserRuleCall_0; }

		//"(" SignalExpression ")"
		public Group getGroup_1() { return cGroup_1; }

		//"("
		public Keyword getLeftParenthesisKeyword_1_0() { return cLeftParenthesisKeyword_1_0; }

		//SignalExpression
		public RuleCall getSignalExpressionParserRuleCall_1_1() { return cSignalExpressionParserRuleCall_1_1; }

		//")"
		public Keyword getRightParenthesisKeyword_1_2() { return cRightParenthesisKeyword_1_2; }

		//SignalPreExpr
		public RuleCall getSignalPreExprParserRuleCall_2() { return cSignalPreExprParserRuleCall_2; }

		//TrapReferenceExpr
		public RuleCall getTrapReferenceExprParserRuleCall_3() { return cTrapReferenceExprParserRuleCall_3; }
	}

	public class SignalReferenceExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.SignalReferenceExpr");
		private final Assignment cValuedObjectAssignment = (Assignment)rule.eContents().get(1);
		private final CrossReference cValuedObjectISignalCrossReference_0 = (CrossReference)cValuedObjectAssignment.eContents().get(0);
		private final RuleCall cValuedObjectISignalIDTerminalRuleCall_0_1 = (RuleCall)cValuedObjectISignalCrossReference_0.eContents().get(1);
		
		//SignalReferenceExpr kexpressions::ValuedObjectReference:
		//	valuedObject=[kexpressions::ISignal]
		@Override public ParserRule getRule() { return rule; }

		//valuedObject=[kexpressions::ISignal]
		public Assignment getValuedObjectAssignment() { return cValuedObjectAssignment; }

		//[kexpressions::ISignal]
		public CrossReference getValuedObjectISignalCrossReference_0() { return cValuedObjectISignalCrossReference_0; }

		//ID
		public RuleCall getValuedObjectISignalIDTerminalRuleCall_0_1() { return cValuedObjectISignalIDTerminalRuleCall_0_1; }
	}

	public class SignalPreExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.SignalPreExpr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cOperatorExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cOperatorAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cOperatorPreOperatorEnumRuleCall_1_0 = (RuleCall)cOperatorAssignment_1.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cSubExpressionsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cSubExpressionsSignalReferenceExprParserRuleCall_3_0 = (RuleCall)cSubExpressionsAssignment_3.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//SignalPreExpr kexpressions::Expression:
		//	{kexpressions::OperatorExpression} operator=PreOperator '(' subExpressions+=SignalReferenceExpr ')'
		@Override public ParserRule getRule() { return rule; }

		//{kexpressions::OperatorExpression} operator=PreOperator '(' subExpressions+=SignalReferenceExpr ')'
		public Group getGroup() { return cGroup; }

		//{kexpressions::OperatorExpression}
		public Action getOperatorExpressionAction_0() { return cOperatorExpressionAction_0; }

		//operator=PreOperator
		public Assignment getOperatorAssignment_1() { return cOperatorAssignment_1; }

		//PreOperator
		public RuleCall getOperatorPreOperatorEnumRuleCall_1_0() { return cOperatorPreOperatorEnumRuleCall_1_0; }

		//'('
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }

		//subExpressions+=SignalReferenceExpr
		public Assignment getSubExpressionsAssignment_3() { return cSubExpressionsAssignment_3; }

		//SignalReferenceExpr
		public RuleCall getSubExpressionsSignalReferenceExprParserRuleCall_3_0() { return cSubExpressionsSignalReferenceExprParserRuleCall_3_0; }

		//')'
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
	}

	public class TrapReferenceExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.TrapReferenceExpr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cTrapReferenceExprAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cValuedObjectAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cValuedObjectTrapDeclCrossReference_1_0 = (CrossReference)cValuedObjectAssignment_1.eContents().get(0);
		private final RuleCall cValuedObjectTrapDeclIDTerminalRuleCall_1_0_1 = (RuleCall)cValuedObjectTrapDeclCrossReference_1_0.eContents().get(1);
		
		//TrapReferenceExpr kexpressions::ValuedObjectReference:
		//	{TrapReferenceExpr} valuedObject=[TrapDecl]
		@Override public ParserRule getRule() { return rule; }

		//{TrapReferenceExpr} valuedObject=[TrapDecl]
		public Group getGroup() { return cGroup; }

		//{TrapReferenceExpr}
		public Action getTrapReferenceExprAction_0() { return cTrapReferenceExprAction_0; }

		//valuedObject=[TrapDecl]
		public Assignment getValuedObjectAssignment_1() { return cValuedObjectAssignment_1; }

		//[TrapDecl]
		public CrossReference getValuedObjectTrapDeclCrossReference_1_0() { return cValuedObjectTrapDeclCrossReference_1_0; }

		//ID
		public RuleCall getValuedObjectTrapDeclIDTerminalRuleCall_1_0_1() { return cValuedObjectTrapDeclIDTerminalRuleCall_1_0_1; }
	}

	public class DelayExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.DelayExpr");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Assignment cExprAssignment_0_0 = (Assignment)cGroup_0.eContents().get(0);
		private final RuleCall cExprExpressionParserRuleCall_0_0_0 = (RuleCall)cExprAssignment_0_0.eContents().get(0);
		private final Assignment cEventAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cEventDelayEventParserRuleCall_0_1_0 = (RuleCall)cEventAssignment_0_1.eContents().get(0);
		private final Assignment cEventAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cEventDelayEventParserRuleCall_1_0 = (RuleCall)cEventAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Assignment cIsImmediateAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final Keyword cIsImmediateImmediateKeyword_2_0_0 = (Keyword)cIsImmediateAssignment_2_0.eContents().get(0);
		private final Assignment cEventAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cEventDelayEventParserRuleCall_2_1_0 = (RuleCall)cEventAssignment_2_1.eContents().get(0);
		
		//// --> B.3.4 Delay Expressions <--
		//// -------------------------------------
		//DelayExpr:
		//	expr=Expression event=DelayEvent | event=DelayEvent | isImmediate?="immediate" event=DelayEvent;
		@Override public ParserRule getRule() { return rule; }

		//expr=Expression event=DelayEvent | event=DelayEvent | isImmediate?="immediate" event=DelayEvent
		public Alternatives getAlternatives() { return cAlternatives; }

		//expr=Expression event=DelayEvent
		public Group getGroup_0() { return cGroup_0; }

		//expr=Expression
		public Assignment getExprAssignment_0_0() { return cExprAssignment_0_0; }

		//Expression
		public RuleCall getExprExpressionParserRuleCall_0_0_0() { return cExprExpressionParserRuleCall_0_0_0; }

		//event=DelayEvent
		public Assignment getEventAssignment_0_1() { return cEventAssignment_0_1; }

		//DelayEvent
		public RuleCall getEventDelayEventParserRuleCall_0_1_0() { return cEventDelayEventParserRuleCall_0_1_0; }

		//event=DelayEvent
		public Assignment getEventAssignment_1() { return cEventAssignment_1; }

		//DelayEvent
		public RuleCall getEventDelayEventParserRuleCall_1_0() { return cEventDelayEventParserRuleCall_1_0; }

		//isImmediate?="immediate" event=DelayEvent
		public Group getGroup_2() { return cGroup_2; }

		//isImmediate?="immediate"
		public Assignment getIsImmediateAssignment_2_0() { return cIsImmediateAssignment_2_0; }

		//"immediate"
		public Keyword getIsImmediateImmediateKeyword_2_0_0() { return cIsImmediateImmediateKeyword_2_0_0; }

		//event=DelayEvent
		public Assignment getEventAssignment_2_1() { return cEventAssignment_2_1; }

		//DelayEvent
		public RuleCall getEventDelayEventParserRuleCall_2_1_0() { return cEventDelayEventParserRuleCall_2_1_0; }
	}

	public class DelayEventElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.DelayEvent");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cTickAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cTickTickParserRuleCall_0_0 = (RuleCall)cTickAssignment_0.eContents().get(0);
		private final Assignment cExprAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cExprSignalReferenceExprParserRuleCall_1_0 = (RuleCall)cExprAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Assignment cFBAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final Keyword cFBLeftSquareBracketKeyword_2_0_0 = (Keyword)cFBAssignment_2_0.eContents().get(0);
		private final Assignment cExprAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cExprSignalExpressionParserRuleCall_2_1_0 = (RuleCall)cExprAssignment_2_1.eContents().get(0);
		private final Assignment cEBAssignment_2_2 = (Assignment)cGroup_2.eContents().get(2);
		private final Keyword cEBRightSquareBracketKeyword_2_2_0 = (Keyword)cEBAssignment_2_2.eContents().get(0);
		
		//DelayEvent:
		//	tick=Tick | expr=SignalReferenceExpr | fB="[" expr=SignalExpression eB="]";
		@Override public ParserRule getRule() { return rule; }

		//tick=Tick | expr=SignalReferenceExpr | fB="[" expr=SignalExpression eB="]"
		public Alternatives getAlternatives() { return cAlternatives; }

		//tick=Tick
		public Assignment getTickAssignment_0() { return cTickAssignment_0; }

		//Tick
		public RuleCall getTickTickParserRuleCall_0_0() { return cTickTickParserRuleCall_0_0; }

		//expr=SignalReferenceExpr
		public Assignment getExprAssignment_1() { return cExprAssignment_1; }

		//SignalReferenceExpr
		public RuleCall getExprSignalReferenceExprParserRuleCall_1_0() { return cExprSignalReferenceExprParserRuleCall_1_0; }

		//fB="[" expr=SignalExpression eB="]"
		public Group getGroup_2() { return cGroup_2; }

		//fB="["
		public Assignment getFBAssignment_2_0() { return cFBAssignment_2_0; }

		//"["
		public Keyword getFBLeftSquareBracketKeyword_2_0_0() { return cFBLeftSquareBracketKeyword_2_0_0; }

		//expr=SignalExpression
		public Assignment getExprAssignment_2_1() { return cExprAssignment_2_1; }

		//SignalExpression
		public RuleCall getExprSignalExpressionParserRuleCall_2_1_0() { return cExprSignalExpressionParserRuleCall_2_1_0; }

		//eB="]"
		public Assignment getEBAssignment_2_2() { return cEBAssignment_2_2; }

		//"]"
		public Keyword getEBRightSquareBracketKeyword_2_2_0() { return cEBRightSquareBracketKeyword_2_2_0; }
	}

	public class ExecElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.Exec");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Group cGroup_0_0 = (Group)cAlternatives_0.eContents().get(0);
		private final Keyword cExecKeyword_0_0_0 = (Keyword)cGroup_0_0.eContents().get(0);
		private final Assignment cTaskAssignment_0_0_1 = (Assignment)cGroup_0_0.eContents().get(1);
		private final CrossReference cTaskTaskCrossReference_0_0_1_0 = (CrossReference)cTaskAssignment_0_0_1.eContents().get(0);
		private final RuleCall cTaskTaskIDTerminalRuleCall_0_0_1_0_1 = (RuleCall)cTaskTaskCrossReference_0_0_1_0.eContents().get(1);
		private final Assignment cBodyAssignment_0_0_2 = (Assignment)cGroup_0_0.eContents().get(2);
		private final RuleCall cBodyExecBodyParserRuleCall_0_0_2_0 = (RuleCall)cBodyAssignment_0_0_2.eContents().get(0);
		private final Keyword cReturnKeyword_0_0_3 = (Keyword)cGroup_0_0.eContents().get(3);
		private final Assignment cRetSignalAssignment_0_0_4 = (Assignment)cGroup_0_0.eContents().get(4);
		private final CrossReference cRetSignalISignalCrossReference_0_0_4_0 = (CrossReference)cRetSignalAssignment_0_0_4.eContents().get(0);
		private final RuleCall cRetSignalISignalIDTerminalRuleCall_0_0_4_0_1 = (RuleCall)cRetSignalISignalCrossReference_0_0_4_0.eContents().get(1);
		private final Group cGroup_0_0_5 = (Group)cGroup_0_0.eContents().get(5);
		private final Keyword cDoKeyword_0_0_5_0 = (Keyword)cGroup_0_0_5.eContents().get(0);
		private final Assignment cStatementAssignment_0_0_5_1 = (Assignment)cGroup_0_0_5.eContents().get(1);
		private final RuleCall cStatementStatementParserRuleCall_0_0_5_1_0 = (RuleCall)cStatementAssignment_0_0_5_1.eContents().get(0);
		private final Group cGroup_0_1 = (Group)cAlternatives_0.eContents().get(1);
		private final Keyword cExecKeyword_0_1_0 = (Keyword)cGroup_0_1.eContents().get(0);
		private final Assignment cExecCaseListAssignment_0_1_1 = (Assignment)cGroup_0_1.eContents().get(1);
		private final RuleCall cExecCaseListExecCaseParserRuleCall_0_1_1_0 = (RuleCall)cExecCaseListAssignment_0_1_1.eContents().get(0);
		private final Assignment cExecCaseListAssignment_0_1_2 = (Assignment)cGroup_0_1.eContents().get(2);
		private final RuleCall cExecCaseListExecCaseParserRuleCall_0_1_2_0 = (RuleCall)cExecCaseListAssignment_0_1_2.eContents().get(0);
		private final Keyword cEndKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cOptEndAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Keyword cOptEndExecKeyword_2_0 = (Keyword)cOptEndAssignment_2.eContents().get(0);
		
		//// --> Exec
		//// -------------------------------------
		//Exec:
		//	("exec" task=[Task] body=ExecBody "return" retSignal=[kexpressions::ISignal] ("do" statement=Statement)? | "exec"
		//	execCaseList+=ExecCase execCaseList+=ExecCase*) "end" optEnd="exec"?;
		@Override public ParserRule getRule() { return rule; }

		//("exec" task=[Task] body=ExecBody "return" retSignal=[kexpressions::ISignal] ("do" statement=Statement)? | "exec"
		//execCaseList+=ExecCase execCaseList+=ExecCase*) "end" optEnd="exec"?
		public Group getGroup() { return cGroup; }

		//("exec" task=[Task] body=ExecBody "return" retSignal=[kexpressions::ISignal] ("do" statement=Statement)? | "exec"
		//execCaseList+=ExecCase execCaseList+=ExecCase*)
		public Alternatives getAlternatives_0() { return cAlternatives_0; }

		//"exec" task=[Task] body=ExecBody "return" retSignal=[kexpressions::ISignal] ("do" statement=Statement)?
		public Group getGroup_0_0() { return cGroup_0_0; }

		//"exec"
		public Keyword getExecKeyword_0_0_0() { return cExecKeyword_0_0_0; }

		//task=[Task]
		public Assignment getTaskAssignment_0_0_1() { return cTaskAssignment_0_0_1; }

		//[Task]
		public CrossReference getTaskTaskCrossReference_0_0_1_0() { return cTaskTaskCrossReference_0_0_1_0; }

		//ID
		public RuleCall getTaskTaskIDTerminalRuleCall_0_0_1_0_1() { return cTaskTaskIDTerminalRuleCall_0_0_1_0_1; }

		//body=ExecBody
		public Assignment getBodyAssignment_0_0_2() { return cBodyAssignment_0_0_2; }

		//ExecBody
		public RuleCall getBodyExecBodyParserRuleCall_0_0_2_0() { return cBodyExecBodyParserRuleCall_0_0_2_0; }

		//"return"
		public Keyword getReturnKeyword_0_0_3() { return cReturnKeyword_0_0_3; }

		//retSignal=[kexpressions::ISignal]
		public Assignment getRetSignalAssignment_0_0_4() { return cRetSignalAssignment_0_0_4; }

		//[kexpressions::ISignal]
		public CrossReference getRetSignalISignalCrossReference_0_0_4_0() { return cRetSignalISignalCrossReference_0_0_4_0; }

		//ID
		public RuleCall getRetSignalISignalIDTerminalRuleCall_0_0_4_0_1() { return cRetSignalISignalIDTerminalRuleCall_0_0_4_0_1; }

		//("do" statement=Statement)?
		public Group getGroup_0_0_5() { return cGroup_0_0_5; }

		//"do"
		public Keyword getDoKeyword_0_0_5_0() { return cDoKeyword_0_0_5_0; }

		//statement=Statement
		public Assignment getStatementAssignment_0_0_5_1() { return cStatementAssignment_0_0_5_1; }

		//Statement
		public RuleCall getStatementStatementParserRuleCall_0_0_5_1_0() { return cStatementStatementParserRuleCall_0_0_5_1_0; }

		//"exec" execCaseList+=ExecCase execCaseList+=ExecCase*
		public Group getGroup_0_1() { return cGroup_0_1; }

		//"exec"
		public Keyword getExecKeyword_0_1_0() { return cExecKeyword_0_1_0; }

		//execCaseList+=ExecCase
		public Assignment getExecCaseListAssignment_0_1_1() { return cExecCaseListAssignment_0_1_1; }

		//ExecCase
		public RuleCall getExecCaseListExecCaseParserRuleCall_0_1_1_0() { return cExecCaseListExecCaseParserRuleCall_0_1_1_0; }

		//execCaseList+=ExecCase*
		public Assignment getExecCaseListAssignment_0_1_2() { return cExecCaseListAssignment_0_1_2; }

		//ExecCase
		public RuleCall getExecCaseListExecCaseParserRuleCall_0_1_2_0() { return cExecCaseListExecCaseParserRuleCall_0_1_2_0; }

		//"end"
		public Keyword getEndKeyword_1() { return cEndKeyword_1; }

		//optEnd="exec"?
		public Assignment getOptEndAssignment_2() { return cOptEndAssignment_2; }

		//"exec"
		public Keyword getOptEndExecKeyword_2_0() { return cOptEndExecKeyword_2_0; }
	}

	public class ExecBodyElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.ExecBody");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cExecBodyAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cVarsAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final CrossReference cVarsIVariableCrossReference_2_0_0 = (CrossReference)cVarsAssignment_2_0.eContents().get(0);
		private final RuleCall cVarsIVariableIDTerminalRuleCall_2_0_0_1 = (RuleCall)cVarsIVariableCrossReference_2_0_0.eContents().get(1);
		private final Group cGroup_2_1 = (Group)cGroup_2.eContents().get(1);
		private final Keyword cCommaKeyword_2_1_0 = (Keyword)cGroup_2_1.eContents().get(0);
		private final Assignment cVarsAssignment_2_1_1 = (Assignment)cGroup_2_1.eContents().get(1);
		private final CrossReference cVarsIVariableCrossReference_2_1_1_0 = (CrossReference)cVarsAssignment_2_1_1.eContents().get(0);
		private final RuleCall cVarsIVariableIDTerminalRuleCall_2_1_1_0_1 = (RuleCall)cVarsIVariableCrossReference_2_1_1_0.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Keyword cLeftParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
		private final Assignment cKexpressionsAssignment_5_0 = (Assignment)cGroup_5.eContents().get(0);
		private final RuleCall cKexpressionsExpressionParserRuleCall_5_0_0 = (RuleCall)cKexpressionsAssignment_5_0.eContents().get(0);
		private final Group cGroup_5_1 = (Group)cGroup_5.eContents().get(1);
		private final Keyword cCommaKeyword_5_1_0 = (Keyword)cGroup_5_1.eContents().get(0);
		private final Assignment cKexpressionsAssignment_5_1_1 = (Assignment)cGroup_5_1.eContents().get(1);
		private final RuleCall cKexpressionsExpressionParserRuleCall_5_1_1_0 = (RuleCall)cKexpressionsAssignment_5_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		//ExecBody:
		//	{ExecBody} "(" (vars+=[kexpressions::IVariable] ("," vars+=[kexpressions::IVariable])*)? ")" "("
		//	(kexpressions+=Expression ("," kexpressions+=Expression)*)? ")";
		@Override public ParserRule getRule() { return rule; }

		//{ExecBody} "(" (vars+=[kexpressions::IVariable] ("," vars+=[kexpressions::IVariable])*)? ")" "("
		//(kexpressions+=Expression ("," kexpressions+=Expression)*)? ")"
		public Group getGroup() { return cGroup; }

		//{ExecBody}
		public Action getExecBodyAction_0() { return cExecBodyAction_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//(vars+=[kexpressions::IVariable] ("," vars+=[kexpressions::IVariable])*)?
		public Group getGroup_2() { return cGroup_2; }

		//vars+=[kexpressions::IVariable]
		public Assignment getVarsAssignment_2_0() { return cVarsAssignment_2_0; }

		//[kexpressions::IVariable]
		public CrossReference getVarsIVariableCrossReference_2_0_0() { return cVarsIVariableCrossReference_2_0_0; }

		//ID
		public RuleCall getVarsIVariableIDTerminalRuleCall_2_0_0_1() { return cVarsIVariableIDTerminalRuleCall_2_0_0_1; }

		//("," vars+=[kexpressions::IVariable])*
		public Group getGroup_2_1() { return cGroup_2_1; }

		//","
		public Keyword getCommaKeyword_2_1_0() { return cCommaKeyword_2_1_0; }

		//vars+=[kexpressions::IVariable]
		public Assignment getVarsAssignment_2_1_1() { return cVarsAssignment_2_1_1; }

		//[kexpressions::IVariable]
		public CrossReference getVarsIVariableCrossReference_2_1_1_0() { return cVarsIVariableCrossReference_2_1_1_0; }

		//ID
		public RuleCall getVarsIVariableIDTerminalRuleCall_2_1_1_0_1() { return cVarsIVariableIDTerminalRuleCall_2_1_1_0_1; }

		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }

		//"("
		public Keyword getLeftParenthesisKeyword_4() { return cLeftParenthesisKeyword_4; }

		//(kexpressions+=Expression ("," kexpressions+=Expression)*)?
		public Group getGroup_5() { return cGroup_5; }

		//kexpressions+=Expression
		public Assignment getKexpressionsAssignment_5_0() { return cKexpressionsAssignment_5_0; }

		//Expression
		public RuleCall getKexpressionsExpressionParserRuleCall_5_0_0() { return cKexpressionsExpressionParserRuleCall_5_0_0; }

		//("," kexpressions+=Expression)*
		public Group getGroup_5_1() { return cGroup_5_1; }

		//","
		public Keyword getCommaKeyword_5_1_0() { return cCommaKeyword_5_1_0; }

		//kexpressions+=Expression
		public Assignment getKexpressionsAssignment_5_1_1() { return cKexpressionsAssignment_5_1_1; }

		//Expression
		public RuleCall getKexpressionsExpressionParserRuleCall_5_1_1_0() { return cKexpressionsExpressionParserRuleCall_5_1_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_6() { return cRightParenthesisKeyword_6; }
	}

	public class ExecCaseElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.ExecCase");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cCaseKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cTaskAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cTaskTaskCrossReference_1_0 = (CrossReference)cTaskAssignment_1.eContents().get(0);
		private final RuleCall cTaskTaskIDTerminalRuleCall_1_0_1 = (RuleCall)cTaskTaskCrossReference_1_0.eContents().get(1);
		private final Assignment cBodyAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cBodyExecBodyParserRuleCall_2_0 = (RuleCall)cBodyAssignment_2.eContents().get(0);
		private final Keyword cReturnKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cRetSignalAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final CrossReference cRetSignalISignalCrossReference_4_0 = (CrossReference)cRetSignalAssignment_4.eContents().get(0);
		private final RuleCall cRetSignalISignalIDTerminalRuleCall_4_0_1 = (RuleCall)cRetSignalISignalCrossReference_4_0.eContents().get(1);
		private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
		private final Keyword cDoKeyword_5_0 = (Keyword)cGroup_5.eContents().get(0);
		private final Assignment cStatementAssignment_5_1 = (Assignment)cGroup_5.eContents().get(1);
		private final RuleCall cStatementStatementParserRuleCall_5_1_0 = (RuleCall)cStatementAssignment_5_1.eContents().get(0);
		
		//ExecCase:
		//	"case" task=[Task] body=ExecBody "return" retSignal=[kexpressions::ISignal] ("do" statement=Statement)?;
		@Override public ParserRule getRule() { return rule; }

		//"case" task=[Task] body=ExecBody "return" retSignal=[kexpressions::ISignal] ("do" statement=Statement)?
		public Group getGroup() { return cGroup; }

		//"case"
		public Keyword getCaseKeyword_0() { return cCaseKeyword_0; }

		//task=[Task]
		public Assignment getTaskAssignment_1() { return cTaskAssignment_1; }

		//[Task]
		public CrossReference getTaskTaskCrossReference_1_0() { return cTaskTaskCrossReference_1_0; }

		//ID
		public RuleCall getTaskTaskIDTerminalRuleCall_1_0_1() { return cTaskTaskIDTerminalRuleCall_1_0_1; }

		//body=ExecBody
		public Assignment getBodyAssignment_2() { return cBodyAssignment_2; }

		//ExecBody
		public RuleCall getBodyExecBodyParserRuleCall_2_0() { return cBodyExecBodyParserRuleCall_2_0; }

		//"return"
		public Keyword getReturnKeyword_3() { return cReturnKeyword_3; }

		//retSignal=[kexpressions::ISignal]
		public Assignment getRetSignalAssignment_4() { return cRetSignalAssignment_4; }

		//[kexpressions::ISignal]
		public CrossReference getRetSignalISignalCrossReference_4_0() { return cRetSignalISignalCrossReference_4_0; }

		//ID
		public RuleCall getRetSignalISignalIDTerminalRuleCall_4_0_1() { return cRetSignalISignalIDTerminalRuleCall_4_0_1; }

		//("do" statement=Statement)?
		public Group getGroup_5() { return cGroup_5; }

		//"do"
		public Keyword getDoKeyword_5_0() { return cDoKeyword_5_0; }

		//statement=Statement
		public Assignment getStatementAssignment_5_1() { return cStatementAssignment_5_1; }

		//Statement
		public RuleCall getStatementStatementParserRuleCall_5_1_0() { return cStatementStatementParserRuleCall_5_1_0; }
	}

	public class TickElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.Tick");
		private final Keyword cTickKeyword = (Keyword)rule.eContents().get(1);
		
		//// ==============================================
		//// === B.2 Namespaces and Predefined Objects  ===
		//// ==============================================
		//Tick:
		//	"tick";
		@Override public ParserRule getRule() { return rule; }

		//"tick"
		public Keyword getTickKeyword() { return cTickKeyword; }
	}
	
	
	private final ProgramElements pProgram;
	private final ModuleElements pModule;
	private final EndModuleElements pEndModule;
	private final ModuleBodyElements pModuleBody;
	private final ModuleInterfaceElements pModuleInterface;
	private final ChannelDescriptionElements pChannelDescription;
	private final EsterelTypeIdentifierElements pEsterelTypeIdentifier;
	private final TypeIdentifierElements pTypeIdentifier;
	private final LocalSignalDeclElements pLocalSignalDecl;
	private final LocalSignalListElements pLocalSignalList;
	private final SensorDeclElements pSensorDecl;
	private final SensorWithTypeElements pSensorWithType;
	private final SensorElements pSensor;
	private final RelationDeclElements pRelationDecl;
	private final RelationTypeElements pRelationType;
	private final RelationImplicationElements pRelationImplication;
	private final RelationIncompatibilityElements pRelationIncompatibility;
	private final TypeDeclElements pTypeDecl;
	private final TypeElements pType;
	private final ConstantDeclsElements pConstantDecls;
	private final OneTypeConstantDeclsElements pOneTypeConstantDecls;
	private final ConstantWithValueElements pConstantWithValue;
	private final ConstantElements pConstant;
	private final ConstantAtomElements pConstantAtom;
	private final ConstantLiteralElements pConstantLiteral;
	private final FunctionDeclElements pFunctionDecl;
	private final FunctionElements pFunction;
	private final ProcedureDeclElements pProcedureDecl;
	private final ProcedureElements pProcedure;
	private final TaskDeclElements pTaskDecl;
	private final TaskElements pTask;
	private final StatementContainerElements pStatementContainer;
	private final StatementContainerInterfaceElements pStatementContainerInterface;
	private final StatementElements pStatement;
	private final AtomicStatementElements pAtomicStatement;
	private final SequenceElements pSequence;
	private final BlockElements pBlock;
	private final AssignmentElements pAssignment;
	private final AbortElements pAbort;
	private final AbortBodyElements pAbortBody;
	private final AbortInstanceElements pAbortInstance;
	private final AbortCaseElements pAbortCase;
	private final AbortCaseSingleElements pAbortCaseSingle;
	private final WeakAbortElements pWeakAbort;
	private final WeakAbortBodyElements pWeakAbortBody;
	private final WeakAbortEndElements pWeakAbortEnd;
	private final WeakAbortEndAltElements pWeakAbortEndAlt;
	private final WeakAbortInstanceElements pWeakAbortInstance;
	private final WeakAbortCaseElements pWeakAbortCase;
	private final AwaitElements pAwait;
	private final AwaitBodyElements pAwaitBody;
	private final AwaitInstanceElements pAwaitInstance;
	private final AwaitCaseElements pAwaitCase;
	private final AwaitEndElements pAwaitEnd;
	private final ProcCallElements pProcCall;
	private final DoElements pDo;
	private final DoUptoElements pDoUpto;
	private final DoWatchingElements pDoWatching;
	private final DoWatchingEndElements pDoWatchingEnd;
	private final EmitElements pEmit;
	private final UnEmitElements pUnEmit;
	private final ResetElements pReset;
	private final EveryDoElements pEveryDo;
	private final ExitElements pExit;
	private final HaltElements pHalt;
	private final IfTestElements pIfTest;
	private final ElsIfElements pElsIf;
	private final ThenPartElements pThenPart;
	private final ElsePartElements pElsePart;
	private final LoopElements pLoop;
	private final EndLoopElements pEndLoop;
	private final LoopEachElements pLoopEach;
	private final LoopDelayElements pLoopDelay;
	private final LoopBodyElements pLoopBody;
	private final NothingElements pNothing;
	private final PauseElements pPause;
	private final PresentElements pPresent;
	private final PresentBodyElements pPresentBody;
	private final PresentEventBodyElements pPresentEventBody;
	private final PresentCaseListElements pPresentCaseList;
	private final PresentCaseElements pPresentCase;
	private final PresentEventElements pPresentEvent;
	private final RepeatElements pRepeat;
	private final RunElements pRun;
	private final ModuleRenamingElements pModuleRenaming;
	private final RenamingListElements pRenamingList;
	private final RenamingElements pRenaming;
	private final TypeRenamingElements pTypeRenaming;
	private final ConstantRenamingElements pConstantRenaming;
	private final FunctionRenamingElements pFunctionRenaming;
	private final ProcedureRenamingElements pProcedureRenaming;
	private final TaskRenamingElements pTaskRenaming;
	private final SignalRenamingElements pSignalRenaming;
	private final BuildInFunctionElements pBuildInFunction;
	private final SuspendElements pSuspend;
	private final WeakSuspendElements pWeakSuspend;
	private final SustainElements pSustain;
	private final TrapElements pTrap;
	private final TrapDeclListElements pTrapDeclList;
	private final TrapDeclElements pTrapDecl;
	private final TrapHandlerElements pTrapHandler;
	private final LocalVariableElements pLocalVariable;
	private final GotoElements pGoto;
	private final LabelElements pLabel;
	private final AtomicExpressionElements pAtomicExpression;
	private final TrapExpressionElements pTrapExpression;
	private final FunctionExpressionElements pFunctionExpression;
	private final ConstantExpressionElements pConstantExpression;
	private final TrapExprElements pTrapExpr;
	private final SignalExpressionElements pSignalExpression;
	private final SignalAndExpressionElements pSignalAndExpression;
	private final SignalNotExpressionElements pSignalNotExpression;
	private final SignalAtomicExpressionElements pSignalAtomicExpression;
	private final SignalReferenceExprElements pSignalReferenceExpr;
	private final SignalPreExprElements pSignalPreExpr;
	private final TrapReferenceExprElements pTrapReferenceExpr;
	private final DelayExprElements pDelayExpr;
	private final DelayEventElements pDelayEvent;
	private final ExecElements pExec;
	private final ExecBodyElements pExecBody;
	private final ExecCaseElements pExecCase;
	private final TickElements pTick;
	private final TerminalRule tESTEREL_SL_COMMENT;
	private final TerminalRule tESTEREL_ML_COMMENT;
	private final TerminalRule tSTRING;
	
	private final Grammar grammar;

	private final KExpressionsGrammarAccess gaKExpressions;

	private final AnnotationsGrammarAccess gaAnnotations;

	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public EsterelGrammarAccess(GrammarProvider grammarProvider,
		KExpressionsGrammarAccess gaKExpressions,
		AnnotationsGrammarAccess gaAnnotations,
		TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaKExpressions = gaKExpressions;
		this.gaAnnotations = gaAnnotations;
		this.gaTerminals = gaTerminals;
		this.pProgram = new ProgramElements();
		this.pModule = new ModuleElements();
		this.pEndModule = new EndModuleElements();
		this.pModuleBody = new ModuleBodyElements();
		this.pModuleInterface = new ModuleInterfaceElements();
		this.pChannelDescription = new ChannelDescriptionElements();
		this.pEsterelTypeIdentifier = new EsterelTypeIdentifierElements();
		this.pTypeIdentifier = new TypeIdentifierElements();
		this.pLocalSignalDecl = new LocalSignalDeclElements();
		this.pLocalSignalList = new LocalSignalListElements();
		this.pSensorDecl = new SensorDeclElements();
		this.pSensorWithType = new SensorWithTypeElements();
		this.pSensor = new SensorElements();
		this.pRelationDecl = new RelationDeclElements();
		this.pRelationType = new RelationTypeElements();
		this.pRelationImplication = new RelationImplicationElements();
		this.pRelationIncompatibility = new RelationIncompatibilityElements();
		this.pTypeDecl = new TypeDeclElements();
		this.pType = new TypeElements();
		this.pConstantDecls = new ConstantDeclsElements();
		this.pOneTypeConstantDecls = new OneTypeConstantDeclsElements();
		this.pConstantWithValue = new ConstantWithValueElements();
		this.pConstant = new ConstantElements();
		this.pConstantAtom = new ConstantAtomElements();
		this.pConstantLiteral = new ConstantLiteralElements();
		this.pFunctionDecl = new FunctionDeclElements();
		this.pFunction = new FunctionElements();
		this.pProcedureDecl = new ProcedureDeclElements();
		this.pProcedure = new ProcedureElements();
		this.pTaskDecl = new TaskDeclElements();
		this.pTask = new TaskElements();
		this.pStatementContainer = new StatementContainerElements();
		this.pStatementContainerInterface = new StatementContainerInterfaceElements();
		this.pStatement = new StatementElements();
		this.pAtomicStatement = new AtomicStatementElements();
		this.pSequence = new SequenceElements();
		this.pBlock = new BlockElements();
		this.pAssignment = new AssignmentElements();
		this.pAbort = new AbortElements();
		this.pAbortBody = new AbortBodyElements();
		this.pAbortInstance = new AbortInstanceElements();
		this.pAbortCase = new AbortCaseElements();
		this.pAbortCaseSingle = new AbortCaseSingleElements();
		this.pWeakAbort = new WeakAbortElements();
		this.pWeakAbortBody = new WeakAbortBodyElements();
		this.pWeakAbortEnd = new WeakAbortEndElements();
		this.pWeakAbortEndAlt = new WeakAbortEndAltElements();
		this.pWeakAbortInstance = new WeakAbortInstanceElements();
		this.pWeakAbortCase = new WeakAbortCaseElements();
		this.pAwait = new AwaitElements();
		this.pAwaitBody = new AwaitBodyElements();
		this.pAwaitInstance = new AwaitInstanceElements();
		this.pAwaitCase = new AwaitCaseElements();
		this.pAwaitEnd = new AwaitEndElements();
		this.pProcCall = new ProcCallElements();
		this.pDo = new DoElements();
		this.pDoUpto = new DoUptoElements();
		this.pDoWatching = new DoWatchingElements();
		this.pDoWatchingEnd = new DoWatchingEndElements();
		this.pEmit = new EmitElements();
		this.pUnEmit = new UnEmitElements();
		this.pReset = new ResetElements();
		this.pEveryDo = new EveryDoElements();
		this.pExit = new ExitElements();
		this.pHalt = new HaltElements();
		this.pIfTest = new IfTestElements();
		this.pElsIf = new ElsIfElements();
		this.pThenPart = new ThenPartElements();
		this.pElsePart = new ElsePartElements();
		this.pLoop = new LoopElements();
		this.pEndLoop = new EndLoopElements();
		this.pLoopEach = new LoopEachElements();
		this.pLoopDelay = new LoopDelayElements();
		this.pLoopBody = new LoopBodyElements();
		this.pNothing = new NothingElements();
		this.pPause = new PauseElements();
		this.pPresent = new PresentElements();
		this.pPresentBody = new PresentBodyElements();
		this.pPresentEventBody = new PresentEventBodyElements();
		this.pPresentCaseList = new PresentCaseListElements();
		this.pPresentCase = new PresentCaseElements();
		this.pPresentEvent = new PresentEventElements();
		this.pRepeat = new RepeatElements();
		this.pRun = new RunElements();
		this.pModuleRenaming = new ModuleRenamingElements();
		this.pRenamingList = new RenamingListElements();
		this.pRenaming = new RenamingElements();
		this.pTypeRenaming = new TypeRenamingElements();
		this.pConstantRenaming = new ConstantRenamingElements();
		this.pFunctionRenaming = new FunctionRenamingElements();
		this.pProcedureRenaming = new ProcedureRenamingElements();
		this.pTaskRenaming = new TaskRenamingElements();
		this.pSignalRenaming = new SignalRenamingElements();
		this.pBuildInFunction = new BuildInFunctionElements();
		this.pSuspend = new SuspendElements();
		this.pWeakSuspend = new WeakSuspendElements();
		this.pSustain = new SustainElements();
		this.pTrap = new TrapElements();
		this.pTrapDeclList = new TrapDeclListElements();
		this.pTrapDecl = new TrapDeclElements();
		this.pTrapHandler = new TrapHandlerElements();
		this.pLocalVariable = new LocalVariableElements();
		this.pGoto = new GotoElements();
		this.pLabel = new LabelElements();
		this.pAtomicExpression = new AtomicExpressionElements();
		this.pTrapExpression = new TrapExpressionElements();
		this.pFunctionExpression = new FunctionExpressionElements();
		this.pConstantExpression = new ConstantExpressionElements();
		this.pTrapExpr = new TrapExprElements();
		this.pSignalExpression = new SignalExpressionElements();
		this.pSignalAndExpression = new SignalAndExpressionElements();
		this.pSignalNotExpression = new SignalNotExpressionElements();
		this.pSignalAtomicExpression = new SignalAtomicExpressionElements();
		this.pSignalReferenceExpr = new SignalReferenceExprElements();
		this.pSignalPreExpr = new SignalPreExprElements();
		this.pTrapReferenceExpr = new TrapReferenceExprElements();
		this.pDelayExpr = new DelayExprElements();
		this.pDelayEvent = new DelayEventElements();
		this.pExec = new ExecElements();
		this.pExecBody = new ExecBodyElements();
		this.pExecCase = new ExecCaseElements();
		this.pTick = new TickElements();
		this.tESTEREL_SL_COMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.ESTEREL_SL_COMMENT");
		this.tESTEREL_ML_COMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.ESTEREL_ML_COMMENT");
		this.tSTRING = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.esterel.Esterel.STRING");
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("de.cau.cs.kieler.esterel.Esterel".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	

	public KExpressionsGrammarAccess getKExpressionsGrammarAccess() {
		return gaKExpressions;
	}

	public AnnotationsGrammarAccess getAnnotationsGrammarAccess() {
		return gaAnnotations;
	}

	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	////	root rule. an esterel file can contain multiple modules
	//Program hidden(ESTEREL_SL_COMMENT, ESTEREL_ML_COMMENT, WS):
	//	modules+=Module*;
	public ProgramElements getProgramAccess() {
		return pProgram;
	}
	
	public ParserRule getProgramRule() {
		return getProgramAccess().getRule();
	}

	//// a module consists of an interface and a body
	//// !-(module)
	//Module:
	//	"module" name=ID ":" interface=ModuleInterface? body=ModuleBody end=EndModule;
	public ModuleElements getModuleAccess() {
		return pModule;
	}
	
	public ParserRule getModuleRule() {
		return getModuleAccess().getRule();
	}

	//EndModule:
	//	"end" "module"
	//	| ".";
	public EndModuleElements getEndModuleAccess() {
		return pEndModule;
	}
	
	public ParserRule getEndModuleRule() {
		return getEndModuleAccess().getRule();
	}

	////deprecated
	//ModuleBody:
	//	statements+=Statement;
	public ModuleBodyElements getModuleBodyAccess() {
		return pModuleBody;
	}
	
	public ParserRule getModuleBodyRule() {
		return getModuleBodyAccess().getRule();
	}

	//// -!
	////            Interface Declarations
	//// ----------------------------------------------
	//ModuleInterface:
	//	(intSignalDecls+=InterfaceSignalDecl
	//	| intTypeDecls+=TypeDecl
	//	| intSensorDecls+=SensorDecl
	//	| intConstantDecls+=ConstantDecls
	//	| intRelationDecls+=RelationDecl
	//	| intTaskDecls+=TaskDecl
	//	| intFunctionDecls+=FunctionDecl
	//	| intProcedureDecls+=ProcedureDecl)+;
	public ModuleInterfaceElements getModuleInterfaceAccess() {
		return pModuleInterface;
	}
	
	public ParserRule getModuleInterfaceRule() {
		return getModuleInterfaceAccess().getRule();
	}

	//// overwrite to add the EsterelTypeIdentifier
	//ChannelDescription:
	//	":" type=EsterelTypeIdentifier | "(" type=EsterelTypeIdentifier ")" | ":=" expression=Expression ":"
	//	type=EsterelTypeIdentifier;
	public ChannelDescriptionElements getChannelDescriptionAccess() {
		return pChannelDescription;
	}
	
	public ParserRule getChannelDescriptionRule() {
		return getChannelDescriptionAccess().getRule();
	}

	//// overwrite to allow function references for signal declarations
	//EsterelTypeIdentifier kexpressions::TypeIdentifier:
	//	type=ValueType
	//	| typeID=ID
	//	| {EsterelTypeIdentifier} ("combine" (type=ValueType | typeID=ID) "with" (func=[Function] |
	//	operator=CombineOperator))
	public EsterelTypeIdentifierElements getEsterelTypeIdentifierAccess() {
		return pEsterelTypeIdentifier;
	}
	
	public ParserRule getEsterelTypeIdentifierRule() {
		return getEsterelTypeIdentifierAccess().getRule();
	}

	//// overwrite to allow type definitions in a specific module
	//TypeIdentifier:
	//	type=ValueType
	//	| typeID=ID
	//	| "combine" (type=ValueType | typeID=ID) "with" operator=CombineOperator | {EsterelType} estType=[Type];
	public TypeIdentifierElements getTypeIdentifierAccess() {
		return pTypeIdentifier;
	}
	
	public ParserRule getTypeIdentifierRule() {
		return getTypeIdentifierAccess().getRule();
	}

	//// ==> Local Signal Declaration
	//// !-(localsignal) -------------------------------------
	//LocalSignalDecl:
	//	"signal" signalList=LocalSignalList "in" statement=Statement "end" optEnd="signal"?;
	public LocalSignalDeclElements getLocalSignalDeclAccess() {
		return pLocalSignalDecl;
	}
	
	public ParserRule getLocalSignalDeclRule() {
		return getLocalSignalDeclAccess().getRule();
	}

	//LocalSignalList:
	//	{LocalSignal} signal+=ISignal ("," signal+=ISignal)*;
	public LocalSignalListElements getLocalSignalListAccess() {
		return pLocalSignalList;
	}
	
	public ParserRule getLocalSignalListRule() {
		return getLocalSignalListAccess().getRule();
	}

	//// -!
	//// ==> Sensor
	//// -------------------------------------
	//SensorDecl:
	//	"sensor" sensors+=SensorWithType ("," sensors+=SensorWithType)* ";";
	public SensorDeclElements getSensorDeclAccess() {
		return pSensorDecl;
	}
	
	public ParserRule getSensorDeclRule() {
		return getSensorDeclAccess().getRule();
	}

	//SensorWithType:
	//	sensor=Sensor (":" type=TypeIdentifier) | sensor=Sensor "(" type=TypeIdentifier ")";
	public SensorWithTypeElements getSensorWithTypeAccess() {
		return pSensorWithType;
	}
	
	public ParserRule getSensorWithTypeRule() {
		return getSensorWithTypeAccess().getRule();
	}

	//Sensor kexpressions::ISignal:
	//	name=ID
	public SensorElements getSensorAccess() {
		return pSensor;
	}
	
	public ParserRule getSensorRule() {
		return getSensorAccess().getRule();
	}

	//// ==> Relations
	//// -------------------------------------
	//RelationDecl:
	//	{Relation} "relation" relations+=RelationType ("," relations+=RelationType)* ";";
	public RelationDeclElements getRelationDeclAccess() {
		return pRelationDecl;
	}
	
	public ParserRule getRelationDeclRule() {
		return getRelationDeclAccess().getRule();
	}

	//RelationType:
	//	RelationImplication | RelationIncompatibility;
	public RelationTypeElements getRelationTypeAccess() {
		return pRelationType;
	}
	
	public ParserRule getRelationTypeRule() {
		return getRelationTypeAccess().getRule();
	}

	//RelationImplication:
	//	first=[kexpressions::ISignal] type="=>" second=[kexpressions::ISignal];
	public RelationImplicationElements getRelationImplicationAccess() {
		return pRelationImplication;
	}
	
	public ParserRule getRelationImplicationRule() {
		return getRelationImplicationAccess().getRule();
	}

	//RelationIncompatibility:
	//	incomp+=[kexpressions::ISignal] type="#" incomp+=[kexpressions::ISignal] ("#"
	//	incomp+=[kexpressions::ISignal])*;
	public RelationIncompatibilityElements getRelationIncompatibilityAccess() {
		return pRelationIncompatibility;
	}
	
	public ParserRule getRelationIncompatibilityRule() {
		return getRelationIncompatibilityAccess().getRule();
	}

	//// ==> Types
	//// -------------------------------------
	//TypeDecl:
	//	"type" types+=Type ("," types+=Type)* ";";
	public TypeDeclElements getTypeDeclAccess() {
		return pTypeDecl;
	}
	
	public ParserRule getTypeDeclRule() {
		return getTypeDeclAccess().getRule();
	}

	//Type:
	//	name=ID;
	public TypeElements getTypeAccess() {
		return pType;
	}
	
	public ParserRule getTypeRule() {
		return getTypeAccess().getRule();
	}

	//// ==> Constants
	//// -------------------------------------
	//ConstantDecls:
	//	"constant" constants+=OneTypeConstantDecls ("," constants+=OneTypeConstantDecls)* ";";
	public ConstantDeclsElements getConstantDeclsAccess() {
		return pConstantDecls;
	}
	
	public ParserRule getConstantDeclsRule() {
		return getConstantDeclsAccess().getRule();
	}

	//OneTypeConstantDecls:
	//	constants+=ConstantWithValue ("," constants+=ConstantWithValue)* ":" type=TypeIdentifier;
	public OneTypeConstantDeclsElements getOneTypeConstantDeclsAccess() {
		return pOneTypeConstantDecls;
	}
	
	public ParserRule getOneTypeConstantDeclsRule() {
		return getOneTypeConstantDeclsAccess().getRule();
	}

	//ConstantWithValue:
	//	constant=Constant ("=" value=ConstantAtom)?;
	public ConstantWithValueElements getConstantWithValueAccess() {
		return pConstantWithValue;
	}
	
	public ParserRule getConstantWithValueRule() {
		return getConstantWithValueAccess().getRule();
	}

	//Constant kexpressions::ValuedObject:
	//	{Constant} name=ID
	public ConstantElements getConstantAccess() {
		return pConstant;
	}
	
	public ParserRule getConstantRule() {
		return getConstantAccess().getRule();
	}

	//ConstantAtom:
	//	INT | ConstantLiteral;
	public ConstantAtomElements getConstantAtomAccess() {
		return pConstantAtom;
	}
	
	public ParserRule getConstantAtomRule() {
		return getConstantAtomAccess().getRule();
	}

	//ConstantLiteral:
	//	FLOAT | BOOLEAN | ID | STRING;
	public ConstantLiteralElements getConstantLiteralAccess() {
		return pConstantLiteral;
	}
	
	public ParserRule getConstantLiteralRule() {
		return getConstantLiteralAccess().getRule();
	}

	//// ==> Functions
	//// -------------------------------------
	//FunctionDecl:
	//	"function" functions+=Function ("," functions+=Function)* ";";
	public FunctionDeclElements getFunctionDeclAccess() {
		return pFunctionDecl;
	}
	
	public ParserRule getFunctionDeclRule() {
		return getFunctionDeclAccess().getRule();
	}

	//Function:
	//	name=ID "(" (idList+=TypeIdentifier ("," idList+=TypeIdentifier)*)? ")" ":" type=TypeIdentifier;
	public FunctionElements getFunctionAccess() {
		return pFunction;
	}
	
	public ParserRule getFunctionRule() {
		return getFunctionAccess().getRule();
	}

	//// ==> Procedures
	//ProcedureDecl:
	//	"procedure" procedures+=Procedure ("," procedures+=Procedure)* ";";
	public ProcedureDeclElements getProcedureDeclAccess() {
		return pProcedureDecl;
	}
	
	public ParserRule getProcedureDeclRule() {
		return getProcedureDeclAccess().getRule();
	}

	//Procedure:
	//	name=ID "(" (idList1+=TypeIdentifier ("," idList1+=TypeIdentifier)*)? ")" "(" (idList2+=TypeIdentifier (","
	//	idList2+=TypeIdentifier)*)? ")";
	public ProcedureElements getProcedureAccess() {
		return pProcedure;
	}
	
	public ParserRule getProcedureRule() {
		return getProcedureAccess().getRule();
	}

	//// ==> Tasks
	//TaskDecl:
	//	"task" tasks+=Task ("," tasks+=Task)* ";";
	public TaskDeclElements getTaskDeclAccess() {
		return pTaskDecl;
	}
	
	public ParserRule getTaskDeclRule() {
		return getTaskDeclAccess().getRule();
	}

	//Task:
	//	name=ID "(" (idList1+=TypeIdentifier ("," idList1+=TypeIdentifier)*)? ")" "(" (idList2+=TypeIdentifier (","
	//	idList2+=TypeIdentifier)*)? ")";
	public TaskElements getTaskAccess() {
		return pTask;
	}
	
	public ParserRule getTaskRule() {
		return getTaskAccess().getRule();
	}

	//StatementContainer:
	//	statement=Statement;
	public StatementContainerElements getStatementContainerAccess() {
		return pStatementContainer;
	}
	
	public ParserRule getStatementContainerRule() {
		return getStatementContainerAccess().getRule();
	}

	//StatementContainerInterface StatementContainer:
	//	LocalSignalDecl | Block | Abort | AbortInstance | AbortCaseSingle | WeakAbort | WeakAbortInstance | AwaitInstance |
	//	Do | DoWatchingEnd | EveryDo | ThenPart | ElsePart | LoopBody | PresentCase | Repeat | Suspend | WeakSuspend | Trap |
	//	TrapHandler | LocalVariable | Exec | ExecCase
	public StatementContainerInterfaceElements getStatementContainerInterfaceAccess() {
		return pStatementContainerInterface;
	}
	
	public ParserRule getStatementContainerInterfaceRule() {
		return getStatementContainerInterfaceAccess().getRule();
	}

	//// ==============================================
	//// ===            B.4 Statements              ===
	//// ==============================================
	//// !-(parallel)
	//Statement:
	//	Sequence ({Parallel.list+=current} ("||" list+=Sequence)+)?;
	public StatementElements getStatementAccess() {
		return pStatement;
	}
	
	public ParserRule getStatementRule() {
		return getStatementAccess().getRule();
	}

	//// -!
	//AtomicStatement Statement:
	//	Abort | Assignment | Await | Block | ProcCall | Do | Emit | UnEmit | Reset | EveryDo | Exit | Exec | Halt | IfTest |
	//	LocalSignalDecl | Loop | Nothing | Pause | Present | Repeat | Run | Suspend | WeakSuspend | Sustain | Trap |
	//	LocalVariable | WeakAbort
	public AtomicStatementElements getAtomicStatementAccess() {
		return pAtomicStatement;
	}
	
	public ParserRule getAtomicStatementRule() {
		return getAtomicStatementAccess().getRule();
	}

	//// --> B.4.1 Control Flow Operators <--	
	//// !-(sequence)
	//Sequence Statement:
	//	AtomicStatement ({Sequence.list+=current} (";" list+=AtomicStatement)+)? ";"?
	public SequenceElements getSequenceAccess() {
		return pSequence;
	}
	
	public ParserRule getSequenceRule() {
		return getSequenceAccess().getRule();
	}

	//// -!
	//Block:
	//	"[" statement=Statement "]";
	public BlockElements getBlockAccess() {
		return pBlock;
	}
	
	public ParserRule getBlockRule() {
		return getBlockAccess().getRule();
	}

	//// Assignment
	//// !-(assign) -------------------------------------
	//Assignment:
	//	var=[kexpressions::IVariable] ":=" expr=Expression;
	public AssignmentElements getAssignmentAccess() {
		return pAssignment;
	}
	
	public ParserRule getAssignmentRule() {
		return getAssignmentAccess().getRule();
	}

	//// -!
	//// !-(abort) --> B.4.2 abort: Strong Preemption
	//// -------------------------------------
	//Abort:
	//	"abort" statement=Statement "when" body=AbortBody;
	public AbortElements getAbortAccess() {
		return pAbort;
	}
	
	public ParserRule getAbortRule() {
		return getAbortAccess().getRule();
	}

	//AbortBody:
	//	AbortInstance | AbortCase;
	public AbortBodyElements getAbortBodyAccess() {
		return pAbortBody;
	}
	
	public ParserRule getAbortBodyRule() {
		return getAbortBodyAccess().getRule();
	}

	//AbortInstance:
	//	delay=DelayExpr ("do" statement=Statement "end" optEnd="abort"?)?;
	public AbortInstanceElements getAbortInstanceAccess() {
		return pAbortInstance;
	}
	
	public ParserRule getAbortInstanceRule() {
		return getAbortInstanceAccess().getRule();
	}

	//AbortCase:
	//	cases+=AbortCaseSingle cases+=AbortCaseSingle* "end" optEnd="abort"?;
	public AbortCaseElements getAbortCaseAccess() {
		return pAbortCase;
	}
	
	public ParserRule getAbortCaseRule() {
		return getAbortCaseAccess().getRule();
	}

	//AbortCaseSingle:
	//	"case" delay=DelayExpr ("do" statement=Statement)?;
	public AbortCaseSingleElements getAbortCaseSingleAccess() {
		return pAbortCaseSingle;
	}
	
	public ParserRule getAbortCaseSingleRule() {
		return getAbortCaseSingleAccess().getRule();
	}

	//// -!
	//// --> B.4.25 weak abort: Weak Preemption
	//// -------------------------------------
	//WeakAbort Abort:
	//	{WeakAbort} "weak" "abort" statement=Statement "when" body=WeakAbortBody
	public WeakAbortElements getWeakAbortAccess() {
		return pWeakAbort;
	}
	
	public ParserRule getWeakAbortRule() {
		return getWeakAbortAccess().getRule();
	}

	//WeakAbortBody:
	//	WeakAbortInstance | WeakAbortCase;
	public WeakAbortBodyElements getWeakAbortBodyAccess() {
		return pWeakAbortBody;
	}
	
	public ParserRule getWeakAbortBodyRule() {
		return getWeakAbortBodyAccess().getRule();
	}

	//WeakAbortEnd:
	//	{WeakAbortEnd} "end" optEnd=WeakAbortEndAlt?;
	public WeakAbortEndElements getWeakAbortEndAccess() {
		return pWeakAbortEnd;
	}
	
	public ParserRule getWeakAbortEndRule() {
		return getWeakAbortEndAccess().getRule();
	}

	//WeakAbortEndAlt:
	//	end="weak"? endA="abort";
	public WeakAbortEndAltElements getWeakAbortEndAltAccess() {
		return pWeakAbortEndAlt;
	}
	
	public ParserRule getWeakAbortEndAltRule() {
		return getWeakAbortEndAltAccess().getRule();
	}

	//WeakAbortInstance AbortInstance:
	//	{WeakAbortInstance} delay=DelayExpr ("do" statement=Statement end=WeakAbortEnd)?
	public WeakAbortInstanceElements getWeakAbortInstanceAccess() {
		return pWeakAbortInstance;
	}
	
	public ParserRule getWeakAbortInstanceRule() {
		return getWeakAbortInstanceAccess().getRule();
	}

	//WeakAbortCase AbortCase:
	//	{WeakAbortCase} cases+=AbortCaseSingle cases+=AbortCaseSingle* end=WeakAbortEnd
	public WeakAbortCaseElements getWeakAbortCaseAccess() {
		return pWeakAbortCase;
	}
	
	public ParserRule getWeakAbortCaseRule() {
		return getWeakAbortCaseAccess().getRule();
	}

	//// --> B.4.3 await: Strong Preemption
	//// !-(await) -------------------------------------
	//Await:
	//	"await" body=AwaitBody;
	public AwaitElements getAwaitAccess() {
		return pAwait;
	}
	
	public ParserRule getAwaitRule() {
		return getAwaitAccess().getRule();
	}

	//AwaitBody:
	//	AwaitInstance | AwaitCase;
	public AwaitBodyElements getAwaitBodyAccess() {
		return pAwaitBody;
	}
	
	public ParserRule getAwaitBodyRule() {
		return getAwaitBodyAccess().getRule();
	}

	//AwaitInstance:
	//	delay=DelayExpr ("do" statement=Statement end=AwaitEnd)?;
	public AwaitInstanceElements getAwaitInstanceAccess() {
		return pAwaitInstance;
	}
	
	public ParserRule getAwaitInstanceRule() {
		return getAwaitInstanceAccess().getRule();
	}

	//AwaitCase:
	//	cases+=AbortCaseSingle cases+=AbortCaseSingle* end=AwaitEnd;
	public AwaitCaseElements getAwaitCaseAccess() {
		return pAwaitCase;
	}
	
	public ParserRule getAwaitCaseRule() {
		return getAwaitCaseAccess().getRule();
	}

	//AwaitEnd:
	//	"end" "await"?;
	public AwaitEndElements getAwaitEndAccess() {
		return pAwaitEnd;
	}
	
	public ParserRule getAwaitEndRule() {
		return getAwaitEndAccess().getRule();
	}

	//// -!
	//// --> B.4.4 call: Procedure Call
	//// -------------------------------------
	//ProcCall:
	//	"call" proc=[Procedure] "(" (varList+=[kexpressions::IVariable] ("," varList+=[kexpressions::IVariable])*)?
	//	")"
	//	"(" (kexpressions+=Expression ("," kexpressions+=Expression)*)? ")";
	public ProcCallElements getProcCallAccess() {
		return pProcCall;
	}
	
	public ParserRule getProcCallRule() {
		return getProcCallAccess().getRule();
	}

	//// --> B.4.5 do-upto: Conditional Iteration (deprecated)
	//// --> B.4.6 do-watching: Strong Preemption (deprecated)
	//// !-(doupto) -------------------------------------
	//Do:
	//	"do" statement=Statement (end=DoUpto | end=DoWatching);
	public DoElements getDoAccess() {
		return pDo;
	}
	
	public ParserRule getDoRule() {
		return getDoAccess().getRule();
	}

	//DoUpto:
	//	"upto" expr=DelayExpr;
	public DoUptoElements getDoUptoAccess() {
		return pDoUpto;
	}
	
	public ParserRule getDoUptoRule() {
		return getDoUptoAccess().getRule();
	}

	//DoWatching:
	//	"watching" delay=DelayExpr end=DoWatchingEnd?;
	public DoWatchingElements getDoWatchingAccess() {
		return pDoWatching;
	}
	
	public ParserRule getDoWatchingRule() {
		return getDoWatchingAccess().getRule();
	}

	//DoWatchingEnd:
	//	"timeout" statement=Statement "end" optEnd="timeout"?;
	public DoWatchingEndElements getDoWatchingEndAccess() {
		return pDoWatchingEnd;
	}
	
	public ParserRule getDoWatchingEndRule() {
		return getDoWatchingEndAccess().getRule();
	}

	//// -!
	//// --> B.4.7 emit: Signal Emission <--
	//// !-(emit)2 -------------------------------------
	//Emit:
	//	"emit" (signal=[kexpressions::ISignal] | tick=Tick) ("(" expr=Expression ")")?;
	public EmitElements getEmitAccess() {
		return pEmit;
	}
	
	public ParserRule getEmitRule() {
		return getEmitAccess().getRule();
	}

	//// -!
	//// --> SCEst only! unemit: Signal UnEmission <--
	//// !-(unemit)2 -------------------------------------
	//UnEmit:
	//	"unemit" (signal=[kexpressions::ISignal] | tick=Tick);
	public UnEmitElements getUnEmitAccess() {
		return pUnEmit;
	}
	
	public ParserRule getUnEmitRule() {
		return getUnEmitAccess().getRule();
	}

	//// -!
	//// --> SCEst only! reset: Signal value reset (absolute write) <--
	//// !-(emit)2 -------------------------------------
	//Reset:
	//	"reset" (signal=[kexpressions::ISignal] | tick=Tick) ("(" expr=Expression ")");
	public ResetElements getResetAccess() {
		return pReset;
	}
	
	public ParserRule getResetRule() {
		return getResetAccess().getRule();
	}

	//// -!
	//// --> B.4.8 every-do: Conditional Iteration
	//// !-(every)-------------------------------------
	//EveryDo:
	//	"every" delay=DelayExpr "do" statement=Statement "end" optEnd="every"?;
	public EveryDoElements getEveryDoAccess() {
		return pEveryDo;
	}
	
	public ParserRule getEveryDoRule() {
		return getEveryDoAccess().getRule();
	}

	//// -!
	//// --> B.4.10 exit: Trap Exit
	//// !-(exit) -------------------------------------
	//Exit:
	//	"exit" trap=[TrapDecl] ("(" expression=Expression ")")?;
	public ExitElements getExitAccess() {
		return pExit;
	}
	
	public ParserRule getExitRule() {
		return getExitAccess().getRule();
	}

	//// -!
	//// --> B.4.11 halt: Wait Forever
	//// !-(halt) -------------------------------------
	//Halt:
	//	{Halt} "halt";
	public HaltElements getHaltAccess() {
		return pHalt;
	}
	
	public ParserRule getHaltRule() {
		return getHaltAccess().getRule();
	}

	//// -!
	//// --> B.4.12: if: Conditional for Data
	//// !-(if)-------------------------------------
	//IfTest:
	//	"if" expr=Expression thenPart=ThenPart? elsif+=ElsIf* elsePart=ElsePart? "end" optEnd="if"?;
	public IfTestElements getIfTestAccess() {
		return pIfTest;
	}
	
	public ParserRule getIfTestRule() {
		return getIfTestAccess().getRule();
	}

	//ElsIf:
	//	"elsif" expr=Expression thenPart=ThenPart?;
	public ElsIfElements getElsIfAccess() {
		return pElsIf;
	}
	
	public ParserRule getElsIfRule() {
		return getElsIfAccess().getRule();
	}

	//ThenPart:
	//	"then" statement=Statement;
	public ThenPartElements getThenPartAccess() {
		return pThenPart;
	}
	
	public ParserRule getThenPartRule() {
		return getThenPartAccess().getRule();
	}

	//ElsePart:
	//	"else" statement=Statement;
	public ElsePartElements getElsePartAccess() {
		return pElsePart;
	}
	
	public ParserRule getElsePartRule() {
		return getElsePartAccess().getRule();
	}

	//// -!
	//// --> B.4.13 loop: Infinite Loop
	//// --> B.4.14 loop-each: Condition Iteration
	//// !-(loop)-------------------------------------
	//Loop:
	//	"loop" body=LoopBody (end1=EndLoop | end=LoopEach);
	public LoopElements getLoopAccess() {
		return pLoop;
	}
	
	public ParserRule getLoopRule() {
		return getLoopAccess().getRule();
	}

	//EndLoop:
	//	{EndLoop} "end" endOpt="loop"?;
	public EndLoopElements getEndLoopAccess() {
		return pEndLoop;
	}
	
	public ParserRule getEndLoopRule() {
		return getEndLoopAccess().getRule();
	}

	//LoopEach:
	//	"each" LoopDelay;
	public LoopEachElements getLoopEachAccess() {
		return pLoopEach;
	}
	
	public ParserRule getLoopEachRule() {
		return getLoopEachAccess().getRule();
	}

	//LoopDelay:
	//	delay=DelayExpr;
	public LoopDelayElements getLoopDelayAccess() {
		return pLoopDelay;
	}
	
	public ParserRule getLoopDelayRule() {
		return getLoopDelayAccess().getRule();
	}

	//LoopBody:
	//	statement=Statement;
	public LoopBodyElements getLoopBodyAccess() {
		return pLoopBody;
	}
	
	public ParserRule getLoopBodyRule() {
		return getLoopBodyAccess().getRule();
	}

	//// -!
	//// --> B.4.15 nothing: No Operation
	//// !-(nothing) -------------------------------------
	//Nothing:
	//	"nothing" {Nothing};
	public NothingElements getNothingAccess() {
		return pNothing;
	}
	
	public ParserRule getNothingRule() {
		return getNothingAccess().getRule();
	}

	//// -!
	//// --> B.4.16 pause: Unit Delay
	//// !-(pause) -------------------------------------
	//Pause:
	//	"pause" {Pause};
	public PauseElements getPauseAccess() {
		return pPause;
	}
	
	public ParserRule getPauseRule() {
		return getPauseAccess().getRule();
	}

	//// -!
	//// --> B.4.17 present: Conditional for Signals
	//// !-(present) -------------------------------------
	//Present:
	//	"present" body=PresentBody elsePart=ElsePart? "end" optEnd="present"?;
	public PresentElements getPresentAccess() {
		return pPresent;
	}
	
	public ParserRule getPresentRule() {
		return getPresentAccess().getRule();
	}

	//PresentBody:
	//	PresentEventBody | PresentCaseList;
	public PresentBodyElements getPresentBodyAccess() {
		return pPresentBody;
	}
	
	public ParserRule getPresentBodyRule() {
		return getPresentBodyAccess().getRule();
	}

	//PresentEventBody:
	//	event=PresentEvent thenPart=ThenPart?;
	public PresentEventBodyElements getPresentEventBodyAccess() {
		return pPresentEventBody;
	}
	
	public ParserRule getPresentEventBodyRule() {
		return getPresentEventBodyAccess().getRule();
	}

	//PresentCaseList:
	//	cases+=PresentCase cases+=PresentCase*;
	public PresentCaseListElements getPresentCaseListAccess() {
		return pPresentCaseList;
	}
	
	public ParserRule getPresentCaseListRule() {
		return getPresentCaseListAccess().getRule();
	}

	//PresentCase:
	//	"case" event=PresentEvent ("do" statement=Statement)?;
	public PresentCaseElements getPresentCaseAccess() {
		return pPresentCase;
	}
	
	public ParserRule getPresentCaseRule() {
		return getPresentCaseAccess().getRule();
	}

	//PresentEvent:
	//	expression=SignalExpression | fB="[" expression=SignalExpression eB="]" | tick=Tick;
	public PresentEventElements getPresentEventAccess() {
		return pPresentEvent;
	}
	
	public ParserRule getPresentEventRule() {
		return getPresentEventAccess().getRule();
	}

	//// -!
	//// --> B.4.18 repeat: Iterate a Fixed Number of Times
	//// -------------------------------------
	//Repeat:
	//	positive?="positive"? "repeat" expression=Expression "times" statement=Statement "end" optEnd="repeat"?;
	public RepeatElements getRepeatAccess() {
		return pRepeat;
	}
	
	public ParserRule getRepeatRule() {
		return getRepeatAccess().getRule();
	}

	//// --> B.4.19 run: Module Instantiation
	//// -------------------------------------
	//Run:
	//	"run" module=ModuleRenaming ("[" list=RenamingList "]")? | "copymodule" module=ModuleRenaming ("[" list=RenamingList
	//	"]")?;
	public RunElements getRunAccess() {
		return pRun;
	}
	
	public ParserRule getRunRule() {
		return getRunAccess().getRule();
	}

	////deprecated
	//// Renamings
	//// -------------------------------------
	//ModuleRenaming:
	//	module=[Module] | newName=ID "/" module=[Module];
	public ModuleRenamingElements getModuleRenamingAccess() {
		return pModuleRenaming;
	}
	
	public ParserRule getModuleRenamingRule() {
		return getModuleRenamingAccess().getRule();
	}

	//RenamingList:
	//	list+=Renaming (";" list+=Renaming)*;
	public RenamingListElements getRenamingListAccess() {
		return pRenamingList;
	}
	
	public ParserRule getRenamingListRule() {
		return getRenamingListAccess().getRule();
	}

	//Renaming:
	//	"type" renamings+=TypeRenaming ("," renamings+=TypeRenaming)*
	//	| "constant" renamings+=ConstantRenaming ("," renamings+=ConstantRenaming)*
	//	| "function" renamings+=FunctionRenaming ("," renamings+=FunctionRenaming)*
	//	| "procedure" renamings+=ProcedureRenaming ("," renamings+=ProcedureRenaming)*
	//	| "task" renamings+=TaskRenaming ("," renamings+=TaskRenaming)*
	//	| "signal" renamings+=SignalRenaming ("," renamings+=SignalRenaming)*;
	public RenamingElements getRenamingAccess() {
		return pRenaming;
	}
	
	public ParserRule getRenamingRule() {
		return getRenamingAccess().getRule();
	}

	//TypeRenaming:
	//	(newName=[Type] | newType=ValueType) "/" oldName=[Type];
	public TypeRenamingElements getTypeRenamingAccess() {
		return pTypeRenaming;
	}
	
	public ParserRule getTypeRenamingRule() {
		return getTypeRenamingAccess().getRule();
	}

	//ConstantRenaming:
	//	(newName=[kexpressions::ValuedObject] | newValue=ConstantAtom) "/" oldName=[kexpressions::ValuedObject];
	public ConstantRenamingElements getConstantRenamingAccess() {
		return pConstantRenaming;
	}
	
	public ParserRule getConstantRenamingRule() {
		return getConstantRenamingAccess().getRule();
	}

	//FunctionRenaming:
	//	(newName=[Function] | newFunc=BuildInFunction) "/" oldName=[Function];
	public FunctionRenamingElements getFunctionRenamingAccess() {
		return pFunctionRenaming;
	}
	
	public ParserRule getFunctionRenamingRule() {
		return getFunctionRenamingAccess().getRule();
	}

	//ProcedureRenaming:
	//	newName=[Procedure] "/" oldName=[Procedure];
	public ProcedureRenamingElements getProcedureRenamingAccess() {
		return pProcedureRenaming;
	}
	
	public ParserRule getProcedureRenamingRule() {
		return getProcedureRenamingAccess().getRule();
	}

	//TaskRenaming:
	//	newName=[Task] "/" oldName=[Task];
	public TaskRenamingElements getTaskRenamingAccess() {
		return pTaskRenaming;
	}
	
	public ParserRule getTaskRenamingRule() {
		return getTaskRenamingAccess().getRule();
	}

	//SignalRenaming:
	//	(newName=[kexpressions::ISignal] | "tick") "/" oldName=[kexpressions::ISignal];
	public SignalRenamingElements getSignalRenamingAccess() {
		return pSignalRenaming;
	}
	
	public ParserRule getSignalRenamingRule() {
		return getSignalRenamingAccess().getRule();
	}

	//// renamings can also rename build in types and functions
	//BuildInFunction:
	//	"*" | "/" | "+" | "-" | "mod" | "=" | "<>" | ">" | "<" | "<=" | ">=" | "not" | "and" | "or";
	public BuildInFunctionElements getBuildInFunctionAccess() {
		return pBuildInFunction;
	}
	
	public ParserRule getBuildInFunctionRule() {
		return getBuildInFunctionAccess().getRule();
	}

	//// --> B.4.21 suspend: Preemption with State Freeze
	//// !-(suspend)-------------------------------------
	//Suspend:
	//	"suspend" statement=Statement "when" delay=DelayExpr;
	public SuspendElements getSuspendAccess() {
		return pSuspend;
	}
	
	public ParserRule getSuspendRule() {
		return getSuspendAccess().getRule();
	}

	//// !-(weak suspend)-------------------------------------
	//WeakSuspend:
	//	"weak" "suspend" statement=Statement "when" delay=DelayExpr;
	public WeakSuspendElements getWeakSuspendAccess() {
		return pWeakSuspend;
	}
	
	public ParserRule getWeakSuspendRule() {
		return getWeakSuspendAccess().getRule();
	}

	//// -!
	//// --> B.4.22 sustain: Emit a Signal Indefinitely
	//// !-(sustain) -------------------------------------
	//Sustain:
	//	"sustain" (signal=[kexpressions::ISignal] | tick=Tick) ("(" expression=Expression ")")?;
	public SustainElements getSustainAccess() {
		return pSustain;
	}
	
	public ParserRule getSustainRule() {
		return getSustainAccess().getRule();
	}

	//// -!
	//// --> B.4.23 trap: TrapDeclaration and Handling
	//// !-(trap)-------------------------------------
	//Trap:
	//	"trap" trapDeclList=TrapDeclList "in" statement=Statement
	//	trapHandler+=TrapHandler* "end" optEnd="trap"?;
	public TrapElements getTrapAccess() {
		return pTrap;
	}
	
	public ParserRule getTrapRule() {
		return getTrapAccess().getRule();
	}

	//TrapDeclList:
	//	trapDecls+=TrapDecl ("," trapDecls+=TrapDecl)*;
	public TrapDeclListElements getTrapDeclListAccess() {
		return pTrapDeclList;
	}
	
	public ParserRule getTrapDeclListRule() {
		return getTrapDeclListAccess().getRule();
	}

	//TrapDecl kexpressions::ISignal:
	//	{TrapDecl} name=ID channelDescr=ChannelDescription?
	public TrapDeclElements getTrapDeclAccess() {
		return pTrapDecl;
	}
	
	public ParserRule getTrapDeclRule() {
		return getTrapDeclAccess().getRule();
	}

	//TrapHandler:
	//	"handle" trapExpr=TrapExpr "do" statement=Statement;
	public TrapHandlerElements getTrapHandlerAccess() {
		return pTrapHandler;
	}
	
	public ParserRule getTrapHandlerRule() {
		return getTrapHandlerAccess().getRule();
	}

	//// -!
	//// --> B.4.24 var: Local Variable Declaration
	//// !-(localvariable) -------------------------------------
	//LocalVariable:
	//	var=InterfaceVariableDecl "in" statement=Statement "end" optEnd="var"?;
	public LocalVariableElements getLocalVariableAccess() {
		return pLocalVariable;
	}
	
	public ParserRule getLocalVariableRule() {
		return getLocalVariableAccess().getRule();
	}

	//// -!
	//// ==============================================
	//// ===            B.2.5 SCL             ===
	//// ==============================================
	//// goto -------------------------------------
	//Goto:
	//	"goto" targetLabel=ID ";";
	public GotoElements getGotoAccess() {
		return pGoto;
	}
	
	public ParserRule getGotoRule() {
		return getGotoAccess().getRule();
	}

	//Label:
	//	label=ID ':';
	public LabelElements getLabelAccess() {
		return pLabel;
	}
	
	public ParserRule getLabelRule() {
		return getLabelAccess().getRule();
	}

	//// ==============================================
	//// ===            B.3 Expressions             ===
	//// ==============================================
	//// esterel is a bit richer than what is provided by kexpressions. These rules are introduced here
	//// care about order of the rules! 
	//AtomicExpression kexpressions::Expression:
	//	FunctionExpression
	//	| TrapExpression
	//	| BooleanValue
	//	| ValuedObjectTestExpression
	//	| TextExpression
	//	| '(' BooleanExpression ')'
	//	| ConstantExpression
	public AtomicExpressionElements getAtomicExpressionAccess() {
		return pAtomicExpression;
	}
	
	public ParserRule getAtomicExpressionRule() {
		return getAtomicExpressionAccess().getRule();
	}

	//TrapExpression kexpressions::Expression:
	//	{TrapExpression} "??" trap=[kexpressions::ISignal]
	public TrapExpressionElements getTrapExpressionAccess() {
		return pTrapExpression;
	}
	
	public ParserRule getTrapExpressionRule() {
		return getTrapExpressionAccess().getRule();
	}

	//FunctionExpression kexpressions::Expression:
	//	{FunctionExpression} function=[Function] "(" (kexpressions+=Expression ("," kexpressions+=Expression)*)? ")"
	public FunctionExpressionElements getFunctionExpressionAccess() {
		return pFunctionExpression;
	}
	
	public ParserRule getFunctionExpressionRule() {
		return getFunctionExpressionAccess().getRule();
	}

	//ConstantExpression kexpressions::Expression:
	//	{ConstantExpression} (constant=[Constant] | value=ConstantAtom)
	public ConstantExpressionElements getConstantExpressionAccess() {
		return pConstantExpression;
	}
	
	public ParserRule getConstantExpressionRule() {
		return getConstantExpressionAccess().getRule();
	}

	//// --> B.3.5 Trap Expressions <--
	//// -------------------------------------
	//TrapExpr kexpressions::Expression:
	//	SignalExpression
	public TrapExprElements getTrapExprAccess() {
		return pTrapExpr;
	}
	
	public ParserRule getTrapExprRule() {
		return getTrapExprAccess().getRule();
	}

	//// --> B.3.3 Signal Expressions <--
	//// -------------------------------------
	//SignalExpression kexpressions::Expression:
	//	SignalAndExpression ({kexpressions::OperatorExpression.subExpressions+=current} operator=OrOperator
	//	subExpressions+=SignalAndExpression)*
	public SignalExpressionElements getSignalExpressionAccess() {
		return pSignalExpression;
	}
	
	public ParserRule getSignalExpressionRule() {
		return getSignalExpressionAccess().getRule();
	}

	//SignalAndExpression kexpressions::Expression:
	//	SignalNotExpression ({kexpressions::OperatorExpression.subExpressions+=current} operator=AndOperator
	//	subExpressions+=SignalNotExpression)*
	public SignalAndExpressionElements getSignalAndExpressionAccess() {
		return pSignalAndExpression;
	}
	
	public ParserRule getSignalAndExpressionRule() {
		return getSignalAndExpressionAccess().getRule();
	}

	//SignalNotExpression kexpressions::Expression:
	//	{kexpressions::OperatorExpression} operator=NotOperator subExpressions+=SignalNotExpression | SignalAtomicExpression
	public SignalNotExpressionElements getSignalNotExpressionAccess() {
		return pSignalNotExpression;
	}
	
	public ParserRule getSignalNotExpressionRule() {
		return getSignalNotExpressionAccess().getRule();
	}

	//SignalAtomicExpression kexpressions::Expression:
	//	SignalReferenceExpr
	//	| "(" SignalExpression ")"
	//	| SignalPreExpr
	//	| TrapReferenceExpr
	public SignalAtomicExpressionElements getSignalAtomicExpressionAccess() {
		return pSignalAtomicExpression;
	}
	
	public ParserRule getSignalAtomicExpressionRule() {
		return getSignalAtomicExpressionAccess().getRule();
	}

	//SignalReferenceExpr kexpressions::ValuedObjectReference:
	//	valuedObject=[kexpressions::ISignal]
	public SignalReferenceExprElements getSignalReferenceExprAccess() {
		return pSignalReferenceExpr;
	}
	
	public ParserRule getSignalReferenceExprRule() {
		return getSignalReferenceExprAccess().getRule();
	}

	//SignalPreExpr kexpressions::Expression:
	//	{kexpressions::OperatorExpression} operator=PreOperator '(' subExpressions+=SignalReferenceExpr ')'
	public SignalPreExprElements getSignalPreExprAccess() {
		return pSignalPreExpr;
	}
	
	public ParserRule getSignalPreExprRule() {
		return getSignalPreExprAccess().getRule();
	}

	//TrapReferenceExpr kexpressions::ValuedObjectReference:
	//	{TrapReferenceExpr} valuedObject=[TrapDecl]
	public TrapReferenceExprElements getTrapReferenceExprAccess() {
		return pTrapReferenceExpr;
	}
	
	public ParserRule getTrapReferenceExprRule() {
		return getTrapReferenceExprAccess().getRule();
	}

	//// --> B.3.4 Delay Expressions <--
	//// -------------------------------------
	//DelayExpr:
	//	expr=Expression event=DelayEvent | event=DelayEvent | isImmediate?="immediate" event=DelayEvent;
	public DelayExprElements getDelayExprAccess() {
		return pDelayExpr;
	}
	
	public ParserRule getDelayExprRule() {
		return getDelayExprAccess().getRule();
	}

	//DelayEvent:
	//	tick=Tick | expr=SignalReferenceExpr | fB="[" expr=SignalExpression eB="]";
	public DelayEventElements getDelayEventAccess() {
		return pDelayEvent;
	}
	
	public ParserRule getDelayEventRule() {
		return getDelayEventAccess().getRule();
	}

	//// --> Exec
	//// -------------------------------------
	//Exec:
	//	("exec" task=[Task] body=ExecBody "return" retSignal=[kexpressions::ISignal] ("do" statement=Statement)? | "exec"
	//	execCaseList+=ExecCase execCaseList+=ExecCase*) "end" optEnd="exec"?;
	public ExecElements getExecAccess() {
		return pExec;
	}
	
	public ParserRule getExecRule() {
		return getExecAccess().getRule();
	}

	//ExecBody:
	//	{ExecBody} "(" (vars+=[kexpressions::IVariable] ("," vars+=[kexpressions::IVariable])*)? ")" "("
	//	(kexpressions+=Expression ("," kexpressions+=Expression)*)? ")";
	public ExecBodyElements getExecBodyAccess() {
		return pExecBody;
	}
	
	public ParserRule getExecBodyRule() {
		return getExecBodyAccess().getRule();
	}

	//ExecCase:
	//	"case" task=[Task] body=ExecBody "return" retSignal=[kexpressions::ISignal] ("do" statement=Statement)?;
	public ExecCaseElements getExecCaseAccess() {
		return pExecCase;
	}
	
	public ParserRule getExecCaseRule() {
		return getExecCaseAccess().getRule();
	}

	//// ==============================================
	//// === B.2 Namespaces and Predefined Objects  ===
	//// ==============================================
	//Tick:
	//	"tick";
	public TickElements getTickAccess() {
		return pTick;
	}
	
	public ParserRule getTickRule() {
		return getTickAccess().getRule();
	}

	//terminal ESTEREL_SL_COMMENT:
	//	'%' !('\n' |
	//	'\r')* ('\r'? '\n')?;
	public TerminalRule getESTEREL_SL_COMMENTRule() {
		return tESTEREL_SL_COMMENT;
	} 

	//terminal ESTEREL_ML_COMMENT:
	//	('%' '{')->('}' '%');
	public TerminalRule getESTEREL_ML_COMMENTRule() {
		return tESTEREL_ML_COMMENT;
	} 

	//terminal STRING:
	//	'"' (!'"' | '"' '"')* '"';
	public TerminalRule getSTRINGRule() {
		return tSTRING;
	} 

	//Root ecore::EObject:
	//	Expression
	//	| InterfaceDeclaration
	public KExpressionsGrammarAccess.RootElements getRootAccess() {
		return gaKExpressions.getRootAccess();
	}
	
	public ParserRule getRootRule() {
		return getRootAccess().getRule();
	}

	////Variable returns annotations::Annotatable:
	////    (annotations += StringAnnotation)*;
	//// --------------------------
	////
	////   EXPRESSIONS
	////
	//// --------------------------
	//Expression:
	//	=> BooleanExpression
	//	| ValuedExpression;
	public KExpressionsGrammarAccess.ExpressionElements getExpressionAccess() {
		return gaKExpressions.getExpressionAccess();
	}
	
	public ParserRule getExpressionRule() {
		return getExpressionAccess().getRule();
	}

	//// Example: not D and C or ?E = 42 or not (A and (B or C))
	//BooleanExpression Expression:
	//	OrExpression
	public KExpressionsGrammarAccess.BooleanExpressionElements getBooleanExpressionAccess() {
		return gaKExpressions.getBooleanExpressionAccess();
	}
	
	public ParserRule getBooleanExpressionRule() {
		return getBooleanExpressionAccess().getRule();
	}

	//// Example: A or B, A and B and C, C and B or D and not E, A and B and C
	//OrExpression Expression:
	//	AndExpression ({OperatorExpression.subExpressions+=current} operator=OrOperator subExpressions+=AndExpression)*
	public KExpressionsGrammarAccess.OrExpressionElements getOrExpressionAccess() {
		return gaKExpressions.getOrExpressionAccess();
	}
	
	public ParserRule getOrExpressionRule() {
		return getOrExpressionAccess().getRule();
	}

	//// Example: A and B, not C and 42 <= ?D
	//AndExpression Expression:
	//	CompareOperation ({OperatorExpression.subExpressions+=current} operator=AndOperator
	//	subExpressions+=CompareOperation)*
	public KExpressionsGrammarAccess.AndExpressionElements getAndExpressionAccess() {
		return gaKExpressions.getAndExpressionAccess();
	}
	
	public ParserRule getAndExpressionRule() {
		return getAndExpressionAccess().getRule();
	}

	//// Example: 42 <= ?A
	//CompareOperation Expression:
	//	=> NotOrValuedExpression ({OperatorExpression.subExpressions+=current} operator=CompareOperator
	//	subExpressions+=NotOrValuedExpression) | NotExpression
	public KExpressionsGrammarAccess.CompareOperationElements getCompareOperationAccess() {
		return gaKExpressions.getCompareOperationAccess();
	}
	
	public ParserRule getCompareOperationRule() {
		return getCompareOperationAccess().getRule();
	}

	//// order IS IMPORTANT
	//NotOrValuedExpression Expression:
	//	=> ValuedExpression
	//	| NotExpression
	public KExpressionsGrammarAccess.NotOrValuedExpressionElements getNotOrValuedExpressionAccess() {
		return gaKExpressions.getNotOrValuedExpressionAccess();
	}
	
	public ParserRule getNotOrValuedExpressionRule() {
		return getNotOrValuedExpressionAccess().getRule();
	}

	//// Example: not A, not false, not (A or B)
	//// at the latter we need the parans to indicate the right binding
	//NotExpression Expression:
	//	{OperatorExpression} operator=NotOperator subExpressions+=NotExpression | super::AtomicExpression
	public KExpressionsGrammarAccess.NotExpressionElements getNotExpressionAccess() {
		return gaKExpressions.getNotExpressionAccess();
	}
	
	public ParserRule getNotExpressionRule() {
		return getNotExpressionAccess().getRule();
	}

	//// everything that evaluates to a primitive number value
	//ValuedExpression Expression:
	//	AddExpression
	public KExpressionsGrammarAccess.ValuedExpressionElements getValuedExpressionAccess() {
		return gaKExpressions.getValuedExpressionAccess();
	}
	
	public ParserRule getValuedExpressionRule() {
		return getValuedExpressionAccess().getRule();
	}

	//// Example: 1 + 2
	//AddExpression Expression:
	//	SubExpression ({OperatorExpression.subExpressions+=current} operator=AddOperator subExpressions+=SubExpression)*
	public KExpressionsGrammarAccess.AddExpressionElements getAddExpressionAccess() {
		return gaKExpressions.getAddExpressionAccess();
	}
	
	public ParserRule getAddExpressionRule() {
		return getAddExpressionAccess().getRule();
	}

	//// Example: varA - ?B
	//SubExpression Expression:
	//	MultExpression ({OperatorExpression.subExpressions+=current} operator=SubOperator subExpressions+=MultExpression)*
	public KExpressionsGrammarAccess.SubExpressionElements getSubExpressionAccess() {
		return gaKExpressions.getSubExpressionAccess();
	}
	
	public ParserRule getSubExpressionRule() {
		return getSubExpressionAccess().getRule();
	}

	////    ({OperatorExpression} subExpressions+=MultExpression (operator=SubOperator subExpressions+=MultExpression)+)
	////	| ({OperatorExpression} subExpressions+=MultExpression subExpressions+=NIntValue)
	////    | MultExpression;
	//// Example: 2 * 4
	//MultExpression Expression:
	//	DivExpression ({OperatorExpression.subExpressions+=current} operator=MultOperator subExpressions+=DivExpression)*
	public KExpressionsGrammarAccess.MultExpressionElements getMultExpressionAccess() {
		return gaKExpressions.getMultExpressionAccess();
	}
	
	public ParserRule getMultExpressionRule() {
		return getMultExpressionAccess().getRule();
	}

	//// Example: (2 / 4)
	//// note: division always has to have parantheses because the '/' sign is also used for trigger/effect delimiter
	//DivExpression Expression:
	//	ModExpression ({OperatorExpression.subExpressions+=current} operator=DivOperator subExpressions+=ModExpression)?
	public KExpressionsGrammarAccess.DivExpressionElements getDivExpressionAccess() {
		return gaKExpressions.getDivExpressionAccess();
	}
	
	public ParserRule getDivExpressionRule() {
		return getDivExpressionAccess().getRule();
	}

	//// Example: varA mod ?B
	//ModExpression Expression:
	//	NegExpression ({OperatorExpression.subExpressions+=current} operator=ModOperator
	//	subExpressions+=AtomicValuedExpression)?
	public KExpressionsGrammarAccess.ModExpressionElements getModExpressionAccess() {
		return gaKExpressions.getModExpressionAccess();
	}
	
	public ParserRule getModExpressionRule() {
		return getModExpressionAccess().getRule();
	}

	//// Example: not A, not false, not (A or B)
	//// at the latter we need the parans to indicate the right binding
	//NegExpression Expression:
	//	{OperatorExpression} operator=SubOperator subExpressions+=NegExpression | AtomicValuedExpression
	public KExpressionsGrammarAccess.NegExpressionElements getNegExpressionAccess() {
		return gaKExpressions.getNegExpressionAccess();
	}
	
	public ParserRule getNegExpressionRule() {
		return getNegExpressionAccess().getRule();
	}

	//AtomicValuedExpression Expression:
	//	IntValue
	//	| FloatValue
	//	//    | '(' DivExpression ')'
	//	| => '(' ValuedExpression ')'
	//	| super::AtomicExpression
	public KExpressionsGrammarAccess.AtomicValuedExpressionElements getAtomicValuedExpressionAccess() {
		return gaKExpressions.getAtomicValuedExpressionAccess();
	}
	
	public ParserRule getAtomicValuedExpressionRule() {
		return getAtomicValuedExpressionAccess().getRule();
	}

	//// Example: pre(pre(?A)), pre(pre(A)), ?A, A varX
	//ValuedObjectTestExpression Expression:
	//	{OperatorExpression} operator=PreOperator '(' subExpressions+=ValuedObjectTestExpression ')'
	//	| {OperatorExpression} operator=ValueTestOperator subExpressions+=ValuedObjectReference
	//	| ValuedObjectReference
	public KExpressionsGrammarAccess.ValuedObjectTestExpressionElements getValuedObjectTestExpressionAccess() {
		return gaKExpressions.getValuedObjectTestExpressionAccess();
	}
	
	public ParserRule getValuedObjectTestExpressionRule() {
		return getValuedObjectTestExpressionAccess().getRule();
	}

	//// Example: A, varB
	//ValuedObjectReference:
	//	valuedObject=[ValuedObject];
	public KExpressionsGrammarAccess.ValuedObjectReferenceElements getValuedObjectReferenceAccess() {
		return gaKExpressions.getValuedObjectReferenceAccess();
	}
	
	public ParserRule getValuedObjectReferenceRule() {
		return getValuedObjectReferenceAccess().getRule();
	}

	//// Example: 'printf(...)'(C)
	//TextExpression:
	//	code=HOSTCODE ("(" type=ID ")")?;
	public KExpressionsGrammarAccess.TextExpressionElements getTextExpressionAccess() {
		return gaKExpressions.getTextExpressionAccess();
	}
	
	public ParserRule getTextExpressionRule() {
		return getTextExpressionAccess().getRule();
	}

	//IntValue:
	//	value=INT;
	public KExpressionsGrammarAccess.IntValueElements getIntValueAccess() {
		return gaKExpressions.getIntValueAccess();
	}
	
	public ParserRule getIntValueRule() {
		return getIntValueAccess().getRule();
	}

	////NIntValue returns IntValue:
	////	value=NINT;
	//FloatValue:
	//	value=FLOAT;
	public KExpressionsGrammarAccess.FloatValueElements getFloatValueAccess() {
		return gaKExpressions.getFloatValueAccess();
	}
	
	public ParserRule getFloatValueRule() {
		return getFloatValueAccess().getRule();
	}

	//BooleanValue:
	//	value=BOOLEAN;
	public KExpressionsGrammarAccess.BooleanValueElements getBooleanValueAccess() {
		return gaKExpressions.getBooleanValueAccess();
	}
	
	public ParserRule getBooleanValueRule() {
		return getBooleanValueAccess().getRule();
	}

	//// data type rule allowing any kind of value to be accepted,
	//// e.g. as initialValues of valuedObjects
	//// used in Kits.xtext 
	//AnyType:
	//	BOOLEAN | INT | FLOAT | ID | super::STRING;
	public KExpressionsGrammarAccess.AnyTypeElements getAnyTypeAccess() {
		return gaKExpressions.getAnyTypeAccess();
	}
	
	public ParserRule getAnyTypeRule() {
		return getAnyTypeAccess().getRule();
	}

	//// --------------------------
	////
	////  Interface Declarations
	////
	//// --------------------------
	//InterfaceDeclaration:
	//	InterfaceSignalDecl
	//	| InterfaceVariableDecl;
	public KExpressionsGrammarAccess.InterfaceDeclarationElements getInterfaceDeclarationAccess() {
		return gaKExpressions.getInterfaceDeclarationAccess();
	}
	
	public ParserRule getInterfaceDeclarationRule() {
		return getInterfaceDeclarationAccess().getRule();
	}

	//ISignal:
	//	name=ID channelDescr=super::ChannelDescription?;
	public KExpressionsGrammarAccess.ISignalElements getISignalAccess() {
		return gaKExpressions.getISignalAccess();
	}
	
	public ParserRule getISignalRule() {
		return getISignalAccess().getRule();
	}

	//InterfaceSignalDecl:
	//	{Input} "input" signals+=ISignal ("," signals+=ISignal)* ";" | {Output} "output" signals+=ISignal (","
	//	signals+=ISignal)* ";" | {InputOutput} "inputoutput" signals+=ISignal ("," signals+=ISignal)* ";" | {Return} "return"
	//	signals+=ISignal ("," signals+=ISignal)* ";";
	public KExpressionsGrammarAccess.InterfaceSignalDeclElements getInterfaceSignalDeclAccess() {
		return gaKExpressions.getInterfaceSignalDeclAccess();
	}
	
	public ParserRule getInterfaceSignalDeclRule() {
		return getInterfaceSignalDeclAccess().getRule();
	}

	//// Variables
	//InterfaceVariableDecl:
	//	"var" varDecls+=VariableDecl ("," varDecls+=VariableDecl)*;
	public KExpressionsGrammarAccess.InterfaceVariableDeclElements getInterfaceVariableDeclAccess() {
		return gaKExpressions.getInterfaceVariableDeclAccess();
	}
	
	public ParserRule getInterfaceVariableDeclRule() {
		return getInterfaceVariableDeclAccess().getRule();
	}

	//VariableDecl:
	//	variables+=IVariable ("," variables+=IVariable)* ":" type=super::TypeIdentifier;
	public KExpressionsGrammarAccess.VariableDeclElements getVariableDeclAccess() {
		return gaKExpressions.getVariableDeclAccess();
	}
	
	public ParserRule getVariableDeclRule() {
		return getVariableDeclAccess().getRule();
	}

	//IVariable:
	//	name=ID (":=" expression=Expression)?;
	public KExpressionsGrammarAccess.IVariableElements getIVariableAccess() {
		return gaKExpressions.getIVariableAccess();
	}
	
	public ParserRule getIVariableRule() {
		return getIVariableAccess().getRule();
	}

	//enum CompareOperator returns OperatorType:
	//	EQ="=" | LT="<" | LEQ="<=" | GT=">" | GEQ=">=" | NE="<>";
	public KExpressionsGrammarAccess.CompareOperatorElements getCompareOperatorAccess() {
		return gaKExpressions.getCompareOperatorAccess();
	}
	
	public EnumRule getCompareOperatorRule() {
		return getCompareOperatorAccess().getRule();
	}

	//enum PreOperator returns OperatorType:
	//	PRE="pre";
	public KExpressionsGrammarAccess.PreOperatorElements getPreOperatorAccess() {
		return gaKExpressions.getPreOperatorAccess();
	}
	
	public EnumRule getPreOperatorRule() {
		return getPreOperatorAccess().getRule();
	}

	//enum OrOperator returns OperatorType:
	//	OR="or";
	public KExpressionsGrammarAccess.OrOperatorElements getOrOperatorAccess() {
		return gaKExpressions.getOrOperatorAccess();
	}
	
	public EnumRule getOrOperatorRule() {
		return getOrOperatorAccess().getRule();
	}

	//enum AndOperator returns OperatorType:
	//	AND="and";
	public KExpressionsGrammarAccess.AndOperatorElements getAndOperatorAccess() {
		return gaKExpressions.getAndOperatorAccess();
	}
	
	public EnumRule getAndOperatorRule() {
		return getAndOperatorAccess().getRule();
	}

	//enum NotOperator returns OperatorType:
	//	NOT="not";
	public KExpressionsGrammarAccess.NotOperatorElements getNotOperatorAccess() {
		return gaKExpressions.getNotOperatorAccess();
	}
	
	public EnumRule getNotOperatorRule() {
		return getNotOperatorAccess().getRule();
	}

	//enum AddOperator returns OperatorType:
	//	ADD="+";
	public KExpressionsGrammarAccess.AddOperatorElements getAddOperatorAccess() {
		return gaKExpressions.getAddOperatorAccess();
	}
	
	public EnumRule getAddOperatorRule() {
		return getAddOperatorAccess().getRule();
	}

	//enum SubOperator returns OperatorType:
	//	SUB="-";
	public KExpressionsGrammarAccess.SubOperatorElements getSubOperatorAccess() {
		return gaKExpressions.getSubOperatorAccess();
	}
	
	public EnumRule getSubOperatorRule() {
		return getSubOperatorAccess().getRule();
	}

	//enum MultOperator returns OperatorType:
	//	MULT="*";
	public KExpressionsGrammarAccess.MultOperatorElements getMultOperatorAccess() {
		return gaKExpressions.getMultOperatorAccess();
	}
	
	public EnumRule getMultOperatorRule() {
		return getMultOperatorAccess().getRule();
	}

	//enum ModOperator returns OperatorType:
	//	MOD="mod";
	public KExpressionsGrammarAccess.ModOperatorElements getModOperatorAccess() {
		return gaKExpressions.getModOperatorAccess();
	}
	
	public EnumRule getModOperatorRule() {
		return getModOperatorAccess().getRule();
	}

	//enum DivOperator returns OperatorType:
	//	DIV="/";
	public KExpressionsGrammarAccess.DivOperatorElements getDivOperatorAccess() {
		return gaKExpressions.getDivOperatorAccess();
	}
	
	public EnumRule getDivOperatorRule() {
		return getDivOperatorAccess().getRule();
	}

	//enum ValueTestOperator returns OperatorType:
	//	VAL="?";
	public KExpressionsGrammarAccess.ValueTestOperatorElements getValueTestOperatorAccess() {
		return gaKExpressions.getValueTestOperatorAccess();
	}
	
	public EnumRule getValueTestOperatorRule() {
		return getValueTestOperatorAccess().getRule();
	}

	//enum ValueType:
	//	PURE="pure" | BOOL="boolean" | UNSIGNED="unsigned" |
	//	INT="integer" | FLOAT="float" | DOUBLE="double" |
	//	STRING="string" | HOST="host";
	public KExpressionsGrammarAccess.ValueTypeElements getValueTypeAccess() {
		return gaKExpressions.getValueTypeAccess();
	}
	
	public EnumRule getValueTypeRule() {
		return getValueTypeAccess().getRule();
	}

	//enum CombineOperator:
	//	NONE="none" | ADD="+" | MULT="*" | MAX="max" |
	//	MIN="min" | OR="or" | AND="and" | HOST="host";
	public KExpressionsGrammarAccess.CombineOperatorElements getCombineOperatorAccess() {
		return gaKExpressions.getCombineOperatorAccess();
	}
	
	public EnumRule getCombineOperatorRule() {
		return getCombineOperatorAccess().getRule();
	}

	//terminal HOSTCODE:
	//	"'" ('\\' ('b' | 't' | 'n' | 'f' | 'r' | '"' | "'" | '\\') | !('\\' | "'"))* "'";
	public TerminalRule getHOSTCODERule() {
		return gaKExpressions.getHOSTCODERule();
	} 

	/// **
	// * @author ssm
	// * @kieler.design 2015-08-21 proposed 
	// * @kieler.rating 2015-08-21 proposed yellow
	// * / // ------------------ //
	////  Annotation Rules  // 
	//// ------------------ //
	//// General rule for annotations
	//// The different annotation sub rules are tested in order. Hence, order matters! 
	//Annotation:
	//	CommentAnnotation | KeyStringValueAnnotation | TypedKeyStringValueAnnotation | TagAnnotation;
	public AnnotationsGrammarAccess.AnnotationElements getAnnotationAccess() {
		return gaAnnotations.getAnnotationAccess();
	}
	
	public ParserRule getAnnotationRule() {
		return getAnnotationAccess().getRule();
	}

	//// General rule for pragmas
	//// We only have string and tag pragmas.    
	//PragmaAnnotation Annotation:
	//	PramgaKeyStringValueAnnotation | PragmaTagAnnotation
	public AnnotationsGrammarAccess.PragmaAnnotationElements getPragmaAnnotationAccess() {
		return gaAnnotations.getPragmaAnnotationAccess();
	}
	
	public ParserRule getPragmaAnnotationRule() {
		return getPragmaAnnotationAccess().getRule();
	}

	//// Valued Annotation Rule
	//// Valued annotations must have a value. For instance, tag annotations are not allowed.
	//// Derived grammars may use this rule if the general annotation rules compromises the grammar
	//// due to ambiguities.
	//ValuedAnnotation Annotation:
	//	CommentAnnotation | KeyStringValueAnnotation | TypedKeyStringValueAnnotation
	public AnnotationsGrammarAccess.ValuedAnnotationElements getValuedAnnotationAccess() {
		return gaAnnotations.getValuedAnnotationAccess();
	}
	
	public ParserRule getValuedAnnotationRule() {
		return getValuedAnnotationAccess().getRule();
	}

	//// Restricted Type Annotation Rule
	//// The restricted type annotation rule does not allow typed string annotations. 
	//// You can use this rule in derived grammars if you don't want to permit typed strings. 
	//RestrictedTypeAnnotation Annotation:
	//	CommentAnnotation | RestrictedKeyStringValueAnnotation | RestrictedTypedKeyStringValueAnnotation | TagAnnotation
	public AnnotationsGrammarAccess.RestrictedTypeAnnotationElements getRestrictedTypeAnnotationAccess() {
		return gaAnnotations.getRestrictedTypeAnnotationAccess();
	}
	
	public ParserRule getRestrictedTypeAnnotationRule() {
		return getRestrictedTypeAnnotationAccess().getRule();
	}

	//// Quoted String Annotation Rule
	//// The quoted string annotation rules uses quoted key string annotations. You can use this rule in 
	//// derived grammars if you don't want to permit unquoted strings. 
	//// (If you are looking for an example, the keffects grammar uses this rule for their emission
	//// rule and to avoid grammar ambiguities.)  
	//QuotedStringAnnotation Annotation:
	//	CommentAnnotation | QuotedKeyStringValueAnnotation | QuotedTypedKeyStringValueAnnotation | TagAnnotation
	public AnnotationsGrammarAccess.QuotedStringAnnotationElements getQuotedStringAnnotationAccess() {
		return gaAnnotations.getQuotedStringAnnotationAccess();
	}
	
	public ParserRule getQuotedStringAnnotationRule() {
		return getQuotedStringAnnotationAccess().getRule();
	}

	//// CommentAnnotation
	//// e.g.: / ** semantic comment * /
	//CommentAnnotation:
	//	values+=COMMENT_ANNOTATION;
	public AnnotationsGrammarAccess.CommentAnnotationElements getCommentAnnotationAccess() {
		return gaAnnotations.getCommentAnnotationAccess();
	}
	
	public ParserRule getCommentAnnotationRule() {
		return getCommentAnnotationAccess().getRule();
	}

	//// TagAnnotation
	//// e.g.: @HVlayout
	//TagAnnotation Annotation:
	//	'@' name=ExtendedID
	public AnnotationsGrammarAccess.TagAnnotationElements getTagAnnotationAccess() {
		return gaAnnotations.getTagAnnotationAccess();
	}
	
	public ParserRule getTagAnnotationRule() {
		return getTagAnnotationAccess().getRule();
	}

	//PragmaTagAnnotation PragmaAnnotation:
	//	'#' name=ExtendedID
	public AnnotationsGrammarAccess.PragmaTagAnnotationElements getPragmaTagAnnotationAccess() {
		return gaAnnotations.getPragmaTagAnnotationAccess();
	}
	
	public ParserRule getPragmaTagAnnotationRule() {
		return getPragmaTagAnnotationAccess().getRule();
	}

	//// KeyStringValueAnnotation
	//// e.g.: @layouter dot
	//// You may separate different values via comma.   
	//KeyStringValueAnnotation StringAnnotation:
	//	'@' name=ExtendedID values+=EStringAllTypes (',' values+=EStringAllTypes)*
	public AnnotationsGrammarAccess.KeyStringValueAnnotationElements getKeyStringValueAnnotationAccess() {
		return gaAnnotations.getKeyStringValueAnnotationAccess();
	}
	
	public ParserRule getKeyStringValueAnnotationRule() {
		return getKeyStringValueAnnotationAccess().getRule();
	}

	//RestrictedKeyStringValueAnnotation StringAnnotation:
	//	'@' name=ExtendedID values+=EStringBoolean (',' values+=EStringBoolean)*
	public AnnotationsGrammarAccess.RestrictedKeyStringValueAnnotationElements getRestrictedKeyStringValueAnnotationAccess() {
		return gaAnnotations.getRestrictedKeyStringValueAnnotationAccess();
	}
	
	public ParserRule getRestrictedKeyStringValueAnnotationRule() {
		return getRestrictedKeyStringValueAnnotationAccess().getRule();
	}

	//PramgaKeyStringValueAnnotation PragmaStringAnnotation:
	//	'#' name=ExtendedID values+=EStringAllTypes (',' values+=EStringAllTypes)*
	public AnnotationsGrammarAccess.PramgaKeyStringValueAnnotationElements getPramgaKeyStringValueAnnotationAccess() {
		return gaAnnotations.getPramgaKeyStringValueAnnotationAccess();
	}
	
	public ParserRule getPramgaKeyStringValueAnnotationRule() {
		return getPramgaKeyStringValueAnnotationAccess().getRule();
	}

	//// TypedKeyStringValueAnnotation
	//// e.g.: @position[de.cau.cs.kieler.core.math.KVector] "(3,2)"
	//TypedKeyStringValueAnnotation TypedStringAnnotation:
	//	'@' name=ExtendedID '[' type=ExtendedID ']' values+=EStringAllTypes (',' values+=EStringAllTypes)*
	public AnnotationsGrammarAccess.TypedKeyStringValueAnnotationElements getTypedKeyStringValueAnnotationAccess() {
		return gaAnnotations.getTypedKeyStringValueAnnotationAccess();
	}
	
	public ParserRule getTypedKeyStringValueAnnotationRule() {
		return getTypedKeyStringValueAnnotationAccess().getRule();
	}

	//RestrictedTypedKeyStringValueAnnotation TypedStringAnnotation:
	//	'@' name=ExtendedID '[' type=ExtendedID ']' values+=EStringBoolean (',' values+=EStringBoolean)*
	public AnnotationsGrammarAccess.RestrictedTypedKeyStringValueAnnotationElements getRestrictedTypedKeyStringValueAnnotationAccess() {
		return gaAnnotations.getRestrictedTypedKeyStringValueAnnotationAccess();
	}
	
	public ParserRule getRestrictedTypedKeyStringValueAnnotationRule() {
		return getRestrictedTypedKeyStringValueAnnotationAccess().getRule();
	}

	//// QuotedKeyStringValueAnnotation
	//// The quoted key string value annotation is a replacement derived grammars may use
	//// if they want to disallow quote-less strings in a key string annotation. 
	//QuotedKeyStringValueAnnotation StringAnnotation:
	//	'@' name=ExtendedID values+=super::STRING (',' values+=super::STRING)*
	public AnnotationsGrammarAccess.QuotedKeyStringValueAnnotationElements getQuotedKeyStringValueAnnotationAccess() {
		return gaAnnotations.getQuotedKeyStringValueAnnotationAccess();
	}
	
	public ParserRule getQuotedKeyStringValueAnnotationRule() {
		return getQuotedKeyStringValueAnnotationAccess().getRule();
	}

	//// QuotedTypedKeyStringValueAnnotation
	//// The quoted typed key string value annotation is a replacement derived grammars may use
	//// if they want to disallow quote-less strings in a key string annotation. 
	//QuotedTypedKeyStringValueAnnotation TypedStringAnnotation:
	//	'@' name=ExtendedID '[' type=ExtendedID ']' values+=super::STRING (',' values+=super::STRING)*
	public AnnotationsGrammarAccess.QuotedTypedKeyStringValueAnnotationElements getQuotedTypedKeyStringValueAnnotationAccess() {
		return gaAnnotations.getQuotedTypedKeyStringValueAnnotationAccess();
	}
	
	public ParserRule getQuotedTypedKeyStringValueAnnotationRule() {
		return getQuotedTypedKeyStringValueAnnotationAccess().getRule();
	}

	//// EString
	//// Allow strings without quotes if they don't contain spaces.
	//// For quoteless strings the ExtendedID rule is used.
	//EString:
	//	super::STRING | ExtendedID;
	public AnnotationsGrammarAccess.EStringElements getEStringAccess() {
		return gaAnnotations.getEStringAccess();
	}
	
	public ParserRule getEStringRule() {
		return getEStringAccess().getRule();
	}

	//EStringBoolean:
	//	super::STRING | ExtendedID | BOOLEAN;
	public AnnotationsGrammarAccess.EStringBooleanElements getEStringBooleanAccess() {
		return gaAnnotations.getEStringBooleanAccess();
	}
	
	public ParserRule getEStringBooleanRule() {
		return getEStringBooleanAccess().getRule();
	}

	//EStringAllTypes:
	//	super::STRING | ExtendedID | BOOLEAN | Integer | Floateger;
	public AnnotationsGrammarAccess.EStringAllTypesElements getEStringAllTypesAccess() {
		return gaAnnotations.getEStringAllTypesAccess();
	}
	
	public ParserRule getEStringAllTypesRule() {
		return getEStringAllTypesAccess().getRule();
	}

	//// ExtendedID
	//// ExtendedID extends the ID rule provided by the terminals grammar.
	//// An ID may have dot separated parts and may close with a number separated by a hash mark.
	//ExtendedID:
	//	ID ("." ID)* ("#" INT)?;
	public AnnotationsGrammarAccess.ExtendedIDElements getExtendedIDAccess() {
		return gaAnnotations.getExtendedIDAccess();
	}
	
	public ParserRule getExtendedIDRule() {
		return getExtendedIDAccess().getRule();
	}

	//QualifiedID:
	//	ID ("." ID)*;
	public AnnotationsGrammarAccess.QualifiedIDElements getQualifiedIDAccess() {
		return gaAnnotations.getQualifiedIDAccess();
	}
	
	public ParserRule getQualifiedIDRule() {
		return getQualifiedIDAccess().getRule();
	}

	//// Integer
	//// The integer rule extends the EInt terminal by an optional sign for negative numbers.
	//Integer ecore::EInt:
	//	'-'? INT
	public AnnotationsGrammarAccess.IntegerElements getIntegerAccess() {
		return gaAnnotations.getIntegerAccess();
	}
	
	public ParserRule getIntegerRule() {
		return getIntegerAccess().getRule();
	}

	//// Floateger
	//// The floateger rule extends the EFloat terminal by an optional sign for negative numbers.
	//Floateger ecore::EFloat:
	//	'-'? FLOAT
	public AnnotationsGrammarAccess.FloategerElements getFloategerAccess() {
		return gaAnnotations.getFloategerAccess();
	}
	
	public ParserRule getFloategerRule() {
		return getFloategerAccess().getRule();
	}

	//terminal COMMENT_ANNOTATION:
	//	'/ **'->'* /';
	public TerminalRule getCOMMENT_ANNOTATIONRule() {
		return gaAnnotations.getCOMMENT_ANNOTATIONRule();
	} 

	//terminal ML_COMMENT:
	//	'/ *' !'*'->'* /';
	public TerminalRule getML_COMMENTRule() {
		return gaAnnotations.getML_COMMENTRule();
	} 

	//terminal fragment NUMBER:
	//	'0'..'9';
	public TerminalRule getNUMBERRule() {
		return gaAnnotations.getNUMBERRule();
	} 

	//terminal INT returns ecore::EInt:
	//	NUMBER+;
	public TerminalRule getINTRule() {
		return gaAnnotations.getINTRule();
	} 

	//terminal FLOAT returns ecore::EFloatObject:
	//	NUMBER+ ('.' NUMBER*) (("e" | "E") ("+" | "-")? NUMBER+)? 'f'? | NUMBER+ 'f';
	public TerminalRule getFLOATRule() {
		return gaAnnotations.getFLOATRule();
	} 

	//terminal BOOLEAN returns ecore::EBooleanObject:
	//	'true' | 'false';
	public TerminalRule getBOOLEANRule() {
		return gaAnnotations.getBOOLEANRule();
	} 

	//terminal ID:
	//	'^'? ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	} 

	//terminal SL_COMMENT:
	//	'//' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	} 

	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	} 

	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	} 
}
