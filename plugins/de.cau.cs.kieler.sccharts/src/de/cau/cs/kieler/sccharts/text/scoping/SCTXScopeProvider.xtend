/*
 * generated by Xtext
 */
package de.cau.cs.kieler.sccharts.text.scoping

import com.google.inject.Inject
import de.cau.cs.kieler.annotations.extensions.AnnotationsExtensions
import de.cau.cs.kieler.kexpressions.KExpressionsPackage
import de.cau.cs.kieler.kexpressions.Parameter
import de.cau.cs.kieler.kexpressions.ReferenceDeclaration
import de.cau.cs.kieler.kexpressions.ValuedObject
import de.cau.cs.kieler.kexpressions.VariableDeclaration
import de.cau.cs.kieler.kexpressions.extensions.KExpressionsDeclarationExtensions
import de.cau.cs.kieler.kexpressions.kext.scoping.KExtScopeProvider
import de.cau.cs.kieler.sccharts.ControlflowRegion
import de.cau.cs.kieler.sccharts.Region
import de.cau.cs.kieler.sccharts.SCCharts
import de.cau.cs.kieler.sccharts.SCChartsPackage
import de.cau.cs.kieler.sccharts.Scope
import de.cau.cs.kieler.sccharts.ScopeCall
import de.cau.cs.kieler.sccharts.State
import de.cau.cs.kieler.sccharts.Transition
import de.cau.cs.kieler.sccharts.extensions.SCChartsCoreExtensions
import de.cau.cs.kieler.sccharts.extensions.SCChartsInheritanceExtensions
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.scoping.IScope
import org.eclipse.xtext.scoping.Scopes
import org.eclipse.xtext.xbase.lib.Functions.Function1
import de.cau.cs.kieler.kexpressions.MethodDeclaration
import de.cau.cs.kieler.kexpressions.ValuedObjectReference
import de.cau.cs.kieler.sccharts.DataflowRegion
import de.cau.cs.kieler.kexpressions.AccessModifier

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 *
 */
class SCTXScopeProvider extends KExtScopeProvider {
    
    @Inject extension SCChartsCoreExtensions
    @Inject extension SCChartsInheritanceExtensions
    @Inject extension AnnotationsExtensions
    @Inject extension KExpressionsDeclarationExtensions
    
    @Inject SCTXQualifiedNameProvider nameProvider

    override getScope(EObject context, EReference reference) {
//        println(context + "\n  " + reference)
        
        switch(context) {
            Transition: return getScopeForTransition(context, reference)
            State: return getScopeForState(context, reference)
            Region: return getScopeForRegion(context, reference)
            ScopeCall: return getScopeForScopeCall(context, reference)  
        }
        
        return super.getScope(context, reference);
    }
    
    protected def IScope getScopeForTransition(Transition transition, EReference reference) {
        val states = <State> newArrayList
        val parentState = transition.eContainer as State
        val parentRegion = parentState.eContainer as ControlflowRegion
        
        parentRegion.states.forEach[ 
            states += it 
        ]
        
        return SCTXScopes.scopeFor(states)
    }
    
    protected def IScope getScopeForState(State state, EReference reference) {
        if (reference.name.equals("scope") || reference == SCChartsPackage.Literals.STATE__BASE_STATES) {
            return state.eResource.allAvailableRootStates
        }
        
        return super.getScope(state, reference)
    }
    
    protected def IScope getScopeForRegion(Region region, EReference reference) {
        if (reference.name.equals("scope")) {
            return SCTXScopes.scopeFor(region.nextSuperStateWithBaseStates.allVisibleInheritedRegions)
        }
        
        return super.getScope(region, reference)
    }
    
    protected def IScope getScopeForScopeCall(ScopeCall scopeCall, EReference reference) {
        if (reference.name.equals("scope")) {
            if (scopeCall.eContainer instanceof State) {
                return scopeCall.eResource.allAvailableRootStates
            } else if (scopeCall.eContainer instanceof Region) {
                return SCTXScopes.scopeFor((scopeCall.eContainer as Scope).nextSuperStateWithBaseStates.getAllVisibleInheritedRegions(!scopeCall.super))
            }
            
            return IScope.NULLSCOPE
        }
        
        return super.getScope(scopeCall as EObject, reference)
    }
        
    override IScope getScopeForParameter(Parameter parameter, EReference reference) {        
        if (reference.name.equals("explicitBinding")) {
            val voCandidates = <ValuedObject> newArrayList
            
            val scopeCall = parameter.eContainer as ScopeCall
            if (scopeCall !== null && scopeCall.scope !== null) {
                val scope = scopeCall.scope
                for (declaration : scope.variableDeclarations.filter[ input || output ]) {
                    voCandidates += declaration.valuedObjects
                }
                // Inherited Decls
                if (scope instanceof State) {
                    for (declaration : scope.allVisibleInheritedDeclarations.filter(VariableDeclaration).filter[ input || output ]) {
                        voCandidates += declaration.valuedObjects
                    }
                }
            }
            
            return SCTXScopes.scopeFor(voCandidates)
        }
        
        return super.getScopeForParameter(parameter, reference)
    }
    
    override def IScope getScopeForReferenceDeclaration(EObject context, EReference reference) {
        if (reference == KExpressionsPackage.Literals.REFERENCE_DECLARATION__REFERENCE) {
            
            val declaration = context
            if (declaration instanceof ReferenceDeclaration) {
                return declaration.eResource.allAvailableRootStates
            }
        } 
        return context.getScopeHierarchical(reference)
    }       

    override IScope getScopeHierarchical(EObject context, EReference reference) {
        val candidates = <ValuedObject> newArrayList
        var declarationScope = context.nextDeclarationScope
        while (declarationScope !== null) {
            for(declaration : declarationScope.declarations) {
                for(VO : declaration.valuedObjects) {
                    candidates += VO
                }
            }   
            
            // Add for regions counter variable            
            if (declarationScope instanceof Region) {
                if (declarationScope.counterVariable !== null) {
                    candidates += declarationScope.counterVariable
                }
            }
            
            // Inherited VOs
            if (declarationScope instanceof State) {
                if (!declarationScope.baseStates.nullOrEmpty) {
                    for (decl : declarationScope.allVisibleInheritedDeclarations) {
                        for(VO : decl.valuedObjects) {
                            candidates += VO
                        }
                    }
                }
            }
            
            declarationScope = declarationScope.nextDeclarationScope
        }
        return Scopes.scopeFor(candidates)
    }
    
    protected def getAllAvailableRootStates(Resource eResource) {
        if (eResource !== null) {
            val scchartsInScope = newHashSet(eResource.contents.head as SCCharts)
            val eResourceSet = eResource.resourceSet
            if (eResourceSet !== null) {
                eResourceSet.resources.filter[!contents.empty].map[contents.head].filter(SCCharts).forEach[ 
                    scchartsInScope += it
                ]
            }
            return SCTXScopes.scopeFor(scchartsInScope.map[rootStates].flatten)
        }
        return IScope.NULLSCOPE
    }
    
    override IScope getScopeForReferencedDeclarationObject(ReferenceDeclaration declaration, ValuedObjectReference context,
        Function1<? super VariableDeclaration, Boolean> predicate) {
        var EObject region = context
        while (region !== null && !(region instanceof Region)) {
            region = region.eContainer
        }
        val adjustedPredicate = if (region instanceof DataflowRegion) predicate else [VariableDeclaration vd | vd.access == AccessModifier.PUBLIC]
        if (declaration.reference instanceof State) {
            val state = declaration.reference as State
            val additionalCandidates = newArrayList
            additionalCandidates += state.declarations.filter(MethodDeclaration).map[valuedObjects.head]
            if (!state.baseStates.nullOrEmpty) {
                for (decl : state.allVisibleInheritedDeclarations) {
                    for(VO : decl.valuedObjects) {
                        additionalCandidates += VO
                    }
                }
            }
            return Scopes.scopeFor(additionalCandidates, super.getScopeForReferencedDeclarationObject(declaration, context, adjustedPredicate))
        } else {
            return super.getScopeForReferencedDeclarationObject(declaration, context, adjustedPredicate)
        }
    }

}
