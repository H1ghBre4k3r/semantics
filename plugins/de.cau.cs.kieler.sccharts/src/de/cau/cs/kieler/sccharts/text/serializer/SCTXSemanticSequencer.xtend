/*
 * generated by Xtext
 */
package de.cau.cs.kieler.sccharts.text.serializer

import com.google.inject.Inject
import de.cau.cs.kieler.annotations.StringPragma
import de.cau.cs.kieler.annotations.registry.PragmaRegistry
import de.cau.cs.kieler.kexpressions.Expression
import de.cau.cs.kieler.kexpressions.IntValue
import de.cau.cs.kieler.kexpressions.OperatorExpression
import de.cau.cs.kieler.sccharts.DelayType
import de.cau.cs.kieler.sccharts.HistoryType
import de.cau.cs.kieler.sccharts.Transition
import de.cau.cs.kieler.sccharts.text.services.SCTXGrammarAccess
import org.eclipse.xtext.serializer.ISerializationContext

import static de.cau.cs.kieler.kexpressions.OperatorType.*

/**
 * @author als
 * @kieler.design proposed
 * @kieler.rating proposed yellow
 */
class SCTXSemanticSequencer extends AbstractSCTXSemanticSequencer {
    
    /** Legacy transitions pragma keyword */
    static val LEGACY_TRANSITIONS_PRAGMA = PragmaRegistry.register("syntax", StringPragma, "Syntax switch for sctx language.")
    
    /** Legacy transitions keyword */
    static val LEGACY_TRANSITIONS_KEYWORD = "arrows"
    
    /** Flag for switching to legacy syntax */
    var boolean legacyTransitionSyntax = false
    
    @Inject
    private SCTXGrammarAccess grammarAccess;
    
    override sequence_StringPragma(ISerializationContext context, StringPragma pragma) {
        if (pragma.name.equals(LEGACY_TRANSITIONS_PRAGMA)) {
            legacyTransitionSyntax = pragma.values.contains(LEGACY_TRANSITIONS_KEYWORD)
        }
        super.sequence_StringPragma(context, pragma)
    }

    override sequence_Transition(ISerializationContext context, Transition transition) {
        val feeder = createSequencerFeeder(transition, createNodeProvider(transition))
        val tg = grammarAccess.transitionAccess
        
        for (idxAnnotation : transition.annotations.indexed) {
            feeder.accept(tg.annotationsRestrictedTypeAnnotationParserRuleCall_0_0, idxAnnotation.value, idxAnnotation.key)
        }
        
        // support legacy transitions
        if (legacyTransitionSyntax) {
            feeder.accept(tg.getPreemptionPreemptionTypeLegacyEnumRuleCall_1_0_1, transition.preemption)
        } else {
            feeder.accept(tg.preemptionPreemptionTypeEnumRuleCall_1_0_0, transition.preemption)
        }
        
        feeder.accept(tg.targetStateStateIDTerminalRuleCall_2_0_1, transition.targetState)
        
        if (transition.delay != DelayType.UNDEFINED) {
            feeder.accept(tg.delayDelayTypeEnumRuleCall_3_0, transition.delay)
        }
        
        if (transition.deferred) {
            feeder.accept(tg.deferredDeferredKeyword_4_0)
        }
        
        if (transition.history != HistoryType.RESET) {
            feeder.accept(tg.historyHistoryTypeEnumRuleCall_5_0, transition.history)
        }
        
        if (transition.trigger != null) {
            if (transition.triggerDelay > 1) {
                feeder.accept(tg.getTriggerDelayINTTerminalRuleCall_6_1_0, transition.triggerDelay)
            }
            
            // This handles separation of count delay together with expressions starting with an integer
            if (transition.triggerDelay == 1 && transition.trigger.requiresParentheses) {
                feeder.accept(tg.getTriggerAtomicExpressionParserRuleCall_6_2_1_0, transition.trigger)
            } else {
                feeder.accept(tg.getTriggerBoolExpressionParserRuleCall_6_2_0_0, transition.trigger)
            }
        }
        for (idxEffect : transition.effects.indexed) {
            if (idxEffect.key == 0) {
                feeder.accept(tg.getEffectsEffectParserRuleCall_7_1_0, idxEffect.value, idxEffect.key)
            } else {
                feeder.accept(tg.getEffectsEffectParserRuleCall_7_2_1_0, idxEffect.value, idxEffect.key)
            }
        }
        
        if (!transition.label.nullOrEmpty) {
            feeder.accept(tg.getLabelSTRINGTerminalRuleCall_8_1_0, transition.label)
        } 
                
        feeder.finish
    }
    
    private static val prefixOperators = newHashSet(NOT, PRE, VAL)
    
    private def boolean requiresParentheses(Expression exp) {
        if (exp instanceof IntValue) {
            return true
        } else if (exp instanceof OperatorExpression) {
            if (!prefixOperators.contains(exp.operator)) {
                return exp.subExpressions.head.requiresParentheses
            } else {
                return false
            }
        } else {
            return false
        }
    }

}
