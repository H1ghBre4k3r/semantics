/*
 * KIELER - Kiel Integrated Environment for Layout Eclipse RichClient
 * 
 * http://www.informatik.uni-kiel.de/rtsys/kieler/
 * 
 * Copyright 2015 by
 * + Kiel University
 *   + Department of Computer Science
 *     + Real-Time and Embedded Systems Group
 * 
 * This code is provided under the terms of the Eclipse Public License (EPL).
 * See the file epl-v10.html for the license text.
 */
package de.cau.cs.kieler.prom.templates

import com.google.common.base.Charsets
import com.google.common.io.Files
import com.google.common.io.LineProcessor
import de.cau.cs.kieler.prom.ModelImporter
import de.cau.cs.kieler.prom.data.FileData
import de.cau.cs.kieler.prom.data.MacroCallData
import freemarker.template.Template
import java.io.File
import java.io.FileFilter
import java.io.IOException
import java.io.StringWriter
import java.util.ArrayList
import java.util.List
import java.util.Map
import java.util.regex.Pattern
import org.eclipse.core.resources.IProject
import org.eclipse.core.runtime.CoreException
import org.eclipse.core.runtime.IConfigurationElement
import org.eclipse.core.runtime.Platform
import org.eclipse.emf.ecore.EObject
import org.eclipse.xtend.lib.annotations.Accessors

/**
 * This class generates wrapper code for models.
 * Annotations are mapped to macro calls which are injected in the input template.
 * Afterwards the macro calls are evaluated by the template engine and the wrapper code which they define is inserted.
 * 
 * @author aas
 */
class TemplateManager {

    /**
     * The id of the extension point for wrapper code annotation analyzers.
     */
    private static val MODEL_ANALYZER_EXTENSION_POINT_ID = "de.cau.cs.kieler.prom.modelAnalyzer"

    /**
     * List with all wrapper code annotation analyzers loaded from extensions.
     */
    private static var List<ModelAnalyzer> modelAnalyzers


    /**
     * A template variable which is replaced with the name of the last analyzed model.
     */
    public static val MODEL_NAME_VARIABLE = "model_name"
    /**
     * A template variable which is replaced with the names of the models.
     */
    public static val MODEL_NAMES_VARIABLE = "model_names"
    
    /**
     * A template variable which is replaced with the name of the file (without file extension)
     * that is created during wrapper code generation.
     */
    public static val FILE_NAME_VARIABLE = "file_name"
    
    /**
     * The variable name in the target template
     * for code generated by KiCo.
     */
    public static val KICO_GENERATED_CODE_VARIABLE = "kico_code"
    
    private static val declarationPhase = new CodeGenerationPhase("declaration", true, "decl")
    private static val initializationPhase = new CodeGenerationPhase("initialization", true, "init")
    private static val inputPhase = new CodeGenerationPhase("input", false)
    private static val outputPhase = new CodeGenerationPhase("output", false)
    private static val releasePhase = new CodeGenerationPhase("release", true, "free")

    public static var List<CodeGenerationPhase> codeGenerationPhases = #[declarationPhase, initializationPhase, inputPhase, outputPhase, releasePhase]

    /**
     * Macro definitions to use <@init>, <@input>, <@output> in wrapper code snippets.
     */
    public static var String macroDefinitions = null
    
    /**
     * The project
     */
    private IProject project

    /**
     * Constructor
     */
    new(IProject project) {
        this.project = project
    }
    
    /**
     * Generates wrapper code for a list of annotated model files.
     * 
     * @param templatePath The project relative path to the wrapper code template
     * @param datas The model files to generate wrapper code for
     */
    def public String generateWrapperCode(String templatePath, FileData... datas) {
        val List<MacroCallData> annotationDatas = newArrayList()
        var List<String> modelNames = newArrayList()
        var String modelName = ""
        for(data : datas) {
            val model = ModelImporter.load(data.getFile(project))
            getMacroCallData(model, annotationDatas)
            modelName = Files.getNameWithoutExtension(datas.get(0).name)
            modelNames += modelName
        }

        // Set model names
        val mapping = #{MODEL_NAME_VARIABLE -> modelName,
                        MODEL_NAMES_VARIABLE -> modelNames}
        generateWrapperCode(templatePath, annotationDatas, mapping)
    }
    
    /**
     * Generates wrapper code for a list of annotated model files.
     * 
     * @param templatePath The project relative path to the wrapper code template
     * @param annotationDatas The annotations that injected as macro calls
     */
    def public String generateWrapperCode(String templatePath, List<MacroCallData> annotationDatas) {
        generateWrapperCode(templatePath, annotationDatas, #{})
    }
    
    /**
     * Generates code by running the template engine on a template file.
     * 
     * @param templatePath The project relative path to the template
     * @param additionalMappings Additional mappings of placeholder variables to their corresponding values
     */
    def public String processTemplate(String templatePath, Map<String, Object> additionalMappings) {
        
        // Check consistency of path
        if (!templatePath.isNullOrEmpty()) {
            FreemarkerConfiguration.newConfiguration(project.location.toOSString)
            
            val template = FreemarkerConfiguration.configuration.getTemplate(templatePath)

            val writer = new StringWriter()
            template.process(additionalMappings, writer)
    
            return writer.toString()
        }
        return ""
    }
    
    /**
     * Generates wrapper code for a list of annotated model files.
     * 
     * @param templatePath The project relative path to the wrapper code template
     * @param additionalMappings Additional mappings of placeholder variables to their corresponding values
     * @param annotationDatas The annotations that injected as macro calls
     */
    def public String generateWrapperCode(String templatePath, List<MacroCallData> annotationDatas, Map<String, Object> additionalMappings) {

        // Check consistency of path
        if (!templatePath.isNullOrEmpty()) {
            val templateWithMacroCalls = getTemplateWithMacroCalls(templatePath, annotationDatas)
            
            // Debug log macro calls
//            System.err.println(templateWithMacroCalls)

            // Create mappings
            val map = <String, Object> newHashMap
            
            // Add name of model 
            if(!map.containsKey(MODEL_NAME_VARIABLE)) {
                val modelName = annotationDatas.get(0).modelName
                map.put(MODEL_NAME_VARIABLE, modelName)
                map.put(MODEL_NAMES_VARIABLE, #[modelName])
            }
            
            // Add name of output file 
            if(!map.containsKey(FILE_NAME_VARIABLE)) {
                val fileName = new File(templatePath).name
                val fileNameWithoutExtension = Files.getNameWithoutExtension(fileName)
                map.put(FILE_NAME_VARIABLE, fileNameWithoutExtension)
            }
            
            // Add additional mappings
            if(additionalMappings != null) {
                map.putAll(additionalMappings)
            }
        
            // Process template with macro calls and the mappings created above
            val wrapperCode = processTemplateWithSnippetDefinitions(templateWithMacroCalls, map)
            return wrapperCode
        }
        return ""
    }
            
    /**
     * Searches for wrapper code annotations in the models
     * and injects macro calls accordingly in the template.
     * 
     * @param templatePath The project relative path to the wrapper code template
     * @param additionalMappings Additional mappings of placeholder variables to their corresponding values
     * @param annotationDatas The annotations that injected as macro calls
     * @return a String with the input template's wrapper code
     * plus injected macro calls from annotations of the given files.
     */
    private def String getTemplateWithMacroCalls(String templatePath, List<MacroCallData> annotationDatas) {
        
        // Create macro calls from annotations
        val map = getMacroCalls(annotationDatas)
        
        // Inject macro calls in input template
        val lineProcessor = new LineProcessor<String>() {
            String text = ""
            
            override getResult() {
                return text
            }
            
            override processLine(String line) throws IOException {
                // Replace placeholders in the line
                // Freemarker should process the templates only after the macro calls have been injected.
                // Otherwise things like includes are processed, not needed in this case, yet gone in the next iteration,
                // in which macro calls should be processed.
                // Thus, injecting the macro calls is done here, before Freemarker is used.
                var lineWithoutPlaceholders = line
                for(entry : map.entrySet) {
                    val placeholderRegex = Pattern.quote("${"+entry.key+"}")
                    lineWithoutPlaceholders = lineWithoutPlaceholders.replaceAll(placeholderRegex, entry.value)
                }
                text += lineWithoutPlaceholders+"\n"
                // Continue reading the lines
                return true
            }
        }
        val templateText = Files.readLines(new File(project.location.append(templatePath).toOSString),
                                           Charsets.UTF_8,
                                           lineProcessor)
        return templateText
    }

    /**
     * Processes the given template and saves the output to the target location of this generator.
     * The template is processed using all macro definitions from the wrapper code snippet directory.
     * 
     * @param templateWithMacroCalls The template text to be processed 
     */
    private def String processTemplateWithSnippetDefinitions(String templateWithMacroCalls, Map<String, Object> additionalMappings) {
        
        FreemarkerConfiguration.newConfiguration(project.location.toOSString)
        
        // Add implicit include of assignment macros such as <@init> and <@output>
        FreemarkerConfiguration.stringTemplateLoader.putTemplate("assignmentMacros", getOrInitializeMacroDefinitions() )
        FreemarkerConfiguration.configuration.addAutoInclude("assignmentMacros")
        
        // Process template with macro calls and now implicitly loaded snippet definitions.
        val template = new Template("templateWithMacroCalls", templateWithMacroCalls, FreemarkerConfiguration.configuration)

        // Process template and write output in string
        val map = if(additionalMappings != null)
                      additionalMappings
                  else
                    newHashMap
        val writer = new StringWriter()
        template.process(map, writer)
        writer.close()
        return writer.toString
    }

    /**
     * Initializes the macro definitions when they are not yet initialized.
     * Afterwards they are returned.
     * 
     * @return the macro definitions of assignment macros such as <@input>
     */
    private def String getOrInitializeMacroDefinitions() {
        // Initialize if not done yet
        if(macroDefinitions == null){
            macroDefinitions = ""
            
            for(phase : codeGenerationPhases ){
                for(macro : phase.macros){
                    macroDefinitions += macro.freeMarkerDefinition
                    macroDefinitions += "\n"
                }                
            }
        }
        return macroDefinitions
    }
    
    /**
     * Creates macro calls from wrapper code annotation datas.
     * 
     * @param annotationDatas List with the datas to generate macro calls for 
     * @return a map where the keys 'inits', 'inputs' and 'outputs'
     *         are mapped to the corresponding macro calls for the given annotations.
     */
    private def Map<String, String> getMacroCalls(MacroCallData... annotationDatas) {
        val Map<String, String> map = newHashMap
        if(annotationDatas.isNullOrEmpty) {
            // Set the macro value for all placeholders (e.g. ${inputs}, ${outputs}) to the empty string,
            // because there are no annotations to inject.
            for(phase : codeGenerationPhases) {
                for(macro : phase.macros) {
                    map.put(macro.name+"s", "")
                }
            }
            return map
        }
        // The assignment macros such as <@init> and <@output> use a variable
        // to determine if their snippet should be inserted.
        for(phase : codeGenerationPhases) {
            phase.macroCallsToInject = phase.freeMarkerAssignment+"\n"
        }

        // Keep track of the annotations that were already seen before in this collection
        val doneAnnotations = new ArrayList<MacroCallData>()
        var boolean isAnnotationDoneAlready
        
        // Add macro calls for annotations to the different phases
        var MacroCallData prev = null; 
        for (data : annotationDatas) {
            
            isAnnotationDoneAlready = true
            if (!doneAnnotations.contains(data)) {
                doneAnnotations.add(data)
                isAnnotationDoneAlready = false
            }

            for(phase : codeGenerationPhases) {
                // We initialize every annotation only once
                // although the same annotation might be used twice: as input and output.
                if(!phase.isUsesAnnotationsOnce || (phase.isUsesAnnotationsOnce && !isAnnotationDoneAlready) ) {
                    // Use input annotations on inputs only, and output annotations on outputs only
                    if(phase.isApplicable(data)) {
                        // The macro of this annotation should be called in this phase
                        phase.macroCallsToInject += getTemplateCodeForAnnotation(data)
                    }
                }
            }
            prev = data;
        }

        // Send FreeMarker the text to replace the placeholder of each phase
        for(phase : codeGenerationPhases) {
            for(macro : phase.macros) {
                // Calling the phase in the template is possible by
                // using the name of the assignment macro with an 's' added
                // (e.g. ${declarations} for <@declaration>)
                map.put(macro.name+"s", phase.macroCallsToInject)
            }
        }
        return map
    }

    /**
     * Creates meta assignments and macro calls for an wrapper code annotation data.
     * 
     * @param data The annotation data
     * @return a string to set information about the variable which the annotation is used for.
     *         as well as the macro call for the annotation.    
     */
    private static def String getTemplateCodeForAnnotation(MacroCallData data) {
        return getMetaAssignments(data) + getMacroCall(data);
    }

    /**
     * Creates a statements that sets meta information about the next variable to be used.
     * 
     * @param data The wrapper code annotation data 
     * @return a string which globally sets meta information.  
     */
    private static def String getMetaAssignments(MacroCallData data) {
        return '''<#assign varname = '«data.varName»' vartype = '«data.varType»' />'''+"\n"
    }

    /**
     * Creates a statement that calls a macro to generate code for the wrapper code annotation data.
     * 
     * @param data The wrapper code annotation data
     * @return a string with the macro call for an wrapper code annotation data.
     */
    private static def String getMacroCall(MacroCallData data) {
        var txt = ""
        // Ignore non existing macro <=> only call if macro exists
        if (data.ignoreNonExistingSnippet)
            txt += '''<#if «data.name»??>'''

        txt += '''<@«data.name» '''
        // Append arguments
        var boolean isBooleanArgument
        var boolean isFloatArgument
        for (String arg : data.arguments) {
            isBooleanArgument = (arg.equalsIgnoreCase("true") || arg.equalsIgnoreCase("false"))
            try {
                isFloatArgument = (Float.valueOf(arg) != null)
            } catch (NumberFormatException e) {
                isFloatArgument = false
            }
            val isNonStringArgument = isBooleanArgument || isFloatArgument
            // Only string arguments need to be surrounded by single quotation marks
            if(isNonStringArgument)
                txt += '''«arg» '''   
            else 
                txt += ''''«arg»' '''
        }
        // Close macro call
        txt += '''/>''';

        // Close if
        if (data.ignoreNonExistingSnippet)
            txt += '''</#if>'''
        
        txt += "\n"

        return txt
    }

    /**
     * Searches for files of a given file extension in a directory and sub directories.
     * 
     * @param folder The directory to start the search in
     * @param fileExtension A file extension that found files must match
     * @return a list with file handles for the found files.
     */
    private def List<File> getFilesRecursive(File folder, String fileExtension) {
        // Filter that accepts directories and files with the given extension.
        val filter = new FileFilter() {
            override accept(File file) {
                return file.isDirectory || Files.getFileExtension(file.name).equalsIgnoreCase(fileExtension)
            }
        }

        // Get files
        val list = new ArrayList<File>()
        getFilesRecursiveHelper(folder, list, filter)
        return list
    }

    /**
     * Auxilary method for getFilesRecursive(...).
     * Searches for files in the given folder and recursive in all sub folders.
     * Each file which is not filtered is added to the list.
     * 
     * @param folder the current folder to be searched for files
     * @param list A list of found files
     * @param filter A filter that found files must match
     */
    private def void getFilesRecursiveHelper(File folder, List<File> list, FileFilter filter) {
        // Iterate over files in the folder.
        // Add found files and remember folders for later.
        val subFolders = newArrayList()
        for (fileEntry : folder.listFiles(filter)) {
            if (fileEntry.isDirectory()) {
                subFolders += fileEntry
            } else {
                list.add(fileEntry)
            }
        }
        
        // Go into next folder level
        for (subFolder : subFolders) {
            getFilesRecursiveHelper(subFolder, list, filter);
        }
    }

    /**
     * Fetches all annotation datas from the file data in the given project
     * 
     * @param project the project
     * @param data the FileData with information which model file will be analyzed
     * @return the annotation datas
     */
    public static def List<MacroCallData> getMacroCallData(IProject project, FileData data) {
        val List<MacroCallData> annotationDatas = newArrayList()
        val model = ModelImporter.load(data.getFile(project))
        getMacroCallData(model, annotationDatas)
        return annotationDatas
    }

    /**
     * Adds wrapper code data objects to the annotationDatas list,
     * which where found in the given files.
     * 
     * @param data File data holding a path to a model file
     * @param annotationDatas List to add found annotation datas to
     */
    public static def String getModelName(EObject model) {
        // Load EObject from file
        if (model != null) {
            initAnalyzers()
            
            // Analyze the model with all wrapper code annotation analyzers
            for (analyzer : TemplateManager.modelAnalyzers) {
                val modelName = analyzer.getModelName(model)
                if(modelName != null) {
                    return modelName
                }
            }

        }
    }

    /**
     * Adds wrapper code data objects to the annotationDatas list,
     * which where found in the given files.
     * 
     * @param data File data holding a path to a model file
     * @param annotationDatas List to add found annotation datas to
     */
    public static def void getMacroCallData(EObject model,
        List<MacroCallData> annotationDatas) {

        // Load EObject from file
        if (model != null) {
            initAnalyzers()
            
            // Analyze the model with all wrapper code annotation analyzers
            for (analyzer : TemplateManager.modelAnalyzers) {
                val annotations = analyzer.getAnnotationInterface(model)
                if (annotations != null) {
                    annotationDatas.addAll(annotations)    
                }
            }

        }
    }
    
    /**
     * Looks for the interface (inputs / outputs) in the model
     * and based on this, creates data objects suited for simulation of the model.
     * 
     * @param model The model
     * @param datas List to add found datas objects to
     */
    public static def void getSimulationInterfaceData(EObject model,
        List<MacroCallData> simulationDatas) {

        // Load EObject from file
        if (model != null) {
            initAnalyzers()
            
            // Analyze the model with all wrapper code annotation analyzers
            for (analyzer : TemplateManager.modelAnalyzers) {
                val datas = analyzer.getSimulationInterface(model)
                if (!datas.isNullOrEmpty) {
                    simulationDatas.addAll(datas)    
                }
            }

        }
    }
    
    /**
     * Load and initialize wrapper code annotation analyzers from all implementing extensions
     * if not yet done.
     */
    private static def void initAnalyzers(){
        if(TemplateManager.modelAnalyzers == null){
            // Initialize list
            TemplateManager.modelAnalyzers = newArrayList()
            
            // Fill list with wrapper code annotation analyzers from extensions.
            val config = Platform.getExtensionRegistry().getConfigurationElementsFor(TemplateManager.MODEL_ANALYZER_EXTENSION_POINT_ID);
            try {
                for (IConfigurationElement e : config) {
                    val o = e.createExecutableExtension("class");
                    if (o instanceof ModelAnalyzer) {
                        TemplateManager.modelAnalyzers += o
                    }
                }
            } catch (CoreException ex) {
                System.err.println(ex.getMessage());
            }
        }
    }
    
    ///////////////////////////////////////////////////////////////////////////////////////////////////
    // New Class
    ///////////////////////////////////////////////////////////////////////////////////////////////////
    /**
     * Class to define the phases for which wrapper code is used and thus to define which macro calls
     * need to be injected in the template.
     */
    public static class CodeGenerationPhase {
        
        /**
         * The unique name of this phase.
         * Used to identify which phase is currently active in the template.
         */
        @Accessors(PUBLIC_GETTER)
        private var String name
        
        /**
         * Defines if the same annotation may be used multiple times in this phase.
         * (e.g. the same annotation should be initialized only once
         * but may be used multiple times: as input and output) 
         */
        private boolean isUsesAnnotationsOnce
        
        /**
         * The list of assignment macros that will insert its content as part of this phase.
         * (e.g. <@init> as well as <@initialization> will insert its content as part of the initialization phase)
         */
        private val List<AssignmentMacro> macros = newArrayList();
        
        /**
         * A variable to calculate the assignments and macros,
         * which should be injected in this phase for the current wrapper code generation launch.
         */
        @Accessors
        private var String macroCallsToInject
        
        /**
         * Constructor.
         * 
         * @param name The unique name of the phase.
         * @param isUsesAnnotationsOnce Defines whether the same annotation may be used multiple times in this phase
         * @param alternativeMacroNames A list of macro names that should be equiivalent to the macro with the same name as this phase. 
         */
        new(String name, boolean isUsesAnnotationsOnce, String... alternativeMacroNames) {
            this.name = name
            this.isUsesAnnotationsOnce = isUsesAnnotationsOnce
            
            // Create macros
            this.macros += new AssignmentMacro(name, this)
            for(alternativeMacroName : alternativeMacroNames) {
                this.macros += new AssignmentMacro(alternativeMacroName, this)
            }
        }
        
        /**
         * The FreeMarker assignment statement which will set this phase as active.
         */
        public def getFreeMarkerAssignment() '''
            <#assign phase='«name»' />
        '''
        
        /**
         * Returns the list of assignment macros, which will insert its content as part of this phase.
         * 
         * @return the list of assignment macros for this phase.
         */
        public def getMacros(){
            return macros
        }
        
        /**
         * Checks if the snippet definition for the annotation should be inserted as part of this phase.
         * 
         * @return true if the snippet definition for the annotation should be inserted as part of this phase.
         */
        public def boolean isApplicable(MacroCallData data){
            return data.phases.contains(name)
        }
    }
    
    ///////////////////////////////////////////////////////////////////////////////////////////////////
    // New Class
    ///////////////////////////////////////////////////////////////////////////////////////////////////
    /**
     * Class to define assignment macros that will insert their content as part of a given phase. 
     */
    private static class AssignmentMacro {
        /**
         * The name for the macro
         */
        private var String name;
        
        /**
         * The phase in which the content of this macro should be used
         */
        private var CodeGenerationPhase phase;
        
        /**
         * Constructor.
         * 
         * @param name The name
         * @param phase The phase
         */
        new(String name, CodeGenerationPhase phase) {
            this.name = name
            this.phase = phase
        }
        
        /**
         * The definition of this assignment macro for the FreeMarker template engine.
         * 
         * @return the FreeMarker definition of this assignment macro
         */
        def getFreeMarkerDefinition() '''
            <#macro «name»>
                <#if phase=='«phase.name»'>
                    <#nested />
                </#if>
            </#macro>
        '''
    }
}