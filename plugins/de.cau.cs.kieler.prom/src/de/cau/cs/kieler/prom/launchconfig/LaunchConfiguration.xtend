/*
 * KIELER - Kiel Integrated Environment for Layout Eclipse RichClient
 *
 * http://www.informatik.uni-kiel.de/rtsys/kieler/
 * 
 * Copyright 2015 by
 * + Kiel University
 *   + Department of Computer Science
 *     + Real-Time and Embedded Systems Group
 * 
 * This code is provided under the terms of the Eclipse Public License (EPL).
 * See the file epl-v10.html for the license text.
 */
package de.cau.cs.kieler.prom.launchconfig

import com.google.common.base.Strings
import de.cau.cs.kieler.kico.KielerCompiler
import de.cau.cs.kieler.kico.KielerCompilerContext
import de.cau.cs.kieler.prom.common.ExtensionLookupUtil
import de.cau.cs.kieler.prom.common.FileCompilationData
import de.cau.cs.kieler.prom.common.KiCoLaunchData
import de.cau.cs.kieler.prom.common.ModelImporter
import de.cau.cs.kieler.prom.common.PromPlugin
import freemarker.template.Configuration
import freemarker.template.Template
import freemarker.template.TemplateExceptionHandler
import freemarker.template.Version
import java.io.File
import java.io.FileReader
import java.io.FileWriter
import java.io.PrintWriter
import org.eclipse.core.resources.IProject
import org.eclipse.core.resources.IResource
import org.eclipse.core.resources.ResourcesPlugin
import org.eclipse.core.runtime.CoreException
import org.eclipse.core.runtime.IProgressMonitor
import org.eclipse.core.runtime.IStatus
import org.eclipse.core.runtime.Path
import org.eclipse.core.runtime.Status
import org.eclipse.core.runtime.jobs.Job
import org.eclipse.core.variables.IStringVariableManager
import org.eclipse.core.variables.VariablesPlugin
import org.eclipse.debug.core.ILaunch
import org.eclipse.debug.core.ILaunchConfiguration
import org.eclipse.debug.core.model.ILaunchConfigurationDelegate
import org.eclipse.emf.ecore.EObject
import org.eclipse.jdt.core.IClasspathEntry
import org.eclipse.jdt.core.IJavaProject
import org.eclipse.jdt.core.JavaCore
import org.eclipse.jface.viewers.StructuredSelection
import org.eclipse.swt.widgets.Display
import org.eclipse.ui.console.ConsolePlugin
import org.eclipse.ui.console.MessageConsole
import org.eclipse.ui.console.MessageConsoleStream
import org.eclipse.xtend.lib.annotations.Accessors

/**
 * Implementation of a launch configuration that uses KiCo.
 * 
 * @author aas
 */
class LaunchConfiguration implements ILaunchConfigurationDelegate {

    /**
     * The extension id of this launch config type.
     * It is set in the plugin.xml.
     */
    public static val LAUNCH_CONFIGURATION_TYPE_ID = "de.cau.cs.kieler.prom.launchconfig.launchConfiguration"

    /**
     * The id for the wrapper code generator extension point.
     */
    public static val WRAPPER_CODE_GENERATOR_EXTENSION_POINT_ID = "de.cau.cs.kieler.prom.wrapperCodeGenerator"

    /**
     * The variable name in the target template
     * for code generated by KiCo.
     */
    public static val COMPILED_CODE_PLACEHOLDER = "kico_code"

    /**
     * The directory in which compiled output of this launch will be saved per default.
     */
    public static val BUILD_DIRECTORY = "kieler-gen"

    // Attribute names
    public static val ATTR_COMMANDS = "de.cau.cs.kieler.prom.launchconfig.commands"
    public static val ATTR_FILES = "de.cau.cs.kieler.prom.launchconfig.files"
    public static val ATTR_ENVIRONMENT = "de.cau.cs.kieler.prom.launchconfig.main.environment"

    // Variable names
    public static val LAUNCHED_PROJECT_VARIABLE = "launched_project_loc"

    public static val MAIN_FILE_NAME_VARIABLE = "main_name"
    public static val MAIN_FILE_PATH_VARIABLE = "main_path"
    public static val MAIN_FILE_LOCATION_VARIABLE = "main_loc"
    public static val MAIN_FILE_NAME_WITHOUT_FILE_EXTENSION_VARIABLE = "main_name_no_ext"

    public static val COMPILED_MAIN_FILE_NAME_VARIABLE = "compiled_main_name"
    public static val COMPILED_MAIN_FILE_PATH_VARIABLE = "compiled_main_path"
    public static val COMPILED_MAIN_FILE_LOCATION_VARIABLE = "compiled_main_loc"
    public static val COMPILED_MAIN_FILE_NAME_WITHOUT_FILE_EXTENSION_VARIABLE = "compiled_main_name_no_ext"

    private IStringVariableManager variableManager

    // Message console
    private static val CONSOLE_NAME = "KiCo Compilation"
    private static MessageConsole console;
    private static MessageConsoleStream consoleStream;

    // Jobs
    private Job compileJob;
    private Job wrapperCodeJob;
    
    // Objects from launch
    @Accessors
    private ILaunchConfiguration configuration
    @Accessors
    private String mode
    @Accessors
    private ILaunch launch
    @Accessors
    private IProgressMonitor monitor

    // Objects loaded from configuration
    @Accessors
    private IProject project

    @Accessors
    private KiCoLaunchData launchData

    /**
     * {@inheritDoc}
     */
    override void launch(ILaunchConfiguration configuration, String mode, ILaunch launch,
        IProgressMonitor monitor) throws CoreException {
        this.configuration = configuration
        this.mode = mode
        this.launch = launch
        this.monitor = monitor
        
        // Load variable manager
        this.variableManager = VariablesPlugin.getDefault.stringVariableManager

        // Init console for errors and messages
        clearConsole()

        // Get data from config.
        loadSettingsFromConfiguration()

        if (project != null) {

            // Set variables (e.g. launched_project_loc, main_name, main_loc, ...)
            setVariables()

            // Create directory for output if there is none yet
            createBuildDirectory()

            // Create jobs.
            compileJob = getCompileJob()
            wrapperCodeJob = getWrapperCodeGenerationJob()

            // Start jobs.
            compileJob.schedule()
            wrapperCodeJob.schedule()

            // Wait for the jobs to finish.
            compileJob.join()
            wrapperCodeJob.join()
            
            // Proceed only if the other jobs succeded  
            if (compileJob.result.code == IStatus.OK && wrapperCodeJob.result.code == IStatus.OK) {
                // Refresh output directory
                if(!launchData.targetDirectory.isNullOrEmpty()) {
                    project.getFolder(launchData.targetDirectory).refreshLocal(IResource.DEPTH_INFINITE, monitor)
                } else {
                    // Refresh directories of files
                    for(fileData : launchData.files) {
                        var dir = new Path(fileData.projectRelativePath).removeTrailingSeparator.toOSString
                        if(dir.startsWith("/") || dir.startsWith("\\")) {
                            dir = dir.substring(1)    
                        }
                        val fullPath = project.name + File.separator + dir
                        val folder = project.getFolder(fullPath)
                        if(folder.exists)
                            folder.refreshLocal(IResource.DEPTH_INFINITE, monitor)
                    }
                }
                
                // Run associated launch shortcut
                runAssociatedLauchShortcut()
                
                // Execute command list 
                getExecuteCommandsJob().schedule()
            }
        } else {
            writeToConsole("Project of launch configuration '" + configuration.name +
                "' does not exist.\n");
        }
    }

    /**
     * Initializes all variables that are used in the launch configuration if they have not been initialized yet.
     */
    public static def void initializeVariables() {
        val variableManager = VariablesPlugin.getDefault.stringVariableManager
        // Check if variables have been initialized already
        var variable = variableManager.getValueVariable(LaunchConfiguration.MAIN_FILE_NAME_VARIABLE)
        // Instantiate all variables if none yet
        if (variable == null) {
            // Project
            initializeVariable(LaunchConfiguration.LAUNCHED_PROJECT_VARIABLE,
            "Fully qualified path to the launched application")
    
            // Main file
            initializeVariable(LaunchConfiguration.MAIN_FILE_NAME_VARIABLE,
                "Name of the main file of the launched application")
            initializeVariable(LaunchConfiguration.MAIN_FILE_LOCATION_VARIABLE,
                "Fully qualified location of the main file of the launched application")
            initializeVariable(LaunchConfiguration.MAIN_FILE_PATH_VARIABLE,
                "Project relative path of the main file of the launched application")
            initializeVariable(LaunchConfiguration.MAIN_FILE_NAME_WITHOUT_FILE_EXTENSION_VARIABLE,
                "Project relative path of the main file of the launched application without file extension")
            
            // Compiled main file
            initializeVariable(LaunchConfiguration.COMPILED_MAIN_FILE_NAME_VARIABLE,
                "Name of the compiled main file of the launched application")
            initializeVariable(LaunchConfiguration.COMPILED_MAIN_FILE_LOCATION_VARIABLE,
                "Fully qualified location of the compiled main file of the launched application")
            initializeVariable(LaunchConfiguration.COMPILED_MAIN_FILE_PATH_VARIABLE,
                "Project relative path of the compiled main file of the launched application")
            initializeVariable(LaunchConfiguration.COMPILED_MAIN_FILE_NAME_WITHOUT_FILE_EXTENSION_VARIABLE,
                "Project relative path of the compiled main file of the launched application without file extension")
        }
    }

    /**
     * Writes to the console view for a KiCo launch.
     * @param message The message to print to the console
     */
    public static def void writeToConsole(String message){
        // If there is nothing to write, we are done immediately.
        if(message.isNullOrEmpty())
            return;
        
        // Ensure the console exists.
        initializeConsole()
        
        // Print message
        consoleStream.println(message)
        
        // Bring console to front
        val consoleManager = ConsolePlugin.getDefault().getConsoleManager();
        consoleManager.showConsoleView(console)
    }

    public static def void writeToConsole(Exception e){
        // Write exception to console of running Eclipse
        var text = ""
        text += Strings.nullToEmpty(e.toString())
        if(text.length > 0 )
            text += ":"
        text += Strings.nullToEmpty(e.message)
        writeToConsole(text)
        
        // Print stack trace
        e.printStackTrace()
    }
    
    
    /**
     * Creates the folder in which compilation results will be saved. 
     */
    private def void createBuildDirectory() {
        // If the target directory is empty
        // the output will be saved in the same folder as the input files,
        // so we don't need to create them.
        if(!launchData.targetDirectory.isNullOrEmpty()) {
            val folder = project.getFolder(launchData.targetDirectory)
            if(!folder.exists) {
                folder.create(false, true, null)
                // Add folder to java class path if it is a java project
                if (project.hasNature(JavaCore.NATURE_ID)) {
                    val javaProject = JavaCore.create(project);
                    PromPlugin.addFolderToJavaClasspath(javaProject, folder)
                }                
            }
        }
    }
    
    /**
     * Runs the associated launch shortcut on the compiled main file.
     * E.g. one may want to launch a file as "Java Application" after KiCo compilation finished. 
     */
    private def void runAssociatedLauchShortcut() {
        // Nothing to do
        if(launchData.mainFile.isNullOrEmpty() || launchData.associatedLaunchShortcut.isNullOrEmpty()) {
            return;
        }
        
        // Start associated launch shortcut on compiled main file
        val compiledMainPath = new Path(computeTargetPath(launchData.mainFile, true))
        val compiledMainFile = project.getFile(compiledMainPath)
        val selection = new StructuredSelection(compiledMainFile)
        val shortcut = ExtensionLookupUtil.getLaunchShortcut(launchData.associatedLaunchShortcut);
        
        if(shortcut == null) {
            throw new Exception("The associated launch shortcut "+launchData.associatedLaunchShortcut+
                                " for the launch configuration '"+configuration.name +"' could not be instantiated.")
        }
        
        // There is an "invalid thread access" exception if this asyncExec is not used.
        Display.getDefault().asyncExec(new Runnable() {
           override run() {
              shortcut.launch(selection, mode)
           }
       })
    }

    /**
     * Creates a job that compiles a list of FileCompildationData via KiCo.
     * 
     * @return the created job.
     */
    private def Job getCompileJob() {

        return new Job("KiCo Compilation") {
            override protected IStatus run(IProgressMonitor monitor) {

//                val startTime = System.currentTimeMillis()

                try {
                    for (data : launchData.files) {
                        compile(data)

                        if (monitor.isCanceled())
                            return Status.CANCEL_STATUS
                    }
                } catch (Exception e) {
                    // Remove this try-catch to notify the user with a popup window.
                    writeToConsole(e)
                    return Status.CANCEL_STATUS
                }

                // Debug info about duration
//                System.err.println("Compilation finished after " + (System.currentTimeMillis() - startTime) + "ms")

                return Status.OK_STATUS
            }
        }
    }

    /**
     * Creates a job that generates and saves the wrapper code for a list of FileCompilationData.
     * 
     * @return the created job. 
     */
    private def Job getWrapperCodeGenerationJob() {
        val launchConfig = this        
        
        return new Job("Wrapper Code Generation") {
            override protected IStatus run(IProgressMonitor monitor) {

//                val startTime = System.currentTimeMillis()

                try {
                    // Create wrapper code
                    val generator = new WrapperCodeGenerator(launchConfig)
                    generator.generateWrapperCode(launchData.files)
                } catch (Exception e) {
                    writeToConsole(e)
                    return Status.CANCEL_STATUS
                }

                // Debug info about duration
//                System.err.println(
//                    "Wrapper Code generation finished after " + (System.currentTimeMillis() - startTime) + "ms")

                return Status.OK_STATUS
            }
        }
    }
    
    /**
     * Creates a job that executes the commands for this launch config successively.
     * 
     * @return the created job.
     */
    private def Job getExecuteCommandsJob() {
        val launchConfig = this
        
        return new Job("Command Execution") {
            
            override protected run(IProgressMonitor monitor) {
                try {
                    val executor = new CommandExecutor(launchConfig)
                    executor.execute(launchData.commands)
                    return Status.OK_STATUS
                } catch (Exception e) {
                    writeToConsole(e)
                    return Status.CANCEL_STATUS
                }
            }
        }
    }

    /**
     * Compile a file via KiCo and save the result.
     * 
     * @param data The file to be compiled
     */
    private def void compile(FileCompilationData data) {
        // Load model from file
        val EObject model = ModelImporter.load(project.location.toOSString + File.separator + data.projectRelativePath, true)

        if (model != null) {
            // Get compiler context with settings for KiCo
            // TODO: ESTERELSIMULATIONVISUALIZATION throws an exception when used (21.07.2015), so we explicitly disable it.
            // TODO: SIMULATIONVISUALIZATION throws an exception when used (28.10.2015), so we explicitly disable it.
            val context = new KielerCompilerContext("!T_ESTERELSIMULATIONVISUALIZATION, !T_SIMULATIONVISUALIZATION, T_" + launchData.targetLanguage, model)
            context.inplace = false
            context.advancedSelect = true

            // Compile
            val result = KielerCompiler.compile(context)

            // Flush compilation result to target
            if (result.allErrors.isNullOrEmpty() && result.allWarnings.isNullOrEmpty() && !result.string.isNullOrEmpty() ) {
                saveCompilationResult(result.string, computeTargetPath(data.projectRelativePath, false))
            } else {
                var errorMessage = "Compilation of '" + data.name + "' failed:\n\n" +
                                   Strings.nullToEmpty(result.allErrors) + "\n" +
                                   Strings.nullToEmpty(result.allWarnings)

                throw new Exception(errorMessage)
            }
        }
    }

    /**
     * Computes the fully qualified target path for a project relative file path.
     * The target path is in the build directory for kico compiled files and in this directory
     * has the same directory structure as the original file in the project.
     * The file extension of the target path is the extension for the current target language.
     * 
     * @param projectRelativePath Project relative path of a file in the project
     * @param projectRelative Flag to specify if the computed path should be projectRelative or not
     * @return the computed path
     */
    public def String computeTargetPath(String projectRelativePath, boolean projectRelative) {
        var String projectRelativeTargetPath;
        if(launchData.targetDirectory.isNullOrEmpty()) {
            // Compute path such that the target file will be in the same file as the source file.
            projectRelativeTargetPath = new Path(projectRelativePath).removeFileExtension.toOSString + launchData.targetLanguageFileExtension
        } else {
            // Compute path in the target directory
            // such that the directory structure of the original file is retained.
            var String projectRelativeRelevantPath = projectRelativePath
            // The source directories of a java project are not part of the relevant target path
            // because output files will be saved to a java source folder as well.
            // So we remove the first segment of the path if it is a java source directory.
            val firstSegment = new Path(projectRelativePath).segment(0);
            if(!firstSegment.isNullOrEmpty() && project.hasNature(JavaCore.NATURE_ID)) {
                val javaProject = JavaCore.create(project)
                if(isJavaSourceDirectory(javaProject, firstSegment)) {
                    projectRelativeRelevantPath = projectRelativePath.substring(firstSegment.length+1)
                }
            }
            
            // Remove extension
            val projectRelativeRelevantPathWithoutExtension = new Path(projectRelativeRelevantPath).removeFileExtension        
         
            // Compute target path
            projectRelativeTargetPath = launchData.targetDirectory + File.separator + projectRelativeRelevantPathWithoutExtension + launchData.targetLanguageFileExtension
        }
        
        // Return either absolute or relative target path
        if(projectRelative)
            return projectRelativeTargetPath
        else
            return project.location + File.separator + projectRelativeTargetPath    
    }

    private def boolean isJavaSourceDirectory(IJavaProject javaProject, String directory) {
        val classPathEntries = javaProject.getRawClasspath();
        for(entry : classPathEntries) {
            if(entry.entryKind == IClasspathEntry.CPE_SOURCE) {
                val sourceFolderName = new Path(entry.path.toOSString).lastSegment
                if(sourceFolderName.equals(directory)) {
                    return true
                }
            } 
        }
        return false
    }

    /**
     * Saves the result to the fully qualified target path,
     * possibly using the target template for the output.
     * 
     * @param result The text to be saved
     * @param targetPath File path where the result should be saved
     */
    private def void saveCompilationResult(String result, String targetPath) {
        // Create directory for the output if none yet.
        createDirectories(targetPath)
        
        // Compile with KiCo and save output
        val resolvedTargetTemplate = variableManager.performStringSubstitution(launchData.targetTemplate)
        if (resolvedTargetTemplate != "") {
            // Use template
            val targetTemplateLocation = project.location + File.separator + resolvedTargetTemplate
            val reader = new FileReader(new File(targetTemplateLocation))
            // Setup Freemarker
            val cfg = new Configuration(new Version(2, 3, 0))
            cfg.templateExceptionHandler = TemplateExceptionHandler.RETHROW_HANDLER
            // Write output to target path
            val template = new Template(resolvedTargetTemplate, reader, cfg)
            val writer = new FileWriter(new File(targetPath))
            template.process(#{COMPILED_CODE_PLACEHOLDER -> result}, writer)
            writer.close()
            reader.close()
        } else {
            // Don't use template
            val writer = new PrintWriter(targetPath, "UTF-8");
            writer.print(result)
            writer.close()
        }
    }

    /**
     * Creates the folder structure for a fully qualified file path.
     * 
     * @param path The path to a fully qualified file
     */
    private def void createDirectories(String filePath) {
        new File(filePath).parentFile.mkdirs()
    }

    /**
     * Loads all necessary data from the launch configuration.
     */
    private def void loadSettingsFromConfiguration() {
        // Load data object
        launchData = KiCoLaunchData.loadFromConfiguration(configuration)
    
        // Set project handle
        project = findProject(launchData.projectName)
    }

    /**
     * Sets several eclipse string variables for this launch (e.g. ${main_name}, ${compiled_main_name}).
     * The variables can be used for example in the commands and file paths.
     */
    private def void setVariables() {
        // Set project
        setVariable(LaunchConfiguration.LAUNCHED_PROJECT_VARIABLE, project.location.toOSString)

        // Set main file
        val mainFileName = new File(launchData.mainFile).name
        val mainFileLocation = if(mainFileName != "")
                                   new File(project.location + File.separator + launchData.mainFile).absolutePath
                               else
                                   ""
        val mainFilePath = launchData.mainFile
        val mainFileWithoutExtension = new Path(mainFileName).removeFileExtension.toOSString
        setVariable(LaunchConfiguration.MAIN_FILE_NAME_VARIABLE, mainFileName)
        setVariable(LaunchConfiguration.MAIN_FILE_LOCATION_VARIABLE, mainFileLocation)
        setVariable(LaunchConfiguration.MAIN_FILE_PATH_VARIABLE, mainFilePath)
        setVariable(LaunchConfiguration.MAIN_FILE_NAME_WITHOUT_FILE_EXTENSION_VARIABLE, mainFileWithoutExtension)

        // Set compiled main file
        val mainTarget = computeTargetPath(launchData.mainFile, true)
        val mainTargetName = new File(mainTarget).name
        val mainTargetLocation = if(mainTargetName != "")
                                     new File(project.location + File.separator + mainTarget).absolutePath
                                 else
                                    ""
        val mainTargetPath = mainTarget
        val mainTargetWithoutExtension = new Path(mainTargetName).removeFileExtension.toOSString
        setVariable(LaunchConfiguration.COMPILED_MAIN_FILE_NAME_VARIABLE, mainTargetName)
        setVariable(LaunchConfiguration.COMPILED_MAIN_FILE_LOCATION_VARIABLE, mainTargetLocation)
        setVariable(LaunchConfiguration.COMPILED_MAIN_FILE_PATH_VARIABLE, mainTargetPath)
        setVariable(LaunchConfiguration.COMPILED_MAIN_FILE_NAME_WITHOUT_FILE_EXTENSION_VARIABLE, mainTargetWithoutExtension)
    }

    /**
     * Creates or modifies the variable with the given name and data.
     * 
     * @param name The variable's name
     * @param value The variable's value
     * @param description The variable's description 
     */
    private def void setVariable(String name, String value) {
        var variable = variableManager.getValueVariable(name)
        variable.value = value
    }
    
    /**
     * Registers a string variable at the string variable manager.
     * 
     * @param name The name of the variable
     * @param description A short description for the variable
     */
    private static def void initializeVariable(String name, String description) {
        val manager = VariablesPlugin.getDefault.stringVariableManager
        val variable = manager.newValueVariable(name, description, false, "")
        variable.description = description
        manager.addVariables(#[variable])
    }

    /**
     * Returns a project handle if the project exists in the current workspace.
     * 
     * @param name The name of a project to be found
     */
    static def IProject findProject(String name) {
        if (!name.isNullOrEmpty() && new Path(name).isValidPath(name)) {
            val p = ResourcesPlugin.workspace.root.getProject(name)
            if (p.location != null)
                return p
        }
        return null
    }

    /**
     * Search for a console with a given name in the Console View.
     * If the console can't be found it will be created.
     * 
     * @param name The name of a message console to be found or created
     * @return The found or newly created message console
     */
    private static def MessageConsole findOrCreateConsole(String name) {
        val consoleManager = ConsolePlugin.getDefault().getConsoleManager();
        val existingConsoles = consoleManager.getConsoles();
        for (var i = 0; i < existingConsoles.length; i++)
            if (name.equals(existingConsoles.get(i).getName()))
                return existingConsoles.get(i) as MessageConsole;

        // No console found, so create a new one.
        val myConsole = new MessageConsole(name, null);
        consoleManager.addConsoles(#[myConsole]);
        return myConsole;
    }
    
    private def void clearConsole() {
        initializeConsole()
        console.clearConsole()
    }
    
    private static def void initializeConsole() {
        if (console == null || consoleStream == null) {
            console = findOrCreateConsole(CONSOLE_NAME)
            consoleStream = console.newMessageStream()
        }
    }
}