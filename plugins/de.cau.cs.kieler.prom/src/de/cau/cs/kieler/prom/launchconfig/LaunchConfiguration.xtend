/*
 * KIELER - Kiel Integrated Environment for Layout Eclipse RichClient
 *
 * http://www.informatik.uni-kiel.de/rtsys/kieler/
 * 
 * Copyright 2015 by
 * + Kiel University
 *   + Department of Computer Science
 *     + Real-Time and Embedded Systems Group
 * 
 * This code is provided under the terms of the Eclipse Public License (EPL).
 * See the file epl-v10.html for the license text.
 */
package de.cau.cs.kieler.prom.launchconfig

import de.cau.cs.kieler.kico.KielerCompiler
import de.cau.cs.kieler.kico.KielerCompilerContext
import de.cau.cs.kieler.prom.common.CommandData
import de.cau.cs.kieler.prom.common.FileCompilationData
import de.cau.cs.kieler.prom.common.ModelImporter
import freemarker.template.Configuration
import freemarker.template.Template
import freemarker.template.TemplateExceptionHandler
import freemarker.template.Version
import java.io.File
import java.io.FileReader
import java.io.FileWriter
import java.io.PrintWriter
import java.util.List
import org.apache.commons.io.FilenameUtils
import org.eclipse.core.resources.IProject
import org.eclipse.core.resources.ResourcesPlugin
import org.eclipse.core.runtime.CoreException
import org.eclipse.core.runtime.IProgressMonitor
import org.eclipse.core.runtime.IStatus
import org.eclipse.core.runtime.Path
import org.eclipse.core.runtime.Status
import org.eclipse.core.runtime.jobs.Job
import org.eclipse.core.variables.IStringVariableManager
import org.eclipse.core.variables.VariablesPlugin
import org.eclipse.debug.core.ILaunch
import org.eclipse.debug.core.ILaunchConfiguration
import org.eclipse.debug.core.model.ILaunchConfigurationDelegate
import org.eclipse.emf.ecore.EObject
import org.eclipse.ui.console.ConsolePlugin
import org.eclipse.ui.console.MessageConsole
import org.eclipse.ui.console.MessageConsoleStream
import com.google.common.base.Strings

/**
 * Implementation of a launch configuration that uses KiCo.
 * 
 * @author aas
 */
class LaunchConfiguration implements ILaunchConfigurationDelegate {

    /**
     * The extension id of this launch config type.
     * It is set in the plugin.xml.
     */
    public static val LAUNCH_CONFIGURATION_TYPE_ID = "de.cau.cs.kieler.prom.launchconfig.launchConfiguration"

    /**
     * The variable name in the target template
     * for code generated by KiCo.
     */
    public static val COMPILED_CODE_PLACEHOLDER = "kico_code"

    /**
     * The directory in which compiled output of this launch will be saved.
     */
    public static val BUILD_DIRECTORY = "kieler-gen"

    // Attribute names
    public static val ATTR_COMMANDS = "de.cau.cs.kieler.prom.launchconfig.commands"

    public static val ATTR_FILES = "de.cau.cs.kieler.prom.launchconfig.files"

    public static val ATTR_PROJECT = "de.cau.cs.kieler.prom.launchconfig.main.project"
    public static val ATTR_MAIN_FILE = "de.cau.cs.kieler.prom.launchconfig.main.file"

    public static val ATTR_ENVIRONMENT = "de.cau.cs.kieler.prom.launchconfig.main.environment"

    public static val ATTR_TARGET_LANGUAGE = "de.cau.cs.kieler.prom.launchconfig.main.target.language"
    public static val ATTR_TARGET_TEMPLATE = "de.cau.cs.kieler.prom.launchconfig.main.target.template"
    public static val ATTR_TARGET_LANGUAGE_FILE_EXTENSION = "de.cau.cs.kieler.prom.launchconfig.main.target.file.extension"

    public static val ATTR_WRAPPER_CODE_TEMPLATE = "de.cau.cs.kieler.prom.launchconfig.main.wrapper.template"
    public static val ATTR_WRAPPER_CODE_SNIPPETS = "de.cau.cs.kieler.prom.launchconfig.main.wrapper.snippets"

    // Variable names
    public static val LAUNCHED_PROJECT_VARIABLE = "launched_project_loc"

    public static val MAIN_FILE_NAME_VARIABLE = "main_name"
    public static val MAIN_FILE_PATH_VARIABLE = "main_path"
    public static val MAIN_FILE_LOCATION_VARIABLE = "main_loc"
    public static val MAIN_FILE_NAME_WITHOUT_FILE_EXTENSION_VARIABLE = "main_name_no_ext"

    public static val COMPILED_MAIN_FILE_NAME_VARIABLE = "compiled_main_name"
    public static val COMPILED_MAIN_FILE_PATH_VARIABLE = "compiled_main_path"
    public static val COMPILED_MAIN_FILE_LOCATION_VARIABLE = "compiled_main_loc"
    public static val COMPILED_MAIN_FILE_NAME_WITHOUT_FILE_EXTENSION_VARIABLE = "compiled_main_name_no_ext"

    private IStringVariableManager variableManager

    // Objects from launch
    private ILaunchConfiguration configuration
    private String mode
    private ILaunch launch
    private IProgressMonitor monitor

    // Objects loaded from configuration
    private IProject project
    private String mainFile
    private List<FileCompilationData> files
    private String targetLanguage
    private String targetTemplate
    private String wrapperCodeTemplate
    private String wrapperCodeSnippetDirectory

    private List<CommandData> commands

    private String targetLanguageFileExtension

    // Jobs
    private Job compileJob;
    private Job wrapperCodeJob;

    // Message console
    private static val CONSOLE_NAME = "Project Launch"
    private MessageConsole console;
    private MessageConsoleStream consoleStream;

    /**
     * {@inheritDoc}
     */
    override void launch(ILaunchConfiguration configuration, String mode, ILaunch launch,
        IProgressMonitor monitor) throws CoreException {
        this.configuration = configuration
        this.mode = mode
        this.launch = launch
        this.monitor = monitor

        // Init console for errors and messages
        if (console == null || consoleStream == null) {
            console = findConsole(CONSOLE_NAME)
            consoleStream = console.newMessageStream()
        }
        console.clearConsole()

        // Get data from config.
        loadSettingsFromConfiguration()

        if (project != null) {

            // Set variables (e.g. launched_project_loc, main_name, main_loc, ...)
            setVariables() 

            // Create jobs.
            compileJob = getCompileJob()
            wrapperCodeJob = getWrapperCodeGenerationJob()

            // Start jobs.
            compileJob.schedule()
            wrapperCodeJob.schedule()

            // Wait for the jobs to finish.
            compileJob.join()
            wrapperCodeJob.join()

            // Execute commands only if the other jobs succeded  
            if (compileJob.result.code == IStatus.OK && wrapperCodeJob.result.code == IStatus.OK) {
                getExecuteCommandsJob().schedule()
            }
        } else {
            consoleStream.println("Project of launch configuration '" + configuration.name +
                "' does not exist.\n");
        }
    }

    /**
     * Creates a job that compiles a list of FileCompildationData via KiCo.
     * 
     * @return the created job.
     */
    private def Job getCompileJob() {

        return new Job("KiCo Compilation") {
            override protected IStatus run(IProgressMonitor monitor) {

                val startTime = System.currentTimeMillis()

                try {
                    for (data : files) {
                        compile(data)

                        if (monitor.isCanceled())
                            return Status.CANCEL_STATUS
                    }
                } catch (Exception e) {
                    // Remove this try-catch to notify the user with a popup window.
                    consoleStream.println(e.message + "\n")
                    return Status.CANCEL_STATUS
                }

                System.err.println("Compilation finished after " + (System.currentTimeMillis() - startTime) + "ms")

                return Status.OK_STATUS
            }
        }
    }

    /**
     * Creates a job that generates and saves the wrapper code for a list of FileCompilationData.
     * 
     * @return the created job. 
     */
    private def Job getWrapperCodeGenerationJob() {
        return new Job("Wrapper Code Generation") {
            override protected IStatus run(IProgressMonitor monitor) {

                val startTime = System.currentTimeMillis()

                try {
                    val generator = new WrapperCodeGenerator(project,
                        variableManager.performStringSubstitution(wrapperCodeTemplate),
                        variableManager.performStringSubstitution(wrapperCodeSnippetDirectory),
                        computeTargetPath(variableManager.performStringSubstitution(wrapperCodeTemplate), false))

                    generator.generateWrapperCode(files)

                } catch (Exception e) {
                    consoleStream.println(e.message + "\n")
                    return Status.CANCEL_STATUS
                }

                System.err.println(
                    "Wrapper Code generation finished after " + (System.currentTimeMillis() - startTime) + "ms")

                return Status.OK_STATUS
            }
        }
    }

    /**
     * Creates a job that executes the commands for this launch config successively.
     * 
     * @return the created job.
     */
    private def Job getExecuteCommandsJob() {
        return new Job("Command Execution") {

            override protected run(IProgressMonitor monitor) {
                try {
                    val executor = new CommandExecutor(project, launch)
                    executor.execute(commands)
                    return Status.OK_STATUS
                } catch (Exception e) {
                    consoleStream.println(e.message + "\n")
                    return Status.CANCEL_STATUS
                }
            }
        }
    }

    /**
     * Compile a file via KiCo and save the result.
     * 
     * @param data The file to be compiled
     */
    private def void compile(FileCompilationData data) {
        // Load model from file
        val EObject model = ModelImporter.get(project.location.toOSString + File.separator + data.projectRelativePath)

        if (model != null) {
            // Get compiler context with settings for KiCo
            // TODO: ESTERELSIMULATIONVISUALIZATION throws an exception when used (21.07.2015), so we explicitly disable it.
            // TODO: SIMULATIONVISUALIZATION throws an exception when used (28.10.2015), so we explicitly disable it.
            // TODO: (Bug KISEMA-1036) still requires *T_INITIALIZATION
            val context = new KielerCompilerContext("!T_ESTERELSIMULATIONVISUALIZATION, !T_SIMULATIONVISUALIZATION, *T_INITIALIZATION, T_" + targetLanguage, model)
            context.inplace = false
            context.advancedSelect = true

            // Compile
            val result = KielerCompiler.compile(context)

            // Flush compilation result to target
            if (result.string != null && result.string != "") {
                saveCompilationResult(result.string, computeTargetPath(data.projectRelativePath, false))
            } else {
                var errorMessage = "Compilation of '" + data.name + "' failed:\n\n" + result.allErrors

                throw new Exception(errorMessage)
            }
        }
    }

    /**
     * Computes the fully qualified target path for a project relative file path.
     * The target path is in the build directory for kico compiled files and in this directory
     * has the same directory structure as the original file in the project.
     * The file extension of the target path is the extension for the current target language.
     * 
     * @param projectRelativePath Project relative path of a file in the project
     * @param projectRelative Flag to specify if the computed path should be projectRelative or not
     * @return the computed path
     */
    private def String computeTargetPath(String projectRelativePath, boolean projectRelative) {
        // The src directory of a typical java project is not part of the relevant target path.
        // (Would be more accurate: if the first directory is a java build source folder, remove it)
        var String projectRelativeRelevantPath;
        if (projectRelativePath.startsWith("src/") || projectRelativePath.startsWith("src\\"))
            projectRelativeRelevantPath = projectRelativePath.substring(4)
        else
            projectRelativeRelevantPath = projectRelativePath

        // Remove extension
        val projectRelativeRelevantPathWithoutExtension = FilenameUtils.removeExtension(projectRelativeRelevantPath)        
    
        // Compute target path
        val projectRelativeTargetPath = BUILD_DIRECTORY + File.separator + projectRelativeRelevantPathWithoutExtension + targetLanguageFileExtension
        if(projectRelative)
            return projectRelativeTargetPath
        else
            return project.location + File.separator + projectRelativeTargetPath
    }

    /**
     * Saves the result to the fully qualified target path,
     * possibly using the target template for the output.
     * 
     * @param result The text to be saved
     * @param targetPath File path where the result should be saved
     */
    private def void saveCompilationResult(String result, String targetPath) {
        // Create directory for the output if none yet.
        createDirectories(targetPath)

        if (targetTemplate != "") {
            // Use template
            val reader = new FileReader(
                new File(project.location + File.separator + variableManager.performStringSubstitution(targetTemplate)))
            val cfg = new Configuration(new Version(2, 3, 0))
            cfg.templateExceptionHandler = TemplateExceptionHandler.RETHROW_HANDLER

            val template = new Template(targetTemplate, reader, cfg)
            val writer = new FileWriter(new File(targetPath))
            template.process(#{COMPILED_CODE_PLACEHOLDER -> result}, writer)
            writer.close()

            reader.close()
        } else {
            // Don't use template
            val writer = new PrintWriter(targetPath, "UTF-8");
            writer.print(result)
            writer.close()
        }
    }

    /**
     * Creates the folder structure for a fully qualified file path.
     * 
     * @param path The path to a fully qualified file
     */
    private def void createDirectories(String path) {
        new File(path).parentFile.mkdirs()
    }

    /**
     * Loads all necessary data from the launch configuration.
     */
    private def void loadSettingsFromConfiguration() {
        // Load project
        val projectName = configuration.getAttribute(ATTR_PROJECT, "")
        project = findProject(projectName)

        // Load main file
        mainFile = configuration.getAttribute(ATTR_MAIN_FILE, "")

        // Model files to be compiled
        files = FileCompilationData.loadAllFromConfiguration(configuration)
    
        // Load target
        targetLanguage = configuration.getAttribute(ATTR_TARGET_LANGUAGE, "")
        targetTemplate = configuration.getAttribute(ATTR_TARGET_TEMPLATE, "")
        targetLanguageFileExtension = configuration.getAttribute(ATTR_TARGET_LANGUAGE_FILE_EXTENSION, "")

        // Load wrapper code
        wrapperCodeTemplate = configuration.getAttribute(ATTR_WRAPPER_CODE_TEMPLATE, "")
        wrapperCodeSnippetDirectory = configuration.getAttribute(ATTR_WRAPPER_CODE_SNIPPETS, "")

        // Load shell commands
        commands = CommandData.loadAllFromConfiguration(configuration)
    }

    /**
     * Sets several eclipse string variables for this launch (e.g. ${main_name}, ${compiled_main_name}).
     * The variables can be used for example in the commands and file paths.
     */
    private def void setVariables() {
        variableManager = VariablesPlugin.getDefault.stringVariableManager

        // Set project
        setVariable(LaunchConfiguration.LAUNCHED_PROJECT_VARIABLE, project.location.toOSString,
            "Fully qualified path to the launched application")

        // Set main file
        val mainFileName = new File(mainFile).name
        val mainFileLocation = if(mainFileName != "") new File(project.location + File.separator + mainFile).
                absolutePath else ""
        val mainFilePath = mainFile
        val mainFileWithoutExtension = FilenameUtils.removeExtension(mainFileName)
        setVariable(LaunchConfiguration.MAIN_FILE_NAME_VARIABLE, mainFileName,
            "Name of the main file of the launched application")
        setVariable(LaunchConfiguration.MAIN_FILE_LOCATION_VARIABLE, mainFileLocation,
            "Fully qualified location of the main file of the launched application")
        setVariable(LaunchConfiguration.MAIN_FILE_PATH_VARIABLE, mainFilePath,
            "Project relative path of the main file of the launched application")
        setVariable(LaunchConfiguration.MAIN_FILE_NAME_WITHOUT_FILE_EXTENSION_VARIABLE, mainFileWithoutExtension,
            "Project relative path of the main file of the launched application without file extension")

        // Set compiled main file
        val mainTarget = computeTargetPath(mainFile, true)
        val mainTargetName = new File(mainTarget).name
        val mainTargetLocation = if(mainTargetName != "") new File(project.location + File.separator + mainTarget).
                absolutePath else ""
        val mainTargetPath = mainTarget
        val mainTargetWithoutExtension = FilenameUtils.removeExtension(mainTargetName)
        setVariable(LaunchConfiguration.COMPILED_MAIN_FILE_NAME_VARIABLE, mainTargetName,
            "Name of the compiled main file of the launched application")
        setVariable(LaunchConfiguration.COMPILED_MAIN_FILE_LOCATION_VARIABLE, mainTargetLocation,
            "Fully qualified location of the compiled main file of the launched application")
        setVariable(LaunchConfiguration.COMPILED_MAIN_FILE_PATH_VARIABLE, mainTargetPath,
            "Project relative path of the compiled main file of the launched application")
        setVariable(LaunchConfiguration.COMPILED_MAIN_FILE_NAME_WITHOUT_FILE_EXTENSION_VARIABLE,
            mainTargetWithoutExtension,
            "Project relative path of the compiled main file of the launched application without file extension")
    }

    /**
     * Creates or modifies the variable with the given name and data.
     * 
     * @param name The variable's name
     * @param value The variable's value
     * @param description The variable's description 
     */
    private def void setVariable(String name, String value, String description) {
        var variable = variableManager.getValueVariable(name)
        if (variable == null) {
            variable = variableManager.newValueVariable(name, description, false, value)
            variableManager.addVariables(#[variable])
        } else {
            variable.description = description
            variable.value = value
        }
    }

    /**
     * Returns a project handle if the project exists in the current workspace.
     * 
     * @param name The name of a project to be found
     */
    static def IProject findProject(String name) {
        if (!Strings.isNullOrEmpty(name) && new Path(name).isValidPath(name)) {
            val p = ResourcesPlugin.workspace.root.getProject(name)
            if (p.location != null)
                return p
        }
        return null
    }

    /**
     * Search for a console with a given name in the Console View.
     * If the console can't be found it will be created.
     * 
     * @param name The name of a message console to be found or created
     * @return The found or newly created message console
     */
    private def MessageConsole findConsole(String name) {
        val plugin = ConsolePlugin.getDefault();
        val conMan = plugin.getConsoleManager();
        val existing = conMan.getConsoles();
        for (var i = 0; i < existing.length; i++)
            if (name.equals(existing.get(i).getName()))
                return existing.get(i) as MessageConsole;

        // No console found, so create a new one.
        val myConsole = new MessageConsole(name, null);
        conMan.addConsoles(#[myConsole]);
        return myConsole;
    }
}