/*
 * KIELER - Kiel Integrated Environment for Layout Eclipse RichClient
 * 
 * http://www.informatik.uni-kiel.de/rtsys/kieler/
 * 
 * Copyright 2010 by
 * + Christian-Albrechts-University of Kiel
 *   + Department of Computer Science
 *     + Real-Time and Embedded Systems Group
 * 
 * This code is provided under the terms of the Eclipse Public License (EPL).
 * See the file epl-v10.html for the license text.
 */
grammar de.cau.cs.kieler.core.kexpressions.KExpressions with  de.cau.cs.kieler.core.annotations.text.Annotations

import "http://kieler.cs.cau.de/kexpressions/0.1.2" 

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

Root returns ecore::EObject:
    Expression;

Expression returns Expression:
     BoolExpression  
     | ValuedExpression
;

BoolExpression returns Expression:
    OrAndExpression;

OrAndExpression returns Expression:
	CompareOperation 
	(
		({OperatorExpression.subExpressions+=current} operator=(OrOperator|LogicalOrOperator) subExpressions+=CompareOperation)*
		|	
		({OperatorExpression.subExpressions+=current} operator=(AndOperator|LogicalAndOperator) subExpressions+=CompareOperation)*
	)
;
	
//OrExpression returns Expression:
//	CompareOperation ({OperatorExpression.subExpressions+=current} operator=(OrOperator) subExpressions+=CompareOperation)*;
////	{OperatorExpression} subExpressions += CompareOperation (/*{OperatorExpression.subExpressions+=current}*/ operator=(AndOperator|OrOperator) subExpressions+=CompareOperation)*;
//
//AndExpression returns Expression:
//	CompareOperation ({OperatorExpression.subExpressions+=current} operator=(AndOperator) subExpressions+=CompareOperation)*;

// Example: 42 <= val(A)
CompareOperation returns Expression:
	NotOrValuedExpression ({OperatorExpression.subExpressions+=current} operator=CompareOperator subExpressions+=NotOrValuedExpression)
	| NotExpression
;

// order IS IMPORTANT
NotOrValuedExpression returns Expression:
	ValuedExpression
	| NotExpression
;


// Example: not A, not false, not (A or B)
// at the latter we need the parents to indicate the right binding
NotExpression returns Expression:
	{OperatorExpression} operator=NotOperator subExpressions+=(NotExpression)
    | AtomicExpression
;
  
    
// everything that evaluates to a primitive number value
ValuedExpression returns Expression:
	AddExpression;


// Example: 1 + 2
AddExpression returns Expression:
	SubExpression ({OperatorExpression.subExpressions+=current} operator=AddOperator subExpressions+=SubExpression)*;


// Example: varA - ?B
SubExpression returns Expression:
	MultExpression ({OperatorExpression.subExpressions+=current} operator=SubOperator subExpressions+=MultExpression)*;
//    ({OperatorExpression} subExpressions+=MultExpression (operator=SubOperator subExpressions+=MultExpression)+)
//	| ({OperatorExpression} subExpressions+=MultExpression subExpressions+=NIntValue)
//    | MultExpression;


// Example: 2 * 4
MultExpression returns Expression:
	DivExpression ({OperatorExpression.subExpressions+=current} operator=MultOperator subExpressions+=DivExpression)*;


// Example: (2 / 4)
// note: division always has to have parentheses because the '/' sign is also used for trigger/effect delimiter
DivExpression returns Expression:
	ModExpression ({OperatorExpression.subExpressions+=current} operator=DivOperator subExpressions+=ModExpression)?;
	

// Example: varA mod ?B
ModExpression returns Expression:
	NegExpression ({OperatorExpression.subExpressions+=current} operator=ModOperator subExpressions+=AtomicValuedExpression)?;


// Example: -?A, -(?A + ?B)
// at the latter we need the parents to indicate the right binding
NegExpression returns Expression:
	{OperatorExpression} operator=SubOperator subExpressions+=(NegExpression)
    | AtomicValuedExpression
;
  
    
AtomicExpression returns Expression:
    BoolValue
    | ValuedObjectTestExpression 
    | '(' BoolExpression ')'
    | TextExpression
;


AtomicValuedExpression returns Expression:
    IntValue
    | FloatValue 
    | '(' ValuedExpression ')'
    | AtomicExpression 
;


// Example: pre(pre(val(A))), pre(val(pre(A))), val(A), A varX
ValuedObjectTestExpression returns Expression:
	{OperatorExpression} operator=(PreOperator|ValOperator)  '('subExpressions+=ValuedObjectTestExpression')'
	| ValuedObjectReference
;

// Example: A, varB
ValuedObjectReference returns ValuedObjectReference:
	valuedObject=[ValuedObject|ID] ('[' cardinalities+=Expression ']')*;


// Example: 'printf(...)'
TextExpression returns TextExpression:
	text=HOSTCODE;

IntValue returns IntValue:
	value=INT;

FloatValue returns FloatValue:
	value=FLOAT;


BoolValue returns BoolValue:
	value=BOOLEAN;


// data type rule allowing any kind of value to be accepted,
// e.g. as initialValues of valuedObjects
// used in Kits.xtext 
AnyType returns ecore::EString:
    BOOLEAN | INT | FLOAT | ID | STRING;


enum CompareOperator returns OperatorType:
	EQ="==" | LT="<" | LEQ="<=" | GT=">" | GEQ=">=" | NE="<>";

enum PreOperator returns OperatorType:
    PRE="pre";

enum OrOperator returns OperatorType:
	OR="|";

enum AndOperator returns OperatorType:
	AND="&";

enum NotOperator returns OperatorType:
	NOT="!";

enum AddOperator returns OperatorType:
	ADD="+";
	
enum SubOperator returns OperatorType:
	SUB="-";
	
enum MultOperator returns OperatorType:	
	MULT="*";

enum ModOperator returns OperatorType:	
	MOD="%";

enum DivOperator returns OperatorType:	
	DIV="/";

enum ValOperator returns OperatorType:
	VAL="val";

enum LogicalOrOperator returns OperatorType:
	OR="||";

enum LogicalAndOperator returns OperatorType:
	AND="&&";

/*
   the following declarations are re-used in Actions.xtext, Interface.xtext, Kits.xtext 
*/
enum ValueType returns ValueType:
	PURE="pure" | BOOL="bool" | UNSIGNED="unsigned"	| 
	INT="int" | FLOAT="float" |
	STRING="string" | HOST="host";


enum CombineOperator returns CombineOperator:
	NONE="none" | ADD="+" | MULT="*" | MAX="max" |
	MIN="min" | OR="|" | AND="&" | HOST="host";


// custom terminal rule allowing to save transition label string as they are
terminal HOSTCODE returns ecore::EString: 
	"'" ( '\\' ('b'|'t'|'n'|'f'|'r'|'"'|"'"|'\\') | !('\\'|"'") )* "'";