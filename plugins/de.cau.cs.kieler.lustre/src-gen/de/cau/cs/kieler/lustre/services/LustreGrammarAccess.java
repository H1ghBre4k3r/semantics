/*
 * generated by Xtext 2.10.0
 */
package de.cau.cs.kieler.lustre.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.CrossReference;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractGrammarElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class LustreGrammarAccess extends AbstractGrammarElementFinder {
	
	public class ProgramElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.Program");
		private final Assignment cPkgAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cPkgPackageParserRuleCall_0 = (RuleCall)cPkgAssignment.eContents().get(0);
		
		//Program hidden(WS, LUSTRE_COMMENT):
		//	pkg=Package;
		@Override public ParserRule getRule() { return rule; }
		
		//pkg=Package
		public Assignment getPkgAssignment() { return cPkgAssignment; }
		
		//Package
		public RuleCall getPkgPackageParserRuleCall_0() { return cPkgPackageParserRuleCall_0; }
	}
	public class PackageElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.Package");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cHeadAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cHeadPackage_HeaderParserRuleCall_0_0 = (RuleCall)cHeadAssignment_0.eContents().get(0);
		private final Assignment cBodyAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cBodyPackage_Body_ContentParserRuleCall_1_0 = (RuleCall)cBodyAssignment_1.eContents().get(0);
		private final Keyword cEndKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//Package:
		//	head=Package_Header body=Package_Body_Content 'end';
		@Override public ParserRule getRule() { return rule; }
		
		//head=Package_Header body=Package_Body_Content 'end'
		public Group getGroup() { return cGroup; }
		
		//head=Package_Header
		public Assignment getHeadAssignment_0() { return cHeadAssignment_0; }
		
		//Package_Header
		public RuleCall getHeadPackage_HeaderParserRuleCall_0_0() { return cHeadPackage_HeaderParserRuleCall_0_0; }
		
		//body=Package_Body_Content
		public Assignment getBodyAssignment_1() { return cBodyAssignment_1; }
		
		//Package_Body_Content
		public RuleCall getBodyPackage_Body_ContentParserRuleCall_1_0() { return cBodyPackage_Body_ContentParserRuleCall_1_0; }
		
		//'end'
		public Keyword getEndKeyword_2() { return cEndKeyword_2; }
	}
	public class Package_HeaderElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.Package_Header");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cPackageKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDENTTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cUsesKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cUsesAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cUsesIdent_ListParserRuleCall_2_1_0 = (RuleCall)cUsesAssignment_2_1.eContents().get(0);
		private final Keyword cProvidesKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cProvidesAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cProvidesPackage_ProvideParserRuleCall_4_0 = (RuleCall)cProvidesAssignment_4.eContents().get(0);
		
		//Package_Header:
		//	'package' name=IDENT ('uses' uses=Ident_List)? 'provides' provides+=Package_Provide+;
		@Override public ParserRule getRule() { return rule; }
		
		//'package' name=IDENT ('uses' uses=Ident_List)? 'provides' provides+=Package_Provide+
		public Group getGroup() { return cGroup; }
		
		//'package'
		public Keyword getPackageKeyword_0() { return cPackageKeyword_0; }
		
		//name=IDENT
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//IDENT
		public RuleCall getNameIDENTTerminalRuleCall_1_0() { return cNameIDENTTerminalRuleCall_1_0; }
		
		//('uses' uses=Ident_List)?
		public Group getGroup_2() { return cGroup_2; }
		
		//'uses'
		public Keyword getUsesKeyword_2_0() { return cUsesKeyword_2_0; }
		
		//uses=Ident_List
		public Assignment getUsesAssignment_2_1() { return cUsesAssignment_2_1; }
		
		//Ident_List
		public RuleCall getUsesIdent_ListParserRuleCall_2_1_0() { return cUsesIdent_ListParserRuleCall_2_1_0; }
		
		//'provides'
		public Keyword getProvidesKeyword_3() { return cProvidesKeyword_3; }
		
		//provides+=Package_Provide+
		public Assignment getProvidesAssignment_4() { return cProvidesAssignment_4; }
		
		//Package_Provide
		public RuleCall getProvidesPackage_ProvideParserRuleCall_4_0() { return cProvidesPackage_ProvideParserRuleCall_4_0; }
	}
	public class Package_ProvideElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.Package_Provide");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cNodeKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cNameNode_HeaderCrossReference_1_0 = (CrossReference)cNameAssignment_1.eContents().get(0);
		private final RuleCall cNameNode_HeaderIDENTTerminalRuleCall_1_0_1 = (RuleCall)cNameNode_HeaderCrossReference_1_0.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cParamAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cParamVar_Decl_ListParserRuleCall_3_0 = (RuleCall)cParamAssignment_3.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Keyword cReturnsKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Keyword cLeftParenthesisKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final Assignment cRetAssignment_7 = (Assignment)cGroup.eContents().get(7);
		private final RuleCall cRetVar_Decl_ListParserRuleCall_7_0 = (RuleCall)cRetAssignment_7.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_8 = (Keyword)cGroup.eContents().get(8);
		private final Keyword cSemicolonKeyword_9 = (Keyword)cGroup.eContents().get(9);
		
		//Package_Provide:
		//	'node' name=[Node_Header|IDENT] '(' param=Var_Decl_List ')' 'returns' '(' ret=Var_Decl_List ')' ';';
		@Override public ParserRule getRule() { return rule; }
		
		//'node' name=[Node_Header|IDENT] '(' param=Var_Decl_List ')' 'returns' '(' ret=Var_Decl_List ')' ';'
		public Group getGroup() { return cGroup; }
		
		//'node'
		public Keyword getNodeKeyword_0() { return cNodeKeyword_0; }
		
		//name=[Node_Header|IDENT]
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//[Node_Header|IDENT]
		public CrossReference getNameNode_HeaderCrossReference_1_0() { return cNameNode_HeaderCrossReference_1_0; }
		
		//IDENT
		public RuleCall getNameNode_HeaderIDENTTerminalRuleCall_1_0_1() { return cNameNode_HeaderIDENTTerminalRuleCall_1_0_1; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }
		
		//param=Var_Decl_List
		public Assignment getParamAssignment_3() { return cParamAssignment_3; }
		
		//Var_Decl_List
		public RuleCall getParamVar_Decl_ListParserRuleCall_3_0() { return cParamVar_Decl_ListParserRuleCall_3_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
		
		//'returns'
		public Keyword getReturnsKeyword_5() { return cReturnsKeyword_5; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_6() { return cLeftParenthesisKeyword_6; }
		
		//ret=Var_Decl_List
		public Assignment getRetAssignment_7() { return cRetAssignment_7; }
		
		//Var_Decl_List
		public RuleCall getRetVar_Decl_ListParserRuleCall_7_0() { return cRetVar_Decl_ListParserRuleCall_7_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_8() { return cRightParenthesisKeyword_8; }
		
		//';'
		public Keyword getSemicolonKeyword_9() { return cSemicolonKeyword_9; }
	}
	public class Package_Body_ContentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.Package_Body_Content");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cBodyKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cEntitiesAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cEntitiesEntity_DeclParserRuleCall_1_0 = (RuleCall)cEntitiesAssignment_1.eContents().get(0);
		
		//Package_Body_Content:
		//	'body' entities+=Entity_Decl+;
		@Override public ParserRule getRule() { return rule; }
		
		//'body' entities+=Entity_Decl+
		public Group getGroup() { return cGroup; }
		
		//'body'
		public Keyword getBodyKeyword_0() { return cBodyKeyword_0; }
		
		//entities+=Entity_Decl+
		public Assignment getEntitiesAssignment_1() { return cEntitiesAssignment_1; }
		
		//Entity_Decl
		public RuleCall getEntitiesEntity_DeclParserRuleCall_1_0() { return cEntitiesEntity_DeclParserRuleCall_1_0; }
	}
	public class Entity_DeclElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.Entity_Decl");
		private final RuleCall cNode_DeclParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//Entity_Decl Node_Decl:
		//	Node_Decl
		@Override public ParserRule getRule() { return rule; }
		
		//Node_Decl
		public RuleCall getNode_DeclParserRuleCall() { return cNode_DeclParserRuleCall; }
	}
	public class PragmaElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.Pragma");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cPercentSignKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cSTRING_CONSTTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Keyword cPercentSignKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		/// *
		// * Pragmas
		// * / Pragma:
		//	('%' STRING_CONST '%')*;
		@Override public ParserRule getRule() { return rule; }
		
		//('%' STRING_CONST '%')*
		public Group getGroup() { return cGroup; }
		
		//'%'
		public Keyword getPercentSignKeyword_0() { return cPercentSignKeyword_0; }
		
		//STRING_CONST
		public RuleCall getSTRING_CONSTTerminalRuleCall_1() { return cSTRING_CONSTTerminalRuleCall_1; }
		
		//'%'
		public Keyword getPercentSignKeyword_2() { return cPercentSignKeyword_2; }
	}
	public class IdentifierElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.Identifier");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cGroup.eContents().get(0);
		private final Assignment cPkgAssignment_0_0 = (Assignment)cGroup_0.eContents().get(0);
		private final RuleCall cPkgIDENTTerminalRuleCall_0_0_0 = (RuleCall)cPkgAssignment_0_0.eContents().get(0);
		private final Assignment cFromPgkAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final Keyword cFromPgkColonColonKeyword_0_1_0 = (Keyword)cFromPgkAssignment_0_1.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDENTTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		
		/// *
		// * Identifiers
		// * / Identifier:
		//	(pkg=IDENT fromPgk?='::')? name=IDENT;
		@Override public ParserRule getRule() { return rule; }
		
		//(pkg=IDENT fromPgk?='::')? name=IDENT
		public Group getGroup() { return cGroup; }
		
		//(pkg=IDENT fromPgk?='::')?
		public Group getGroup_0() { return cGroup_0; }
		
		//pkg=IDENT
		public Assignment getPkgAssignment_0_0() { return cPkgAssignment_0_0; }
		
		//IDENT
		public RuleCall getPkgIDENTTerminalRuleCall_0_0_0() { return cPkgIDENTTerminalRuleCall_0_0_0; }
		
		//fromPgk?='::'
		public Assignment getFromPgkAssignment_0_1() { return cFromPgkAssignment_0_1; }
		
		//'::'
		public Keyword getFromPgkColonColonKeyword_0_1_0() { return cFromPgkColonColonKeyword_0_1_0; }
		
		//name=IDENT
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//IDENT
		public RuleCall getNameIDENTTerminalRuleCall_1_0() { return cNameIDENTTerminalRuleCall_1_0; }
	}
	public class Type_DeclElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.Type_Decl");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cTypeKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final Assignment cNameAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cNameIDENTTerminalRuleCall_0_1_0 = (RuleCall)cNameAssignment_0_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_0_2 = (Keyword)cGroup_0.eContents().get(2);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cTypeKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cNameAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cNameIDENTTerminalRuleCall_1_1_0 = (RuleCall)cNameAssignment_1_1.eContents().get(0);
		private final Keyword cEqualsSignKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		private final Assignment cTypeAssignment_1_3 = (Assignment)cGroup_1.eContents().get(3);
		private final RuleCall cTypeTypeParserRuleCall_1_3_0 = (RuleCall)cTypeAssignment_1_3.eContents().get(0);
		private final Keyword cSemicolonKeyword_1_4 = (Keyword)cGroup_1.eContents().get(4);
		
		/// * 
		// * Types
		// * / Type_Decl:
		//	'type' name=IDENT ';'
		//	| 'type' name=IDENT '=' type=Type ';';
		@Override public ParserRule getRule() { return rule; }
		
		//'type' name=IDENT ';' | 'type' name=IDENT '=' type=Type ';'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'type' name=IDENT ';'
		public Group getGroup_0() { return cGroup_0; }
		
		//'type'
		public Keyword getTypeKeyword_0_0() { return cTypeKeyword_0_0; }
		
		//name=IDENT
		public Assignment getNameAssignment_0_1() { return cNameAssignment_0_1; }
		
		//IDENT
		public RuleCall getNameIDENTTerminalRuleCall_0_1_0() { return cNameIDENTTerminalRuleCall_0_1_0; }
		
		//';'
		public Keyword getSemicolonKeyword_0_2() { return cSemicolonKeyword_0_2; }
		
		//'type' name=IDENT '=' type=Type ';'
		public Group getGroup_1() { return cGroup_1; }
		
		//'type'
		public Keyword getTypeKeyword_1_0() { return cTypeKeyword_1_0; }
		
		//name=IDENT
		public Assignment getNameAssignment_1_1() { return cNameAssignment_1_1; }
		
		//IDENT
		public RuleCall getNameIDENTTerminalRuleCall_1_1_0() { return cNameIDENTTerminalRuleCall_1_1_0; }
		
		//'='
		public Keyword getEqualsSignKeyword_1_2() { return cEqualsSignKeyword_1_2; }
		
		//type=Type
		public Assignment getTypeAssignment_1_3() { return cTypeAssignment_1_3; }
		
		//Type
		public RuleCall getTypeTypeParserRuleCall_1_3_0() { return cTypeTypeParserRuleCall_1_3_0; }
		
		//';'
		public Keyword getSemicolonKeyword_1_4() { return cSemicolonKeyword_1_4; }
	}
	public class TypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.Type");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNameIDENTTerminalRuleCall_0 = (RuleCall)cNameAssignment.eContents().get(0);
		
		//Type:
		//	name=IDENT
		//	//    | Record_Type
		//	//    | Array_Type
		//	//    | Enum_Type;
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//name=IDENT
		public Assignment getNameAssignment() { return cNameAssignment; }
		
		//IDENT
		public RuleCall getNameIDENTTerminalRuleCall_0() { return cNameIDENTTerminalRuleCall_0; }
	}
	public class Record_TypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.Record_Type");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cStructKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cFieldsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cFieldsField_ListParserRuleCall_2_0 = (RuleCall)cFieldsAssignment_2.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//Record_Type:
		//	'struct' '{' fields=Field_List '}';
		@Override public ParserRule getRule() { return rule; }
		
		//'struct' '{' fields=Field_List '}'
		public Group getGroup() { return cGroup; }
		
		//'struct'
		public Keyword getStructKeyword_0() { return cStructKeyword_0; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }
		
		//fields=Field_List
		public Assignment getFieldsAssignment_2() { return cFieldsAssignment_2; }
		
		//Field_List
		public RuleCall getFieldsField_ListParserRuleCall_2_0() { return cFieldsField_ListParserRuleCall_2_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_3() { return cRightCurlyBracketKeyword_3; }
	}
	public class Field_ListElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.Field_List");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cFieldsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cFieldsFieldParserRuleCall_0_0 = (RuleCall)cFieldsAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCommaKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cFieldsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cFieldsFieldParserRuleCall_1_1_0 = (RuleCall)cFieldsAssignment_1_1.eContents().get(0);
		
		//Field_List:
		//	fields+=Field (',' fields+=Field)*;
		@Override public ParserRule getRule() { return rule; }
		
		//fields+=Field (',' fields+=Field)*
		public Group getGroup() { return cGroup; }
		
		//fields+=Field
		public Assignment getFieldsAssignment_0() { return cFieldsAssignment_0; }
		
		//Field
		public RuleCall getFieldsFieldParserRuleCall_0_0() { return cFieldsFieldParserRuleCall_0_0; }
		
		//(',' fields+=Field)*
		public Group getGroup_1() { return cGroup_1; }
		
		//','
		public Keyword getCommaKeyword_1_0() { return cCommaKeyword_1_0; }
		
		//fields+=Field
		public Assignment getFieldsAssignment_1_1() { return cFieldsAssignment_1_1; }
		
		//Field
		public RuleCall getFieldsFieldParserRuleCall_1_1_0() { return cFieldsFieldParserRuleCall_1_1_0; }
	}
	public class FieldElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.Field");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIDENTTerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTypeAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTypeTypeParserRuleCall_2_0 = (RuleCall)cTypeAssignment_2.eContents().get(0);
		
		//Field:
		//	name=IDENT ':' type=Type;
		@Override public ParserRule getRule() { return rule; }
		
		//name=IDENT ':' type=Type
		public Group getGroup() { return cGroup; }
		
		//name=IDENT
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//IDENT
		public RuleCall getNameIDENTTerminalRuleCall_0_0() { return cNameIDENTTerminalRuleCall_0_0; }
		
		//':'
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }
		
		//type=Type
		public Assignment getTypeAssignment_2() { return cTypeAssignment_2; }
		
		//Type
		public RuleCall getTypeTypeParserRuleCall_2_0() { return cTypeTypeParserRuleCall_2_0; }
	}
	public class Enum_TypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.Enum_Type");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cEnumKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cNameListAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameListIdent_ListParserRuleCall_2_0 = (RuleCall)cNameListAssignment_2.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//Enum_Type:
		//	'enum' '{' nameList=Ident_List '}';
		@Override public ParserRule getRule() { return rule; }
		
		//'enum' '{' nameList=Ident_List '}'
		public Group getGroup() { return cGroup; }
		
		//'enum'
		public Keyword getEnumKeyword_0() { return cEnumKeyword_0; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }
		
		//nameList=Ident_List
		public Assignment getNameListAssignment_2() { return cNameListAssignment_2; }
		
		//Ident_List
		public RuleCall getNameListIdent_ListParserRuleCall_2_0() { return cNameListIdent_ListParserRuleCall_2_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_3() { return cRightCurlyBracketKeyword_3; }
	}
	public class Const_DeclElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.Const_Decl");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cConstKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final Assignment cNameAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cNameIDENTTerminalRuleCall_0_1_0 = (RuleCall)cNameAssignment_0_1.eContents().get(0);
		private final Keyword cColonKeyword_0_2 = (Keyword)cGroup_0.eContents().get(2);
		private final Assignment cTypeAssignment_0_3 = (Assignment)cGroup_0.eContents().get(3);
		private final RuleCall cTypeTypeParserRuleCall_0_3_0 = (RuleCall)cTypeAssignment_0_3.eContents().get(0);
		private final Keyword cSemicolonKeyword_0_4 = (Keyword)cGroup_0.eContents().get(4);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cConstKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cNameAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cNameIDENTTerminalRuleCall_1_1_0 = (RuleCall)cNameAssignment_1_1.eContents().get(0);
		private final Keyword cEqualsSignKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		private final Assignment cExprAssignment_1_3 = (Assignment)cGroup_1.eContents().get(3);
		private final RuleCall cExprExpressionParserRuleCall_1_3_0 = (RuleCall)cExprAssignment_1_3.eContents().get(0);
		private final Keyword cSemicolonKeyword_1_4 = (Keyword)cGroup_1.eContents().get(4);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Keyword cConstKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cNameAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cNameIDENTTerminalRuleCall_2_1_0 = (RuleCall)cNameAssignment_2_1.eContents().get(0);
		private final Keyword cColonKeyword_2_2 = (Keyword)cGroup_2.eContents().get(2);
		private final Assignment cTypeAssignment_2_3 = (Assignment)cGroup_2.eContents().get(3);
		private final RuleCall cTypeTypeParserRuleCall_2_3_0 = (RuleCall)cTypeAssignment_2_3.eContents().get(0);
		private final Keyword cEqualsSignKeyword_2_4 = (Keyword)cGroup_2.eContents().get(4);
		private final Assignment cExprAssignment_2_5 = (Assignment)cGroup_2.eContents().get(5);
		private final RuleCall cExprExpressionParserRuleCall_2_5_0 = (RuleCall)cExprAssignment_2_5.eContents().get(0);
		private final Keyword cSemicolonKeyword_2_6 = (Keyword)cGroup_2.eContents().get(6);
		
		/// *
		// * Constants and variables
		// * / Const_Decl:
		//	'const' name=IDENT ':' type=Type ';'
		//	| 'const' name=IDENT '=' expr=Expression ';'
		//	| 'const' name=IDENT ':' type=Type '=' expr=Expression ';';
		@Override public ParserRule getRule() { return rule; }
		
		//'const' name=IDENT ':' type=Type ';' | 'const' name=IDENT '=' expr=Expression ';' | 'const' name=IDENT ':' type=Type '='
		//expr=Expression ';'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'const' name=IDENT ':' type=Type ';'
		public Group getGroup_0() { return cGroup_0; }
		
		//'const'
		public Keyword getConstKeyword_0_0() { return cConstKeyword_0_0; }
		
		//name=IDENT
		public Assignment getNameAssignment_0_1() { return cNameAssignment_0_1; }
		
		//IDENT
		public RuleCall getNameIDENTTerminalRuleCall_0_1_0() { return cNameIDENTTerminalRuleCall_0_1_0; }
		
		//':'
		public Keyword getColonKeyword_0_2() { return cColonKeyword_0_2; }
		
		//type=Type
		public Assignment getTypeAssignment_0_3() { return cTypeAssignment_0_3; }
		
		//Type
		public RuleCall getTypeTypeParserRuleCall_0_3_0() { return cTypeTypeParserRuleCall_0_3_0; }
		
		//';'
		public Keyword getSemicolonKeyword_0_4() { return cSemicolonKeyword_0_4; }
		
		//'const' name=IDENT '=' expr=Expression ';'
		public Group getGroup_1() { return cGroup_1; }
		
		//'const'
		public Keyword getConstKeyword_1_0() { return cConstKeyword_1_0; }
		
		//name=IDENT
		public Assignment getNameAssignment_1_1() { return cNameAssignment_1_1; }
		
		//IDENT
		public RuleCall getNameIDENTTerminalRuleCall_1_1_0() { return cNameIDENTTerminalRuleCall_1_1_0; }
		
		//'='
		public Keyword getEqualsSignKeyword_1_2() { return cEqualsSignKeyword_1_2; }
		
		//expr=Expression
		public Assignment getExprAssignment_1_3() { return cExprAssignment_1_3; }
		
		//Expression
		public RuleCall getExprExpressionParserRuleCall_1_3_0() { return cExprExpressionParserRuleCall_1_3_0; }
		
		//';'
		public Keyword getSemicolonKeyword_1_4() { return cSemicolonKeyword_1_4; }
		
		//'const' name=IDENT ':' type=Type '=' expr=Expression ';'
		public Group getGroup_2() { return cGroup_2; }
		
		//'const'
		public Keyword getConstKeyword_2_0() { return cConstKeyword_2_0; }
		
		//name=IDENT
		public Assignment getNameAssignment_2_1() { return cNameAssignment_2_1; }
		
		//IDENT
		public RuleCall getNameIDENTTerminalRuleCall_2_1_0() { return cNameIDENTTerminalRuleCall_2_1_0; }
		
		//':'
		public Keyword getColonKeyword_2_2() { return cColonKeyword_2_2; }
		
		//type=Type
		public Assignment getTypeAssignment_2_3() { return cTypeAssignment_2_3; }
		
		//Type
		public RuleCall getTypeTypeParserRuleCall_2_3_0() { return cTypeTypeParserRuleCall_2_3_0; }
		
		//'='
		public Keyword getEqualsSignKeyword_2_4() { return cEqualsSignKeyword_2_4; }
		
		//expr=Expression
		public Assignment getExprAssignment_2_5() { return cExprAssignment_2_5; }
		
		//Expression
		public RuleCall getExprExpressionParserRuleCall_2_5_0() { return cExprExpressionParserRuleCall_2_5_0; }
		
		//';'
		public Keyword getSemicolonKeyword_2_6() { return cSemicolonKeyword_2_6; }
	}
	public class Ident_ListElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.Ident_List");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNamesAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNamesIDENTTerminalRuleCall_0_0 = (RuleCall)cNamesAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCommaKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cNamesAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cNamesIDENTTerminalRuleCall_1_1_0 = (RuleCall)cNamesAssignment_1_1.eContents().get(0);
		
		//Ident_List:
		//	names+=IDENT (',' names+=IDENT)*;
		@Override public ParserRule getRule() { return rule; }
		
		//names+=IDENT (',' names+=IDENT)*
		public Group getGroup() { return cGroup; }
		
		//names+=IDENT
		public Assignment getNamesAssignment_0() { return cNamesAssignment_0; }
		
		//IDENT
		public RuleCall getNamesIDENTTerminalRuleCall_0_0() { return cNamesIDENTTerminalRuleCall_0_0; }
		
		//(',' names+=IDENT)*
		public Group getGroup_1() { return cGroup_1; }
		
		//','
		public Keyword getCommaKeyword_1_0() { return cCommaKeyword_1_0; }
		
		//names+=IDENT
		public Assignment getNamesAssignment_1_1() { return cNamesAssignment_1_1; }
		
		//IDENT
		public RuleCall getNamesIDENTTerminalRuleCall_1_1_0() { return cNamesIDENTTerminalRuleCall_1_1_0; }
	}
	public class Node_DeclElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.Node_Decl");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cHeadAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cHeadNode_HeaderParserRuleCall_0_0 = (RuleCall)cHeadAssignment_0.eContents().get(0);
		private final Assignment cBdyAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cBdyFN_BodyParserRuleCall_1_0 = (RuleCall)cBdyAssignment_1.eContents().get(0);
		
		//Node_Decl:
		//	head=Node_Header bdy=FN_Body;
		@Override public ParserRule getRule() { return rule; }
		
		//head=Node_Header bdy=FN_Body
		public Group getGroup() { return cGroup; }
		
		//head=Node_Header
		public Assignment getHeadAssignment_0() { return cHeadAssignment_0; }
		
		//Node_Header
		public RuleCall getHeadNode_HeaderParserRuleCall_0_0() { return cHeadNode_HeaderParserRuleCall_0_0; }
		
		//bdy=FN_Body
		public Assignment getBdyAssignment_1() { return cBdyAssignment_1; }
		
		//FN_Body
		public RuleCall getBdyFN_BodyParserRuleCall_1_0() { return cBdyFN_BodyParserRuleCall_1_0; }
	}
	public class Node_HeaderElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.Node_Header");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cNodeKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDENTTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cParamAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cParamVar_Decl_ListParserRuleCall_3_0 = (RuleCall)cParamAssignment_3.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Keyword cReturnsKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Keyword cLeftParenthesisKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final Assignment cRetAssignment_7 = (Assignment)cGroup.eContents().get(7);
		private final RuleCall cRetVar_Decl_ListParserRuleCall_7_0 = (RuleCall)cRetAssignment_7.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_8 = (Keyword)cGroup.eContents().get(8);
		private final Keyword cSemicolonKeyword_9 = (Keyword)cGroup.eContents().get(9);
		
		//Node_Header:
		//	'node' name=IDENT '(' param=Var_Decl_List ')' 'returns' '(' ret=Var_Decl_List ')' ';';
		@Override public ParserRule getRule() { return rule; }
		
		//'node' name=IDENT '(' param=Var_Decl_List ')' 'returns' '(' ret=Var_Decl_List ')' ';'
		public Group getGroup() { return cGroup; }
		
		//'node'
		public Keyword getNodeKeyword_0() { return cNodeKeyword_0; }
		
		//name=IDENT
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//IDENT
		public RuleCall getNameIDENTTerminalRuleCall_1_0() { return cNameIDENTTerminalRuleCall_1_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }
		
		//param=Var_Decl_List
		public Assignment getParamAssignment_3() { return cParamAssignment_3; }
		
		//Var_Decl_List
		public RuleCall getParamVar_Decl_ListParserRuleCall_3_0() { return cParamVar_Decl_ListParserRuleCall_3_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
		
		//'returns'
		public Keyword getReturnsKeyword_5() { return cReturnsKeyword_5; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_6() { return cLeftParenthesisKeyword_6; }
		
		//ret=Var_Decl_List
		public Assignment getRetAssignment_7() { return cRetAssignment_7; }
		
		//Var_Decl_List
		public RuleCall getRetVar_Decl_ListParserRuleCall_7_0() { return cRetVar_Decl_ListParserRuleCall_7_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_8() { return cRightParenthesisKeyword_8; }
		
		//';'
		public Keyword getSemicolonKeyword_9() { return cSemicolonKeyword_9; }
	}
	public class Var_Decl_ListElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.Var_Decl_List");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cVarListAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cVarListVar_DeclParserRuleCall_0_0 = (RuleCall)cVarListAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCommaKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cVarListAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cVarListVar_DeclParserRuleCall_1_1_0 = (RuleCall)cVarListAssignment_1_1.eContents().get(0);
		
		//Var_Decl_List:
		//	varList+=Var_Decl (',' varList+=Var_Decl)*;
		@Override public ParserRule getRule() { return rule; }
		
		//varList+=Var_Decl (',' varList+=Var_Decl)*
		public Group getGroup() { return cGroup; }
		
		//varList+=Var_Decl
		public Assignment getVarListAssignment_0() { return cVarListAssignment_0; }
		
		//Var_Decl
		public RuleCall getVarListVar_DeclParserRuleCall_0_0() { return cVarListVar_DeclParserRuleCall_0_0; }
		
		//(',' varList+=Var_Decl)*
		public Group getGroup_1() { return cGroup_1; }
		
		//','
		public Keyword getCommaKeyword_1_0() { return cCommaKeyword_1_0; }
		
		//varList+=Var_Decl
		public Assignment getVarListAssignment_1_1() { return cVarListAssignment_1_1; }
		
		//Var_Decl
		public RuleCall getVarListVar_DeclParserRuleCall_1_1_0() { return cVarListVar_DeclParserRuleCall_1_1_0; }
	}
	public class Var_DeclElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.Var_Decl");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIDENTTerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTypeAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTypeTypeParserRuleCall_2_0 = (RuleCall)cTypeAssignment_2.eContents().get(0);
		private final Assignment cClkAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cClkDeclared_ClockParserRuleCall_3_0 = (RuleCall)cClkAssignment_3.eContents().get(0);
		
		//Var_Decl:
		//	name=IDENT ':' type=Type clk=Declared_Clock?;
		@Override public ParserRule getRule() { return rule; }
		
		//name=IDENT ':' type=Type clk=Declared_Clock?
		public Group getGroup() { return cGroup; }
		
		//name=IDENT
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//IDENT
		public RuleCall getNameIDENTTerminalRuleCall_0_0() { return cNameIDENTTerminalRuleCall_0_0; }
		
		//':'
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }
		
		//type=Type
		public Assignment getTypeAssignment_2() { return cTypeAssignment_2; }
		
		//Type
		public RuleCall getTypeTypeParserRuleCall_2_0() { return cTypeTypeParserRuleCall_2_0; }
		
		//clk=Declared_Clock?
		public Assignment getClkAssignment_3() { return cClkAssignment_3; }
		
		//Declared_Clock
		public RuleCall getClkDeclared_ClockParserRuleCall_3_0() { return cClkDeclared_ClockParserRuleCall_3_0; }
	}
	public class Declared_ClockElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.Declared_Clock");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cWhenKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIdentifierParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		
		//Declared_Clock:
		//	'when' name=Identifier;
		@Override public ParserRule getRule() { return rule; }
		
		//'when' name=Identifier
		public Group getGroup() { return cGroup; }
		
		//'when'
		public Keyword getWhenKeyword_0() { return cWhenKeyword_0; }
		
		//name=Identifier
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//Identifier
		public RuleCall getNameIdentifierParserRuleCall_1_0() { return cNameIdentifierParserRuleCall_1_0; }
	}
	public class FN_BodyElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.FN_Body");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cFN_BodyAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cDeclAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cDeclLocal_Var_DeclParserRuleCall_1_0 = (RuleCall)cDeclAssignment_1.eContents().get(0);
		private final Keyword cLetKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cEqAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cEqEquationParserRuleCall_3_0 = (RuleCall)cEqAssignment_3.eContents().get(0);
		private final Keyword cTelKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Keyword cSemicolonKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//FN_Body:
		//	{FN_Body} decl+=Local_Var_Decl* 'let' eq+=Equation* 'tel' ';'?;
		@Override public ParserRule getRule() { return rule; }
		
		//{FN_Body} decl+=Local_Var_Decl* 'let' eq+=Equation* 'tel' ';'?
		public Group getGroup() { return cGroup; }
		
		//{FN_Body}
		public Action getFN_BodyAction_0() { return cFN_BodyAction_0; }
		
		//decl+=Local_Var_Decl*
		public Assignment getDeclAssignment_1() { return cDeclAssignment_1; }
		
		//Local_Var_Decl
		public RuleCall getDeclLocal_Var_DeclParserRuleCall_1_0() { return cDeclLocal_Var_DeclParserRuleCall_1_0; }
		
		//'let'
		public Keyword getLetKeyword_2() { return cLetKeyword_2; }
		
		//eq+=Equation*
		public Assignment getEqAssignment_3() { return cEqAssignment_3; }
		
		//Equation
		public RuleCall getEqEquationParserRuleCall_3_0() { return cEqEquationParserRuleCall_3_0; }
		
		//'tel'
		public Keyword getTelKeyword_4() { return cTelKeyword_4; }
		
		//';'?
		public Keyword getSemicolonKeyword_5() { return cSemicolonKeyword_5; }
	}
	public class Local_Var_DeclElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.Local_Var_Decl");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cVarKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cVar_DeclParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Keyword cSemicolonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//Local_Var_Decl Var_Decl:
		//	'var' Var_Decl ';'
		@Override public ParserRule getRule() { return rule; }
		
		//'var' Var_Decl ';'
		public Group getGroup() { return cGroup; }
		
		//'var'
		public Keyword getVarKeyword_0() { return cVarKeyword_0; }
		
		//Var_Decl
		public RuleCall getVar_DeclParserRuleCall_1() { return cVar_DeclParserRuleCall_1; }
		
		//';'
		public Keyword getSemicolonKeyword_2() { return cSemicolonKeyword_2; }
	}
	public class Equation_ListElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.Equation_List");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cEquation_ListAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cEqAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cEqEq_or_AstParserRuleCall_1_0 = (RuleCall)cEqAssignment_1.eContents().get(0);
		
		//Equation_List:
		//	{Equation_List} eq+=Eq_or_Ast*;
		@Override public ParserRule getRule() { return rule; }
		
		//{Equation_List} eq+=Eq_or_Ast*
		public Group getGroup() { return cGroup; }
		
		//{Equation_List}
		public Action getEquation_ListAction_0() { return cEquation_ListAction_0; }
		
		//eq+=Eq_or_Ast*
		public Assignment getEqAssignment_1() { return cEqAssignment_1; }
		
		//Eq_or_Ast
		public RuleCall getEqEq_or_AstParserRuleCall_1_0() { return cEqEq_or_AstParserRuleCall_1_0; }
	}
	public class Eq_or_AstElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.Eq_or_Ast");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cEquationParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cAssertionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//Eq_or_Ast:
		//	Equation
		//	| Assertion;
		@Override public ParserRule getRule() { return rule; }
		
		//Equation | Assertion
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Equation
		public RuleCall getEquationParserRuleCall_0() { return cEquationParserRuleCall_0; }
		
		//Assertion
		public RuleCall getAssertionParserRuleCall_1() { return cAssertionParserRuleCall_1; }
	}
	public class EquationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.Equation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cLeftAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cLeftIDENTTerminalRuleCall_0_0 = (RuleCall)cLeftAssignment_0.eContents().get(0);
		private final Keyword cEqualsSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cRightAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cRightRight_PartParserRuleCall_2_0 = (RuleCall)cRightAssignment_2.eContents().get(0);
		private final Keyword cSemicolonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//Equation:
		//	left=IDENT '=' right=Right_Part ';';
		@Override public ParserRule getRule() { return rule; }
		
		//left=IDENT '=' right=Right_Part ';'
		public Group getGroup() { return cGroup; }
		
		//left=IDENT
		public Assignment getLeftAssignment_0() { return cLeftAssignment_0; }
		
		//IDENT
		public RuleCall getLeftIDENTTerminalRuleCall_0_0() { return cLeftIDENTTerminalRuleCall_0_0; }
		
		//'='
		public Keyword getEqualsSignKeyword_1() { return cEqualsSignKeyword_1; }
		
		//right=Right_Part
		public Assignment getRightAssignment_2() { return cRightAssignment_2; }
		
		//Right_Part
		public RuleCall getRightRight_PartParserRuleCall_2_0() { return cRightRight_PartParserRuleCall_2_0; }
		
		//';'
		public Keyword getSemicolonKeyword_3() { return cSemicolonKeyword_3; }
	}
	public class Left_PartElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.Left_Part");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final RuleCall cLeft_ListParserRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_0_2 = (Keyword)cGroup_0.eContents().get(2);
		private final RuleCall cLeft_ListParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//Left_Part:
		//	'(' Left_List ')'
		//	| Left_List;
		@Override public ParserRule getRule() { return rule; }
		
		//'(' Left_List ')' | Left_List
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'(' Left_List ')'
		public Group getGroup_0() { return cGroup_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_0_0() { return cLeftParenthesisKeyword_0_0; }
		
		//Left_List
		public RuleCall getLeft_ListParserRuleCall_0_1() { return cLeft_ListParserRuleCall_0_1; }
		
		//')'
		public Keyword getRightParenthesisKeyword_0_2() { return cRightParenthesisKeyword_0_2; }
		
		//Left_List
		public RuleCall getLeft_ListParserRuleCall_1() { return cLeft_ListParserRuleCall_1; }
	}
	public class Left_ListElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.Left_List");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cIdAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cIdLeftParserRuleCall_0_0 = (RuleCall)cIdAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCommaKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cIdAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cIdLeftParserRuleCall_1_1_0 = (RuleCall)cIdAssignment_1_1.eContents().get(0);
		
		//Left_List:
		//	id+=Left (',' id+=Left)*;
		@Override public ParserRule getRule() { return rule; }
		
		//id+=Left (',' id+=Left)*
		public Group getGroup() { return cGroup; }
		
		//id+=Left
		public Assignment getIdAssignment_0() { return cIdAssignment_0; }
		
		//Left
		public RuleCall getIdLeftParserRuleCall_0_0() { return cIdLeftParserRuleCall_0_0; }
		
		//(',' id+=Left)*
		public Group getGroup_1() { return cGroup_1; }
		
		//','
		public Keyword getCommaKeyword_1_0() { return cCommaKeyword_1_0; }
		
		//id+=Left
		public Assignment getIdAssignment_1_1() { return cIdAssignment_1_1; }
		
		//Left
		public RuleCall getIdLeftParserRuleCall_1_1_0() { return cIdLeftParserRuleCall_1_1_0; }
	}
	public class LeftElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.Left");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIdentifierParserRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Assignment cSelAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cSelSelectorParserRuleCall_1_0 = (RuleCall)cSelAssignment_1.eContents().get(0);
		
		//Left:
		//	name=Identifier sel=Selector?;
		@Override public ParserRule getRule() { return rule; }
		
		//name=Identifier sel=Selector?
		public Group getGroup() { return cGroup; }
		
		//name=Identifier
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//Identifier
		public RuleCall getNameIdentifierParserRuleCall_0_0() { return cNameIdentifierParserRuleCall_0_0; }
		
		//sel=Selector?
		public Assignment getSelAssignment_1() { return cSelAssignment_1; }
		
		//Selector
		public RuleCall getSelSelectorParserRuleCall_1_0() { return cSelSelectorParserRuleCall_1_0; }
	}
	public class SelectorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.Selector");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cFullStopKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final Assignment cNameAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cNameIDENTTerminalRuleCall_0_1_0 = (RuleCall)cNameAssignment_0_1.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cBeginAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cBeginExpressionParserRuleCall_1_1_0 = (RuleCall)cBeginAssignment_1_1.eContents().get(0);
		private final Assignment cEndAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cEndSelTrancheEndParserRuleCall_1_2_0 = (RuleCall)cEndAssignment_1_2.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_1_3 = (Keyword)cGroup_1.eContents().get(3);
		
		//Selector:
		//	'.' name=IDENT
		//	| '[' begin=Expression end=SelTrancheEnd? ']';
		@Override public ParserRule getRule() { return rule; }
		
		//'.' name=IDENT | '[' begin=Expression end=SelTrancheEnd? ']'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'.' name=IDENT
		public Group getGroup_0() { return cGroup_0; }
		
		//'.'
		public Keyword getFullStopKeyword_0_0() { return cFullStopKeyword_0_0; }
		
		//name=IDENT
		public Assignment getNameAssignment_0_1() { return cNameAssignment_0_1; }
		
		//IDENT
		public RuleCall getNameIDENTTerminalRuleCall_0_1_0() { return cNameIDENTTerminalRuleCall_0_1_0; }
		
		//'[' begin=Expression end=SelTrancheEnd? ']'
		public Group getGroup_1() { return cGroup_1; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_1_0() { return cLeftSquareBracketKeyword_1_0; }
		
		//begin=Expression
		public Assignment getBeginAssignment_1_1() { return cBeginAssignment_1_1; }
		
		//Expression
		public RuleCall getBeginExpressionParserRuleCall_1_1_0() { return cBeginExpressionParserRuleCall_1_1_0; }
		
		//end=SelTrancheEnd?
		public Assignment getEndAssignment_1_2() { return cEndAssignment_1_2; }
		
		//SelTrancheEnd
		public RuleCall getEndSelTrancheEndParserRuleCall_1_2_0() { return cEndSelTrancheEndParserRuleCall_1_2_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_1_3() { return cRightSquareBracketKeyword_1_3; }
	}
	public class SelTrancheEndElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.SelTrancheEnd");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cFullStopFullStopKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cExpressionParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		//SelTrancheEnd:
		//	'..' Expression;
		@Override public ParserRule getRule() { return rule; }
		
		//'..' Expression
		public Group getGroup() { return cGroup; }
		
		//'..'
		public Keyword getFullStopFullStopKeyword_0() { return cFullStopFullStopKeyword_0; }
		
		//Expression
		public RuleCall getExpressionParserRuleCall_1() { return cExpressionParserRuleCall_1; }
	}
	public class Right_PartElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.Right_Part");
		private final RuleCall cExpressionParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//Right_Part Expression:
		//	Expression
		@Override public ParserRule getRule() { return rule; }
		
		//Expression
		public RuleCall getExpressionParserRuleCall() { return cExpressionParserRuleCall; }
	}
	public class AssertionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.Assertion");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cAssertKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cExpressionParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Keyword cSemicolonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//Assertion:
		//	'assert' Expression ';';
		@Override public ParserRule getRule() { return rule; }
		
		//'assert' Expression ';'
		public Group getGroup() { return cGroup; }
		
		//'assert'
		public Keyword getAssertKeyword_0() { return cAssertKeyword_0; }
		
		//Expression
		public RuleCall getExpressionParserRuleCall_1() { return cExpressionParserRuleCall_1; }
		
		//';'
		public Keyword getSemicolonKeyword_2() { return cSemicolonKeyword_2; }
	}
	public class ExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.Expression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cIfThenElseAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Keyword cIfKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Assignment cIfexprAssignment_0_2 = (Assignment)cGroup_0.eContents().get(2);
		private final RuleCall cIfexprExpressionParserRuleCall_0_2_0 = (RuleCall)cIfexprAssignment_0_2.eContents().get(0);
		private final Keyword cThenKeyword_0_3 = (Keyword)cGroup_0.eContents().get(3);
		private final Assignment cThenexprAssignment_0_4 = (Assignment)cGroup_0.eContents().get(4);
		private final RuleCall cThenexprExpressionParserRuleCall_0_4_0 = (RuleCall)cThenexprAssignment_0_4.eContents().get(0);
		private final Keyword cElseKeyword_0_5 = (Keyword)cGroup_0.eContents().get(5);
		private final Assignment cElseexprAssignment_0_6 = (Assignment)cGroup_0.eContents().get(6);
		private final RuleCall cElseexprExpressionParserRuleCall_0_6_0 = (RuleCall)cElseexprAssignment_0_6.eContents().get(0);
		private final RuleCall cFbyParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		/// *
		// * Expressions
		// * / Expression:
		//	{IfThenElse} 'if' ifexpr=Expression 'then' thenexpr=Expression 'else' elseexpr=Expression
		//	//    | {Arrow} left=Expression '->' right=Expression
		//	| Fby;
		@Override public ParserRule getRule() { return rule; }
		
		//{IfThenElse} 'if' ifexpr=Expression 'then' thenexpr=Expression 'else' elseexpr=Expression //    | {Arrow} left=Expression '->' right=Expression
		//| Fby
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//{IfThenElse} 'if' ifexpr=Expression 'then' thenexpr=Expression 'else' elseexpr=Expression
		public Group getGroup_0() { return cGroup_0; }
		
		//{IfThenElse}
		public Action getIfThenElseAction_0_0() { return cIfThenElseAction_0_0; }
		
		//'if'
		public Keyword getIfKeyword_0_1() { return cIfKeyword_0_1; }
		
		//ifexpr=Expression
		public Assignment getIfexprAssignment_0_2() { return cIfexprAssignment_0_2; }
		
		//Expression
		public RuleCall getIfexprExpressionParserRuleCall_0_2_0() { return cIfexprExpressionParserRuleCall_0_2_0; }
		
		//'then'
		public Keyword getThenKeyword_0_3() { return cThenKeyword_0_3; }
		
		//thenexpr=Expression
		public Assignment getThenexprAssignment_0_4() { return cThenexprAssignment_0_4; }
		
		//Expression
		public RuleCall getThenexprExpressionParserRuleCall_0_4_0() { return cThenexprExpressionParserRuleCall_0_4_0; }
		
		//'else'
		public Keyword getElseKeyword_0_5() { return cElseKeyword_0_5; }
		
		//elseexpr=Expression
		public Assignment getElseexprAssignment_0_6() { return cElseexprAssignment_0_6; }
		
		//Expression
		public RuleCall getElseexprExpressionParserRuleCall_0_6_0() { return cElseexprExpressionParserRuleCall_0_6_0; }
		
		//Fby
		public RuleCall getFbyParserRuleCall_1() { return cFbyParserRuleCall_1; }
	}
	public class FbyElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.Fby");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cArrowParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cFbyLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cFbyKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightArrowParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Fby Expression:
		//	Arrow ({Fby.left=current} 'fby' right=Arrow)*
		@Override public ParserRule getRule() { return rule; }
		
		//Arrow ({Fby.left=current} 'fby' right=Arrow)*
		public Group getGroup() { return cGroup; }
		
		//Arrow
		public RuleCall getArrowParserRuleCall_0() { return cArrowParserRuleCall_0; }
		
		//({Fby.left=current} 'fby' right=Arrow)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{Fby.left=current}
		public Action getFbyLeftAction_1_0() { return cFbyLeftAction_1_0; }
		
		//'fby'
		public Keyword getFbyKeyword_1_1() { return cFbyKeyword_1_1; }
		
		//right=Arrow
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//Arrow
		public RuleCall getRightArrowParserRuleCall_1_2_0() { return cRightArrowParserRuleCall_1_2_0; }
	}
	public class ArrowElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.Arrow");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cOrParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cArrowLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cHyphenMinusGreaterThanSignKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightOrParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Arrow Expression:
		//	Or ({Arrow.left=current} '->' right=Or)*
		@Override public ParserRule getRule() { return rule; }
		
		//Or ({Arrow.left=current} '->' right=Or)*
		public Group getGroup() { return cGroup; }
		
		//Or
		public RuleCall getOrParserRuleCall_0() { return cOrParserRuleCall_0; }
		
		//({Arrow.left=current} '->' right=Or)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{Arrow.left=current}
		public Action getArrowLeftAction_1_0() { return cArrowLeftAction_1_0; }
		
		//'->'
		public Keyword getHyphenMinusGreaterThanSignKeyword_1_1() { return cHyphenMinusGreaterThanSignKeyword_1_1; }
		
		//right=Or
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//Or
		public RuleCall getRightOrParserRuleCall_1_2_0() { return cRightOrParserRuleCall_1_2_0; }
	}
	public class OrElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.Or");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAndParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cOrLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cOrKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightAndParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Or Expression:
		//	And ({Or.left=current} 'or' right=And)*
		@Override public ParserRule getRule() { return rule; }
		
		//And ({Or.left=current} 'or' right=And)*
		public Group getGroup() { return cGroup; }
		
		//And
		public RuleCall getAndParserRuleCall_0() { return cAndParserRuleCall_0; }
		
		//({Or.left=current} 'or' right=And)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{Or.left=current}
		public Action getOrLeftAction_1_0() { return cOrLeftAction_1_0; }
		
		//'or'
		public Keyword getOrKeyword_1_1() { return cOrKeyword_1_1; }
		
		//right=And
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//And
		public RuleCall getRightAndParserRuleCall_1_2_0() { return cRightAndParserRuleCall_1_2_0; }
	}
	public class AndElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.And");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cEqualityParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cAndLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cAndKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightEqualityParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//And Expression:
		//	Equality ({And.left=current} 'and' right=Equality)*
		@Override public ParserRule getRule() { return rule; }
		
		//Equality ({And.left=current} 'and' right=Equality)*
		public Group getGroup() { return cGroup; }
		
		//Equality
		public RuleCall getEqualityParserRuleCall_0() { return cEqualityParserRuleCall_0; }
		
		//({And.left=current} 'and' right=Equality)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{And.left=current}
		public Action getAndLeftAction_1_0() { return cAndLeftAction_1_0; }
		
		//'and'
		public Keyword getAndKeyword_1_1() { return cAndKeyword_1_1; }
		
		//right=Equality
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//Equality
		public RuleCall getRightEqualityParserRuleCall_1_2_0() { return cRightEqualityParserRuleCall_1_2_0; }
	}
	public class EqualityElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.Equality");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cComparisonParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cEqualityLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Alternatives cOpAlternatives_1_1_0 = (Alternatives)cOpAssignment_1_1.eContents().get(0);
		private final Keyword cOpEqualsSignKeyword_1_1_0_0 = (Keyword)cOpAlternatives_1_1_0.eContents().get(0);
		private final Keyword cOpLessThanSignGreaterThanSignKeyword_1_1_0_1 = (Keyword)cOpAlternatives_1_1_0.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightComparisonParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Equality Expression:
		//	Comparison ({Equality.left=current} op=('=' | '<>') right=Comparison)*
		@Override public ParserRule getRule() { return rule; }
		
		//Comparison ({Equality.left=current} op=('=' | '<>') right=Comparison)*
		public Group getGroup() { return cGroup; }
		
		//Comparison
		public RuleCall getComparisonParserRuleCall_0() { return cComparisonParserRuleCall_0; }
		
		//({Equality.left=current} op=('=' | '<>') right=Comparison)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{Equality.left=current}
		public Action getEqualityLeftAction_1_0() { return cEqualityLeftAction_1_0; }
		
		//op=('=' | '<>')
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }
		
		//('=' | '<>')
		public Alternatives getOpAlternatives_1_1_0() { return cOpAlternatives_1_1_0; }
		
		//'='
		public Keyword getOpEqualsSignKeyword_1_1_0_0() { return cOpEqualsSignKeyword_1_1_0_0; }
		
		//'<>'
		public Keyword getOpLessThanSignGreaterThanSignKeyword_1_1_0_1() { return cOpLessThanSignGreaterThanSignKeyword_1_1_0_1; }
		
		//right=Comparison
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//Comparison
		public RuleCall getRightComparisonParserRuleCall_1_2_0() { return cRightComparisonParserRuleCall_1_2_0; }
	}
	public class ComparisonElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.Comparison");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cPlusOrMinusParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cComparisonLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Alternatives cOpAlternatives_1_1_0 = (Alternatives)cOpAssignment_1_1.eContents().get(0);
		private final Keyword cOpGreaterThanSignEqualsSignKeyword_1_1_0_0 = (Keyword)cOpAlternatives_1_1_0.eContents().get(0);
		private final Keyword cOpLessThanSignEqualsSignKeyword_1_1_0_1 = (Keyword)cOpAlternatives_1_1_0.eContents().get(1);
		private final Keyword cOpGreaterThanSignKeyword_1_1_0_2 = (Keyword)cOpAlternatives_1_1_0.eContents().get(2);
		private final Keyword cOpLessThanSignKeyword_1_1_0_3 = (Keyword)cOpAlternatives_1_1_0.eContents().get(3);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightPlusOrMinusParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Comparison Expression:
		//	PlusOrMinus ({Comparison.left=current} op=('>=' | '<=' | '>' | '<') right=PlusOrMinus)*
		@Override public ParserRule getRule() { return rule; }
		
		//PlusOrMinus ({Comparison.left=current} op=('>=' | '<=' | '>' | '<') right=PlusOrMinus)*
		public Group getGroup() { return cGroup; }
		
		//PlusOrMinus
		public RuleCall getPlusOrMinusParserRuleCall_0() { return cPlusOrMinusParserRuleCall_0; }
		
		//({Comparison.left=current} op=('>=' | '<=' | '>' | '<') right=PlusOrMinus)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{Comparison.left=current}
		public Action getComparisonLeftAction_1_0() { return cComparisonLeftAction_1_0; }
		
		//op=('>=' | '<=' | '>' | '<')
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }
		
		//('>=' | '<=' | '>' | '<')
		public Alternatives getOpAlternatives_1_1_0() { return cOpAlternatives_1_1_0; }
		
		//'>='
		public Keyword getOpGreaterThanSignEqualsSignKeyword_1_1_0_0() { return cOpGreaterThanSignEqualsSignKeyword_1_1_0_0; }
		
		//'<='
		public Keyword getOpLessThanSignEqualsSignKeyword_1_1_0_1() { return cOpLessThanSignEqualsSignKeyword_1_1_0_1; }
		
		//'>'
		public Keyword getOpGreaterThanSignKeyword_1_1_0_2() { return cOpGreaterThanSignKeyword_1_1_0_2; }
		
		//'<'
		public Keyword getOpLessThanSignKeyword_1_1_0_3() { return cOpLessThanSignKeyword_1_1_0_3; }
		
		//right=PlusOrMinus
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//PlusOrMinus
		public RuleCall getRightPlusOrMinusParserRuleCall_1_2_0() { return cRightPlusOrMinusParserRuleCall_1_2_0; }
	}
	public class PlusOrMinusElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.PlusOrMinus");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cMulOrDivParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_1_0 = (Alternatives)cGroup_1.eContents().get(0);
		private final Group cGroup_1_0_0 = (Group)cAlternatives_1_0.eContents().get(0);
		private final Action cPlusLeftAction_1_0_0_0 = (Action)cGroup_1_0_0.eContents().get(0);
		private final Keyword cPlusSignKeyword_1_0_0_1 = (Keyword)cGroup_1_0_0.eContents().get(1);
		private final Group cGroup_1_0_1 = (Group)cAlternatives_1_0.eContents().get(1);
		private final Action cMinusLeftAction_1_0_1_0 = (Action)cGroup_1_0_1.eContents().get(0);
		private final Keyword cHyphenMinusKeyword_1_0_1_1 = (Keyword)cGroup_1_0_1.eContents().get(1);
		private final Assignment cRightAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightMulOrDivParserRuleCall_1_1_0 = (RuleCall)cRightAssignment_1_1.eContents().get(0);
		
		//PlusOrMinus Expression:
		//	MulOrDiv (({Plus.left=current} '+' | {Minus.left=current} '-') right=MulOrDiv)*
		@Override public ParserRule getRule() { return rule; }
		
		//MulOrDiv (({Plus.left=current} '+' | {Minus.left=current} '-') right=MulOrDiv)*
		public Group getGroup() { return cGroup; }
		
		//MulOrDiv
		public RuleCall getMulOrDivParserRuleCall_0() { return cMulOrDivParserRuleCall_0; }
		
		//(({Plus.left=current} '+' | {Minus.left=current} '-') right=MulOrDiv)*
		public Group getGroup_1() { return cGroup_1; }
		
		//({Plus.left=current} '+' | {Minus.left=current} '-')
		public Alternatives getAlternatives_1_0() { return cAlternatives_1_0; }
		
		//{Plus.left=current} '+'
		public Group getGroup_1_0_0() { return cGroup_1_0_0; }
		
		//{Plus.left=current}
		public Action getPlusLeftAction_1_0_0_0() { return cPlusLeftAction_1_0_0_0; }
		
		//'+'
		public Keyword getPlusSignKeyword_1_0_0_1() { return cPlusSignKeyword_1_0_0_1; }
		
		//{Minus.left=current} '-'
		public Group getGroup_1_0_1() { return cGroup_1_0_1; }
		
		//{Minus.left=current}
		public Action getMinusLeftAction_1_0_1_0() { return cMinusLeftAction_1_0_1_0; }
		
		//'-'
		public Keyword getHyphenMinusKeyword_1_0_1_1() { return cHyphenMinusKeyword_1_0_1_1; }
		
		//right=MulOrDiv
		public Assignment getRightAssignment_1_1() { return cRightAssignment_1_1; }
		
		//MulOrDiv
		public RuleCall getRightMulOrDivParserRuleCall_1_1_0() { return cRightMulOrDivParserRuleCall_1_1_0; }
	}
	public class MulOrDivElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.MulOrDiv");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cPrimaryParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_1_0 = (Alternatives)cGroup_1.eContents().get(0);
		private final Group cGroup_1_0_0 = (Group)cAlternatives_1_0.eContents().get(0);
		private final Action cMulLeftAction_1_0_0_0 = (Action)cGroup_1_0_0.eContents().get(0);
		private final Keyword cAsteriskKeyword_1_0_0_1 = (Keyword)cGroup_1_0_0.eContents().get(1);
		private final Group cGroup_1_0_1 = (Group)cAlternatives_1_0.eContents().get(1);
		private final Action cDivLeftAction_1_0_1_0 = (Action)cGroup_1_0_1.eContents().get(0);
		private final Keyword cSolidusKeyword_1_0_1_1 = (Keyword)cGroup_1_0_1.eContents().get(1);
		private final Assignment cRightAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightPrimaryParserRuleCall_1_1_0 = (RuleCall)cRightAssignment_1_1.eContents().get(0);
		
		//MulOrDiv Expression:
		//	Primary (({Mul.left=current} '*' | {Div.left=current} '/') right=Primary)*
		@Override public ParserRule getRule() { return rule; }
		
		//Primary (({Mul.left=current} '*' | {Div.left=current} '/') right=Primary)*
		public Group getGroup() { return cGroup; }
		
		//Primary
		public RuleCall getPrimaryParserRuleCall_0() { return cPrimaryParserRuleCall_0; }
		
		//(({Mul.left=current} '*' | {Div.left=current} '/') right=Primary)*
		public Group getGroup_1() { return cGroup_1; }
		
		//({Mul.left=current} '*' | {Div.left=current} '/')
		public Alternatives getAlternatives_1_0() { return cAlternatives_1_0; }
		
		//{Mul.left=current} '*'
		public Group getGroup_1_0_0() { return cGroup_1_0_0; }
		
		//{Mul.left=current}
		public Action getMulLeftAction_1_0_0_0() { return cMulLeftAction_1_0_0_0; }
		
		//'*'
		public Keyword getAsteriskKeyword_1_0_0_1() { return cAsteriskKeyword_1_0_0_1; }
		
		//{Div.left=current} '/'
		public Group getGroup_1_0_1() { return cGroup_1_0_1; }
		
		//{Div.left=current}
		public Action getDivLeftAction_1_0_1_0() { return cDivLeftAction_1_0_1_0; }
		
		//'/'
		public Keyword getSolidusKeyword_1_0_1_1() { return cSolidusKeyword_1_0_1_1; }
		
		//right=Primary
		public Assignment getRightAssignment_1_1() { return cRightAssignment_1_1; }
		
		//Primary
		public RuleCall getRightPrimaryParserRuleCall_1_1_0() { return cRightPrimaryParserRuleCall_1_1_0; }
	}
	public class PrimaryElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.Primary");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final RuleCall cExpressionParserRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_0_2 = (Keyword)cGroup_0.eContents().get(2);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cNotAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cNotKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cExpressionAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cExpressionPrimaryParserRuleCall_1_2_0 = (RuleCall)cExpressionAssignment_1_2.eContents().get(0);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Action cUMinusAction_2_0 = (Action)cGroup_2.eContents().get(0);
		private final Keyword cHyphenMinusKeyword_2_1 = (Keyword)cGroup_2.eContents().get(1);
		private final Assignment cExpressionAssignment_2_2 = (Assignment)cGroup_2.eContents().get(2);
		private final RuleCall cExpressionPrimaryParserRuleCall_2_2_0 = (RuleCall)cExpressionAssignment_2_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cAlternatives.eContents().get(3);
		private final Action cPreAction_3_0 = (Action)cGroup_3.eContents().get(0);
		private final Keyword cPreKeyword_3_1 = (Keyword)cGroup_3.eContents().get(1);
		private final Assignment cExpressionAssignment_3_2 = (Assignment)cGroup_3.eContents().get(2);
		private final RuleCall cExpressionPrimaryParserRuleCall_3_2_0 = (RuleCall)cExpressionAssignment_3_2.eContents().get(0);
		private final Group cGroup_4 = (Group)cAlternatives.eContents().get(4);
		private final Action cCurrentAction_4_0 = (Action)cGroup_4.eContents().get(0);
		private final Keyword cCurrentKeyword_4_1 = (Keyword)cGroup_4.eContents().get(1);
		private final Assignment cExpressionAssignment_4_2 = (Assignment)cGroup_4.eContents().get(2);
		private final RuleCall cExpressionPrimaryParserRuleCall_4_2_0 = (RuleCall)cExpressionAssignment_4_2.eContents().get(0);
		private final RuleCall cAtomicExpressionParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		
		//Primary Expression:
		//	'(' Expression ')'
		//	| {Not} 'not' expression=Primary
		//	| {UMinus} '-' expression=Primary
		//	| {Pre} 'pre' expression=Primary
		//	| {Current} 'current' expression=Primary
		//	| AtomicExpression
		@Override public ParserRule getRule() { return rule; }
		
		//'(' Expression ')' | {Not} 'not' expression=Primary | {UMinus} '-' expression=Primary | {Pre} 'pre' expression=Primary |
		//{Current} 'current' expression=Primary | AtomicExpression
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'(' Expression ')'
		public Group getGroup_0() { return cGroup_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_0_0() { return cLeftParenthesisKeyword_0_0; }
		
		//Expression
		public RuleCall getExpressionParserRuleCall_0_1() { return cExpressionParserRuleCall_0_1; }
		
		//')'
		public Keyword getRightParenthesisKeyword_0_2() { return cRightParenthesisKeyword_0_2; }
		
		//{Not} 'not' expression=Primary
		public Group getGroup_1() { return cGroup_1; }
		
		//{Not}
		public Action getNotAction_1_0() { return cNotAction_1_0; }
		
		//'not'
		public Keyword getNotKeyword_1_1() { return cNotKeyword_1_1; }
		
		//expression=Primary
		public Assignment getExpressionAssignment_1_2() { return cExpressionAssignment_1_2; }
		
		//Primary
		public RuleCall getExpressionPrimaryParserRuleCall_1_2_0() { return cExpressionPrimaryParserRuleCall_1_2_0; }
		
		//{UMinus} '-' expression=Primary
		public Group getGroup_2() { return cGroup_2; }
		
		//{UMinus}
		public Action getUMinusAction_2_0() { return cUMinusAction_2_0; }
		
		//'-'
		public Keyword getHyphenMinusKeyword_2_1() { return cHyphenMinusKeyword_2_1; }
		
		//expression=Primary
		public Assignment getExpressionAssignment_2_2() { return cExpressionAssignment_2_2; }
		
		//Primary
		public RuleCall getExpressionPrimaryParserRuleCall_2_2_0() { return cExpressionPrimaryParserRuleCall_2_2_0; }
		
		//{Pre} 'pre' expression=Primary
		public Group getGroup_3() { return cGroup_3; }
		
		//{Pre}
		public Action getPreAction_3_0() { return cPreAction_3_0; }
		
		//'pre'
		public Keyword getPreKeyword_3_1() { return cPreKeyword_3_1; }
		
		//expression=Primary
		public Assignment getExpressionAssignment_3_2() { return cExpressionAssignment_3_2; }
		
		//Primary
		public RuleCall getExpressionPrimaryParserRuleCall_3_2_0() { return cExpressionPrimaryParserRuleCall_3_2_0; }
		
		//{Current} 'current' expression=Primary
		public Group getGroup_4() { return cGroup_4; }
		
		//{Current}
		public Action getCurrentAction_4_0() { return cCurrentAction_4_0; }
		
		//'current'
		public Keyword getCurrentKeyword_4_1() { return cCurrentKeyword_4_1; }
		
		//expression=Primary
		public Assignment getExpressionAssignment_4_2() { return cExpressionAssignment_4_2; }
		
		//Primary
		public RuleCall getExpressionPrimaryParserRuleCall_4_2_0() { return cExpressionPrimaryParserRuleCall_4_2_0; }
		
		//AtomicExpression
		public RuleCall getAtomicExpressionParserRuleCall_5() { return cAtomicExpressionParserRuleCall_5; }
	}
	public class AtomicExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.AtomicExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cConstantExpressionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cVariablerefAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cValueAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cValueIDENTTerminalRuleCall_1_1_0 = (RuleCall)cValueAssignment_1_1.eContents().get(0);
		
		//AtomicExpression Expression:
		//	ConstantExpression | {Variableref} value=IDENT
		@Override public ParserRule getRule() { return rule; }
		
		//ConstantExpression | {Variableref} value=IDENT
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//ConstantExpression
		public RuleCall getConstantExpressionParserRuleCall_0() { return cConstantExpressionParserRuleCall_0; }
		
		//{Variableref} value=IDENT
		public Group getGroup_1() { return cGroup_1; }
		
		//{Variableref}
		public Action getVariablerefAction_1_0() { return cVariablerefAction_1_0; }
		
		//value=IDENT
		public Assignment getValueAssignment_1_1() { return cValueAssignment_1_1; }
		
		//IDENT
		public RuleCall getValueIDENTTerminalRuleCall_1_1_0() { return cValueIDENTTerminalRuleCall_1_1_0; }
	}
	public class ConstantExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.ConstantExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cBooleanConstantAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Assignment cValueAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cValueBOOLTerminalRuleCall_0_1_0 = (RuleCall)cValueAssignment_0_1.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cFloatConstantAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cValueAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cValueFLOATTerminalRuleCall_1_1_0 = (RuleCall)cValueAssignment_1_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Action cIntConstantAction_2_0 = (Action)cGroup_2.eContents().get(0);
		private final Assignment cValueAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cValueINTTerminalRuleCall_2_1_0 = (RuleCall)cValueAssignment_2_1.eContents().get(0);
		
		//ConstantExpression Expression:
		//	{BooleanConstant} value=BOOL
		//	| {FloatConstant} value=FLOAT
		//	| {IntConstant} value=INT
		@Override public ParserRule getRule() { return rule; }
		
		//{BooleanConstant} value=BOOL | {FloatConstant} value=FLOAT | {IntConstant} value=INT
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//{BooleanConstant} value=BOOL
		public Group getGroup_0() { return cGroup_0; }
		
		//{BooleanConstant}
		public Action getBooleanConstantAction_0_0() { return cBooleanConstantAction_0_0; }
		
		//value=BOOL
		public Assignment getValueAssignment_0_1() { return cValueAssignment_0_1; }
		
		//BOOL
		public RuleCall getValueBOOLTerminalRuleCall_0_1_0() { return cValueBOOLTerminalRuleCall_0_1_0; }
		
		//{FloatConstant} value=FLOAT
		public Group getGroup_1() { return cGroup_1; }
		
		//{FloatConstant}
		public Action getFloatConstantAction_1_0() { return cFloatConstantAction_1_0; }
		
		//value=FLOAT
		public Assignment getValueAssignment_1_1() { return cValueAssignment_1_1; }
		
		//FLOAT
		public RuleCall getValueFLOATTerminalRuleCall_1_1_0() { return cValueFLOATTerminalRuleCall_1_1_0; }
		
		//{IntConstant} value=INT
		public Group getGroup_2() { return cGroup_2; }
		
		//{IntConstant}
		public Action getIntConstantAction_2_0() { return cIntConstantAction_2_0; }
		
		//value=INT
		public Assignment getValueAssignment_2_1() { return cValueAssignment_2_1; }
		
		//INT
		public RuleCall getValueINTTerminalRuleCall_2_1_0() { return cValueINTTerminalRuleCall_2_1_0; }
	}
	
	
	private final ProgramElements pProgram;
	private final PackageElements pPackage;
	private final Package_HeaderElements pPackage_Header;
	private final Package_ProvideElements pPackage_Provide;
	private final Package_Body_ContentElements pPackage_Body_Content;
	private final Entity_DeclElements pEntity_Decl;
	private final PragmaElements pPragma;
	private final IdentifierElements pIdentifier;
	private final Type_DeclElements pType_Decl;
	private final TypeElements pType;
	private final Record_TypeElements pRecord_Type;
	private final Field_ListElements pField_List;
	private final FieldElements pField;
	private final Enum_TypeElements pEnum_Type;
	private final Const_DeclElements pConst_Decl;
	private final Ident_ListElements pIdent_List;
	private final Node_DeclElements pNode_Decl;
	private final Node_HeaderElements pNode_Header;
	private final Var_Decl_ListElements pVar_Decl_List;
	private final Var_DeclElements pVar_Decl;
	private final Declared_ClockElements pDeclared_Clock;
	private final FN_BodyElements pFN_Body;
	private final Local_Var_DeclElements pLocal_Var_Decl;
	private final Equation_ListElements pEquation_List;
	private final Eq_or_AstElements pEq_or_Ast;
	private final EquationElements pEquation;
	private final Left_PartElements pLeft_Part;
	private final Left_ListElements pLeft_List;
	private final LeftElements pLeft;
	private final SelectorElements pSelector;
	private final SelTrancheEndElements pSelTrancheEnd;
	private final Right_PartElements pRight_Part;
	private final AssertionElements pAssertion;
	private final ExpressionElements pExpression;
	private final FbyElements pFby;
	private final ArrowElements pArrow;
	private final OrElements pOr;
	private final AndElements pAnd;
	private final EqualityElements pEquality;
	private final ComparisonElements pComparison;
	private final PlusOrMinusElements pPlusOrMinus;
	private final MulOrDivElements pMulOrDiv;
	private final PrimaryElements pPrimary;
	private final AtomicExpressionElements pAtomicExpression;
	private final ConstantExpressionElements pConstantExpression;
	private final TerminalRule tBOOL;
	private final TerminalRule tIDENT;
	private final TerminalRule tINT;
	private final TerminalRule tFLOAT;
	private final TerminalRule tSTRING_CONST;
	private final TerminalRule tLUSTRE_COMMENT;
	private final TerminalRule tLUSTRE_ML_COMMENT;
	private final TerminalRule tLUSTRE_SL_COMMENT;
	private final TerminalRule tWS;
	
	private final Grammar grammar;

	@Inject
	public LustreGrammarAccess(GrammarProvider grammarProvider) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.pProgram = new ProgramElements();
		this.pPackage = new PackageElements();
		this.pPackage_Header = new Package_HeaderElements();
		this.pPackage_Provide = new Package_ProvideElements();
		this.pPackage_Body_Content = new Package_Body_ContentElements();
		this.pEntity_Decl = new Entity_DeclElements();
		this.pPragma = new PragmaElements();
		this.pIdentifier = new IdentifierElements();
		this.pType_Decl = new Type_DeclElements();
		this.pType = new TypeElements();
		this.pRecord_Type = new Record_TypeElements();
		this.pField_List = new Field_ListElements();
		this.pField = new FieldElements();
		this.pEnum_Type = new Enum_TypeElements();
		this.pConst_Decl = new Const_DeclElements();
		this.pIdent_List = new Ident_ListElements();
		this.pNode_Decl = new Node_DeclElements();
		this.pNode_Header = new Node_HeaderElements();
		this.pVar_Decl_List = new Var_Decl_ListElements();
		this.pVar_Decl = new Var_DeclElements();
		this.pDeclared_Clock = new Declared_ClockElements();
		this.pFN_Body = new FN_BodyElements();
		this.pLocal_Var_Decl = new Local_Var_DeclElements();
		this.pEquation_List = new Equation_ListElements();
		this.pEq_or_Ast = new Eq_or_AstElements();
		this.pEquation = new EquationElements();
		this.pLeft_Part = new Left_PartElements();
		this.pLeft_List = new Left_ListElements();
		this.pLeft = new LeftElements();
		this.pSelector = new SelectorElements();
		this.pSelTrancheEnd = new SelTrancheEndElements();
		this.pRight_Part = new Right_PartElements();
		this.pAssertion = new AssertionElements();
		this.pExpression = new ExpressionElements();
		this.pFby = new FbyElements();
		this.pArrow = new ArrowElements();
		this.pOr = new OrElements();
		this.pAnd = new AndElements();
		this.pEquality = new EqualityElements();
		this.pComparison = new ComparisonElements();
		this.pPlusOrMinus = new PlusOrMinusElements();
		this.pMulOrDiv = new MulOrDivElements();
		this.pPrimary = new PrimaryElements();
		this.pAtomicExpression = new AtomicExpressionElements();
		this.pConstantExpression = new ConstantExpressionElements();
		this.tBOOL = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.BOOL");
		this.tIDENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.IDENT");
		this.tINT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.INT");
		this.tFLOAT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.FLOAT");
		this.tSTRING_CONST = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.STRING_CONST");
		this.tLUSTRE_COMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.LUSTRE_COMMENT");
		this.tLUSTRE_ML_COMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.LUSTRE_ML_COMMENT");
		this.tLUSTRE_SL_COMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.LUSTRE_SL_COMMENT");
		this.tWS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.WS");
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("de.cau.cs.kieler.lustre.Lustre".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	

	
	//Program hidden(WS, LUSTRE_COMMENT):
	//	pkg=Package;
	public ProgramElements getProgramAccess() {
		return pProgram;
	}
	
	public ParserRule getProgramRule() {
		return getProgramAccess().getRule();
	}
	
	//Package:
	//	head=Package_Header body=Package_Body_Content 'end';
	public PackageElements getPackageAccess() {
		return pPackage;
	}
	
	public ParserRule getPackageRule() {
		return getPackageAccess().getRule();
	}
	
	//Package_Header:
	//	'package' name=IDENT ('uses' uses=Ident_List)? 'provides' provides+=Package_Provide+;
	public Package_HeaderElements getPackage_HeaderAccess() {
		return pPackage_Header;
	}
	
	public ParserRule getPackage_HeaderRule() {
		return getPackage_HeaderAccess().getRule();
	}
	
	//Package_Provide:
	//	'node' name=[Node_Header|IDENT] '(' param=Var_Decl_List ')' 'returns' '(' ret=Var_Decl_List ')' ';';
	public Package_ProvideElements getPackage_ProvideAccess() {
		return pPackage_Provide;
	}
	
	public ParserRule getPackage_ProvideRule() {
		return getPackage_ProvideAccess().getRule();
	}
	
	//Package_Body_Content:
	//	'body' entities+=Entity_Decl+;
	public Package_Body_ContentElements getPackage_Body_ContentAccess() {
		return pPackage_Body_Content;
	}
	
	public ParserRule getPackage_Body_ContentRule() {
		return getPackage_Body_ContentAccess().getRule();
	}
	
	//Entity_Decl Node_Decl:
	//	Node_Decl
	public Entity_DeclElements getEntity_DeclAccess() {
		return pEntity_Decl;
	}
	
	public ParserRule getEntity_DeclRule() {
		return getEntity_DeclAccess().getRule();
	}
	
	/// *
	// * Pragmas
	// * / Pragma:
	//	('%' STRING_CONST '%')*;
	public PragmaElements getPragmaAccess() {
		return pPragma;
	}
	
	public ParserRule getPragmaRule() {
		return getPragmaAccess().getRule();
	}
	
	/// *
	// * Identifiers
	// * / Identifier:
	//	(pkg=IDENT fromPgk?='::')? name=IDENT;
	public IdentifierElements getIdentifierAccess() {
		return pIdentifier;
	}
	
	public ParserRule getIdentifierRule() {
		return getIdentifierAccess().getRule();
	}
	
	/// * 
	// * Types
	// * / Type_Decl:
	//	'type' name=IDENT ';'
	//	| 'type' name=IDENT '=' type=Type ';';
	public Type_DeclElements getType_DeclAccess() {
		return pType_Decl;
	}
	
	public ParserRule getType_DeclRule() {
		return getType_DeclAccess().getRule();
	}
	
	//Type:
	//	name=IDENT
	//	//    | Record_Type
	//	//    | Array_Type
	//	//    | Enum_Type;
	//;
	public TypeElements getTypeAccess() {
		return pType;
	}
	
	public ParserRule getTypeRule() {
		return getTypeAccess().getRule();
	}
	
	//Record_Type:
	//	'struct' '{' fields=Field_List '}';
	public Record_TypeElements getRecord_TypeAccess() {
		return pRecord_Type;
	}
	
	public ParserRule getRecord_TypeRule() {
		return getRecord_TypeAccess().getRule();
	}
	
	//Field_List:
	//	fields+=Field (',' fields+=Field)*;
	public Field_ListElements getField_ListAccess() {
		return pField_List;
	}
	
	public ParserRule getField_ListRule() {
		return getField_ListAccess().getRule();
	}
	
	//Field:
	//	name=IDENT ':' type=Type;
	public FieldElements getFieldAccess() {
		return pField;
	}
	
	public ParserRule getFieldRule() {
		return getFieldAccess().getRule();
	}
	
	//Enum_Type:
	//	'enum' '{' nameList=Ident_List '}';
	public Enum_TypeElements getEnum_TypeAccess() {
		return pEnum_Type;
	}
	
	public ParserRule getEnum_TypeRule() {
		return getEnum_TypeAccess().getRule();
	}
	
	/// *
	// * Constants and variables
	// * / Const_Decl:
	//	'const' name=IDENT ':' type=Type ';'
	//	| 'const' name=IDENT '=' expr=Expression ';'
	//	| 'const' name=IDENT ':' type=Type '=' expr=Expression ';';
	public Const_DeclElements getConst_DeclAccess() {
		return pConst_Decl;
	}
	
	public ParserRule getConst_DeclRule() {
		return getConst_DeclAccess().getRule();
	}
	
	//Ident_List:
	//	names+=IDENT (',' names+=IDENT)*;
	public Ident_ListElements getIdent_ListAccess() {
		return pIdent_List;
	}
	
	public ParserRule getIdent_ListRule() {
		return getIdent_ListAccess().getRule();
	}
	
	//Node_Decl:
	//	head=Node_Header bdy=FN_Body;
	public Node_DeclElements getNode_DeclAccess() {
		return pNode_Decl;
	}
	
	public ParserRule getNode_DeclRule() {
		return getNode_DeclAccess().getRule();
	}
	
	//Node_Header:
	//	'node' name=IDENT '(' param=Var_Decl_List ')' 'returns' '(' ret=Var_Decl_List ')' ';';
	public Node_HeaderElements getNode_HeaderAccess() {
		return pNode_Header;
	}
	
	public ParserRule getNode_HeaderRule() {
		return getNode_HeaderAccess().getRule();
	}
	
	//Var_Decl_List:
	//	varList+=Var_Decl (',' varList+=Var_Decl)*;
	public Var_Decl_ListElements getVar_Decl_ListAccess() {
		return pVar_Decl_List;
	}
	
	public ParserRule getVar_Decl_ListRule() {
		return getVar_Decl_ListAccess().getRule();
	}
	
	//Var_Decl:
	//	name=IDENT ':' type=Type clk=Declared_Clock?;
	public Var_DeclElements getVar_DeclAccess() {
		return pVar_Decl;
	}
	
	public ParserRule getVar_DeclRule() {
		return getVar_DeclAccess().getRule();
	}
	
	//Declared_Clock:
	//	'when' name=Identifier;
	public Declared_ClockElements getDeclared_ClockAccess() {
		return pDeclared_Clock;
	}
	
	public ParserRule getDeclared_ClockRule() {
		return getDeclared_ClockAccess().getRule();
	}
	
	//FN_Body:
	//	{FN_Body} decl+=Local_Var_Decl* 'let' eq+=Equation* 'tel' ';'?;
	public FN_BodyElements getFN_BodyAccess() {
		return pFN_Body;
	}
	
	public ParserRule getFN_BodyRule() {
		return getFN_BodyAccess().getRule();
	}
	
	//Local_Var_Decl Var_Decl:
	//	'var' Var_Decl ';'
	public Local_Var_DeclElements getLocal_Var_DeclAccess() {
		return pLocal_Var_Decl;
	}
	
	public ParserRule getLocal_Var_DeclRule() {
		return getLocal_Var_DeclAccess().getRule();
	}
	
	//Equation_List:
	//	{Equation_List} eq+=Eq_or_Ast*;
	public Equation_ListElements getEquation_ListAccess() {
		return pEquation_List;
	}
	
	public ParserRule getEquation_ListRule() {
		return getEquation_ListAccess().getRule();
	}
	
	//Eq_or_Ast:
	//	Equation
	//	| Assertion;
	public Eq_or_AstElements getEq_or_AstAccess() {
		return pEq_or_Ast;
	}
	
	public ParserRule getEq_or_AstRule() {
		return getEq_or_AstAccess().getRule();
	}
	
	//Equation:
	//	left=IDENT '=' right=Right_Part ';';
	public EquationElements getEquationAccess() {
		return pEquation;
	}
	
	public ParserRule getEquationRule() {
		return getEquationAccess().getRule();
	}
	
	//Left_Part:
	//	'(' Left_List ')'
	//	| Left_List;
	public Left_PartElements getLeft_PartAccess() {
		return pLeft_Part;
	}
	
	public ParserRule getLeft_PartRule() {
		return getLeft_PartAccess().getRule();
	}
	
	//Left_List:
	//	id+=Left (',' id+=Left)*;
	public Left_ListElements getLeft_ListAccess() {
		return pLeft_List;
	}
	
	public ParserRule getLeft_ListRule() {
		return getLeft_ListAccess().getRule();
	}
	
	//Left:
	//	name=Identifier sel=Selector?;
	public LeftElements getLeftAccess() {
		return pLeft;
	}
	
	public ParserRule getLeftRule() {
		return getLeftAccess().getRule();
	}
	
	//Selector:
	//	'.' name=IDENT
	//	| '[' begin=Expression end=SelTrancheEnd? ']';
	public SelectorElements getSelectorAccess() {
		return pSelector;
	}
	
	public ParserRule getSelectorRule() {
		return getSelectorAccess().getRule();
	}
	
	//SelTrancheEnd:
	//	'..' Expression;
	public SelTrancheEndElements getSelTrancheEndAccess() {
		return pSelTrancheEnd;
	}
	
	public ParserRule getSelTrancheEndRule() {
		return getSelTrancheEndAccess().getRule();
	}
	
	//Right_Part Expression:
	//	Expression
	public Right_PartElements getRight_PartAccess() {
		return pRight_Part;
	}
	
	public ParserRule getRight_PartRule() {
		return getRight_PartAccess().getRule();
	}
	
	//Assertion:
	//	'assert' Expression ';';
	public AssertionElements getAssertionAccess() {
		return pAssertion;
	}
	
	public ParserRule getAssertionRule() {
		return getAssertionAccess().getRule();
	}
	
	/// *
	// * Expressions
	// * / Expression:
	//	{IfThenElse} 'if' ifexpr=Expression 'then' thenexpr=Expression 'else' elseexpr=Expression
	//	//    | {Arrow} left=Expression '->' right=Expression
	//	| Fby;
	public ExpressionElements getExpressionAccess() {
		return pExpression;
	}
	
	public ParserRule getExpressionRule() {
		return getExpressionAccess().getRule();
	}
	
	//Fby Expression:
	//	Arrow ({Fby.left=current} 'fby' right=Arrow)*
	public FbyElements getFbyAccess() {
		return pFby;
	}
	
	public ParserRule getFbyRule() {
		return getFbyAccess().getRule();
	}
	
	//Arrow Expression:
	//	Or ({Arrow.left=current} '->' right=Or)*
	public ArrowElements getArrowAccess() {
		return pArrow;
	}
	
	public ParserRule getArrowRule() {
		return getArrowAccess().getRule();
	}
	
	//Or Expression:
	//	And ({Or.left=current} 'or' right=And)*
	public OrElements getOrAccess() {
		return pOr;
	}
	
	public ParserRule getOrRule() {
		return getOrAccess().getRule();
	}
	
	//And Expression:
	//	Equality ({And.left=current} 'and' right=Equality)*
	public AndElements getAndAccess() {
		return pAnd;
	}
	
	public ParserRule getAndRule() {
		return getAndAccess().getRule();
	}
	
	//Equality Expression:
	//	Comparison ({Equality.left=current} op=('=' | '<>') right=Comparison)*
	public EqualityElements getEqualityAccess() {
		return pEquality;
	}
	
	public ParserRule getEqualityRule() {
		return getEqualityAccess().getRule();
	}
	
	//Comparison Expression:
	//	PlusOrMinus ({Comparison.left=current} op=('>=' | '<=' | '>' | '<') right=PlusOrMinus)*
	public ComparisonElements getComparisonAccess() {
		return pComparison;
	}
	
	public ParserRule getComparisonRule() {
		return getComparisonAccess().getRule();
	}
	
	//PlusOrMinus Expression:
	//	MulOrDiv (({Plus.left=current} '+' | {Minus.left=current} '-') right=MulOrDiv)*
	public PlusOrMinusElements getPlusOrMinusAccess() {
		return pPlusOrMinus;
	}
	
	public ParserRule getPlusOrMinusRule() {
		return getPlusOrMinusAccess().getRule();
	}
	
	//MulOrDiv Expression:
	//	Primary (({Mul.left=current} '*' | {Div.left=current} '/') right=Primary)*
	public MulOrDivElements getMulOrDivAccess() {
		return pMulOrDiv;
	}
	
	public ParserRule getMulOrDivRule() {
		return getMulOrDivAccess().getRule();
	}
	
	//Primary Expression:
	//	'(' Expression ')'
	//	| {Not} 'not' expression=Primary
	//	| {UMinus} '-' expression=Primary
	//	| {Pre} 'pre' expression=Primary
	//	| {Current} 'current' expression=Primary
	//	| AtomicExpression
	public PrimaryElements getPrimaryAccess() {
		return pPrimary;
	}
	
	public ParserRule getPrimaryRule() {
		return getPrimaryAccess().getRule();
	}
	
	//AtomicExpression Expression:
	//	ConstantExpression | {Variableref} value=IDENT
	public AtomicExpressionElements getAtomicExpressionAccess() {
		return pAtomicExpression;
	}
	
	public ParserRule getAtomicExpressionRule() {
		return getAtomicExpressionAccess().getRule();
	}
	
	//ConstantExpression Expression:
	//	{BooleanConstant} value=BOOL
	//	| {FloatConstant} value=FLOAT
	//	| {IntConstant} value=INT
	public ConstantExpressionElements getConstantExpressionAccess() {
		return pConstantExpression;
	}
	
	public ParserRule getConstantExpressionRule() {
		return getConstantExpressionAccess().getRule();
	}
	
	//terminal BOOL returns ecore::EBoolean:
	//	'true' | 'false';
	public TerminalRule getBOOLRule() {
		return tBOOL;
	}
	
	//terminal IDENT:
	//	'^'? ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;
	public TerminalRule getIDENTRule() {
		return tIDENT;
	}
	
	//terminal INT returns ecore::EInt:
	//	'0'..'9'+;
	public TerminalRule getINTRule() {
		return tINT;
	}
	
	//terminal FLOAT returns ecore::EFloat:
	//	'0'..'9'+ '.' '0'..'9'*
	//	| '.' '0'..'9'+;
	public TerminalRule getFLOATRule() {
		return tFLOAT;
	}
	
	//terminal STRING_CONST:
	//	'"' ('\\' ('b' | 't' | 'n' | 'f' | 'r' | 'u' | '"' | "'" | '\\') | !('\\' | '"'))* '"' |
	//	"'" ('\\' ('b' | 't' | 'n' | 'f' | 'r' | 'u' | '"' | "'" | '\\') | !('\\' | "'"))* "'";
	public TerminalRule getSTRING_CONSTRule() {
		return tSTRING_CONST;
	}
	
	//terminal LUSTRE_COMMENT:
	//	LUSTRE_ML_COMMENT | LUSTRE_SL_COMMENT;
	public TerminalRule getLUSTRE_COMMENTRule() {
		return tLUSTRE_COMMENT;
	}
	
	//terminal LUSTRE_ML_COMMENT:
	//	'(*'->'*)';
	public TerminalRule getLUSTRE_ML_COMMENTRule() {
		return tLUSTRE_ML_COMMENT;
	}
	
	//terminal LUSTRE_SL_COMMENT:
	//	'--' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getLUSTRE_SL_COMMENTRule() {
		return tLUSTRE_SL_COMMENT;
	}
	
	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return tWS;
	}
}
