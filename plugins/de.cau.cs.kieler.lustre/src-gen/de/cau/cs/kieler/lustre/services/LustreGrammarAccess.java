/*
 * generated by Xtext 2.10.0
 */
package de.cau.cs.kieler.lustre.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.CrossReference;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractGrammarElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class LustreGrammarAccess extends AbstractGrammarElementFinder {
	
	public class ProgramElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.Program");
		private final Assignment cPackagesAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cPackagesPackage_DeclarationParserRuleCall_0 = (RuleCall)cPackagesAssignment.eContents().get(0);
		
		/// **
		// * @author cpa
		// * / Program hidden(WS, LUSTRE_COMMENT):
		//	packages+=Package_Declaration+;
		@Override public ParserRule getRule() { return rule; }
		
		//packages+=Package_Declaration+
		public Assignment getPackagesAssignment() { return cPackagesAssignment; }
		
		//Package_Declaration
		public RuleCall getPackagesPackage_DeclarationParserRuleCall_0() { return cPackagesPackage_DeclarationParserRuleCall_0; }
	}
	public class Package_DeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.Package_Declaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cPackageKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDENTTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cUsesKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cUsesAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cUsesIDENTTerminalRuleCall_2_1_0 = (RuleCall)cUsesAssignment_2_1.eContents().get(0);
		private final Group cGroup_2_2 = (Group)cGroup_2.eContents().get(2);
		private final Keyword cCommaKeyword_2_2_0 = (Keyword)cGroup_2_2.eContents().get(0);
		private final Assignment cUsesAssignment_2_2_1 = (Assignment)cGroup_2_2.eContents().get(1);
		private final RuleCall cUsesIDENTTerminalRuleCall_2_2_1_0 = (RuleCall)cUsesAssignment_2_2_1.eContents().get(0);
		private final Keyword cProvidesKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cProvidesAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cProvidesPackage_ProvidedParserRuleCall_4_0 = (RuleCall)cProvidesAssignment_4.eContents().get(0);
		private final Keyword cBodyKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Alternatives cAlternatives_6 = (Alternatives)cGroup.eContents().get(6);
		private final Assignment cNodesAssignment_6_0 = (Assignment)cAlternatives_6.eContents().get(0);
		private final RuleCall cNodesNode_DeclarationParserRuleCall_6_0_0 = (RuleCall)cNodesAssignment_6_0.eContents().get(0);
		private final Assignment cTypesAssignment_6_1 = (Assignment)cAlternatives_6.eContents().get(1);
		private final RuleCall cTypesType_DeclarationParserRuleCall_6_1_0 = (RuleCall)cTypesAssignment_6_1.eContents().get(0);
		private final Assignment cConstantsAssignment_6_2 = (Assignment)cAlternatives_6.eContents().get(2);
		private final RuleCall cConstantsConstant_DeclarationParserRuleCall_6_2_0 = (RuleCall)cConstantsAssignment_6_2.eContents().get(0);
		private final Keyword cEndKeyword_7 = (Keyword)cGroup.eContents().get(7);
		
		/// *
		// * Packages
		// * / Package_Declaration:
		//	'package' name=IDENT ('uses' uses+=IDENT (',' uses+=IDENT)*)?
		//	'provides' provides+=Package_Provided+
		//	'body' (nodes+=Node_Declaration | types+=Type_Declaration | constants+=Constant_Declaration)*
		//	'end';
		@Override public ParserRule getRule() { return rule; }
		
		//'package' name=IDENT ('uses' uses+=IDENT (',' uses+=IDENT)*)? 'provides' provides+=Package_Provided+ 'body'
		//(nodes+=Node_Declaration | types+=Type_Declaration | constants+=Constant_Declaration)* 'end'
		public Group getGroup() { return cGroup; }
		
		//'package'
		public Keyword getPackageKeyword_0() { return cPackageKeyword_0; }
		
		//name=IDENT
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//IDENT
		public RuleCall getNameIDENTTerminalRuleCall_1_0() { return cNameIDENTTerminalRuleCall_1_0; }
		
		//('uses' uses+=IDENT (',' uses+=IDENT)*)?
		public Group getGroup_2() { return cGroup_2; }
		
		//'uses'
		public Keyword getUsesKeyword_2_0() { return cUsesKeyword_2_0; }
		
		//uses+=IDENT
		public Assignment getUsesAssignment_2_1() { return cUsesAssignment_2_1; }
		
		//IDENT
		public RuleCall getUsesIDENTTerminalRuleCall_2_1_0() { return cUsesIDENTTerminalRuleCall_2_1_0; }
		
		//(',' uses+=IDENT)*
		public Group getGroup_2_2() { return cGroup_2_2; }
		
		//','
		public Keyword getCommaKeyword_2_2_0() { return cCommaKeyword_2_2_0; }
		
		//uses+=IDENT
		public Assignment getUsesAssignment_2_2_1() { return cUsesAssignment_2_2_1; }
		
		//IDENT
		public RuleCall getUsesIDENTTerminalRuleCall_2_2_1_0() { return cUsesIDENTTerminalRuleCall_2_2_1_0; }
		
		//'provides'
		public Keyword getProvidesKeyword_3() { return cProvidesKeyword_3; }
		
		//provides+=Package_Provided+
		public Assignment getProvidesAssignment_4() { return cProvidesAssignment_4; }
		
		//Package_Provided
		public RuleCall getProvidesPackage_ProvidedParserRuleCall_4_0() { return cProvidesPackage_ProvidedParserRuleCall_4_0; }
		
		//'body'
		public Keyword getBodyKeyword_5() { return cBodyKeyword_5; }
		
		//(nodes+=Node_Declaration | types+=Type_Declaration | constants+=Constant_Declaration)*
		public Alternatives getAlternatives_6() { return cAlternatives_6; }
		
		//nodes+=Node_Declaration
		public Assignment getNodesAssignment_6_0() { return cNodesAssignment_6_0; }
		
		//Node_Declaration
		public RuleCall getNodesNode_DeclarationParserRuleCall_6_0_0() { return cNodesNode_DeclarationParserRuleCall_6_0_0; }
		
		//types+=Type_Declaration
		public Assignment getTypesAssignment_6_1() { return cTypesAssignment_6_1; }
		
		//Type_Declaration
		public RuleCall getTypesType_DeclarationParserRuleCall_6_1_0() { return cTypesType_DeclarationParserRuleCall_6_1_0; }
		
		//constants+=Constant_Declaration
		public Assignment getConstantsAssignment_6_2() { return cConstantsAssignment_6_2; }
		
		//Constant_Declaration
		public RuleCall getConstantsConstant_DeclarationParserRuleCall_6_2_0() { return cConstantsConstant_DeclarationParserRuleCall_6_2_0; }
		
		//'end'
		public Keyword getEndKeyword_7() { return cEndKeyword_7; }
	}
	public class Package_ProvidedElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.Package_Provided");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cNodeKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cNameNode_DeclarationCrossReference_1_0 = (CrossReference)cNameAssignment_1.eContents().get(0);
		private final RuleCall cNameNode_DeclarationIDENTTerminalRuleCall_1_0_1 = (RuleCall)cNameNode_DeclarationCrossReference_1_0.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Assignment cParametersAssignment_3_0 = (Assignment)cGroup_3.eContents().get(0);
		private final RuleCall cParametersPackage_Provided_IOParserRuleCall_3_0_0 = (RuleCall)cParametersAssignment_3_0.eContents().get(0);
		private final Group cGroup_3_1 = (Group)cGroup_3.eContents().get(1);
		private final Keyword cCommaKeyword_3_1_0 = (Keyword)cGroup_3_1.eContents().get(0);
		private final Assignment cParametersAssignment_3_1_1 = (Assignment)cGroup_3_1.eContents().get(1);
		private final RuleCall cParametersPackage_Provided_IOParserRuleCall_3_1_1_0 = (RuleCall)cParametersAssignment_3_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Keyword cReturnsKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Keyword cLeftParenthesisKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final Assignment cReturnedAssignment_7 = (Assignment)cGroup.eContents().get(7);
		private final RuleCall cReturnedPackage_Provided_IOParserRuleCall_7_0 = (RuleCall)cReturnedAssignment_7.eContents().get(0);
		private final Group cGroup_8 = (Group)cGroup.eContents().get(8);
		private final Keyword cCommaKeyword_8_0 = (Keyword)cGroup_8.eContents().get(0);
		private final Assignment cReturnedAssignment_8_1 = (Assignment)cGroup_8.eContents().get(1);
		private final RuleCall cReturnedPackage_Provided_IOParserRuleCall_8_1_0 = (RuleCall)cReturnedAssignment_8_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_9 = (Keyword)cGroup.eContents().get(9);
		private final Keyword cSemicolonKeyword_10 = (Keyword)cGroup.eContents().get(10);
		
		//Package_Provided:
		//	'node' name=[Node_Declaration|IDENT]
		//	'(' (parameters+=Package_Provided_IO (',' parameters+=Package_Provided_IO)*)? ')'
		//	'returns' '(' returned+=Package_Provided_IO (',' returned+=Package_Provided_IO)* ')'
		//	';';
		@Override public ParserRule getRule() { return rule; }
		
		//'node' name=[Node_Declaration|IDENT] '(' (parameters+=Package_Provided_IO (',' parameters+=Package_Provided_IO)*)? ')'
		//'returns' '(' returned+=Package_Provided_IO (',' returned+=Package_Provided_IO)* ')' ';'
		public Group getGroup() { return cGroup; }
		
		//'node'
		public Keyword getNodeKeyword_0() { return cNodeKeyword_0; }
		
		//name=[Node_Declaration|IDENT]
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//[Node_Declaration|IDENT]
		public CrossReference getNameNode_DeclarationCrossReference_1_0() { return cNameNode_DeclarationCrossReference_1_0; }
		
		//IDENT
		public RuleCall getNameNode_DeclarationIDENTTerminalRuleCall_1_0_1() { return cNameNode_DeclarationIDENTTerminalRuleCall_1_0_1; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }
		
		//(parameters+=Package_Provided_IO (',' parameters+=Package_Provided_IO)*)?
		public Group getGroup_3() { return cGroup_3; }
		
		//parameters+=Package_Provided_IO
		public Assignment getParametersAssignment_3_0() { return cParametersAssignment_3_0; }
		
		//Package_Provided_IO
		public RuleCall getParametersPackage_Provided_IOParserRuleCall_3_0_0() { return cParametersPackage_Provided_IOParserRuleCall_3_0_0; }
		
		//(',' parameters+=Package_Provided_IO)*
		public Group getGroup_3_1() { return cGroup_3_1; }
		
		//','
		public Keyword getCommaKeyword_3_1_0() { return cCommaKeyword_3_1_0; }
		
		//parameters+=Package_Provided_IO
		public Assignment getParametersAssignment_3_1_1() { return cParametersAssignment_3_1_1; }
		
		//Package_Provided_IO
		public RuleCall getParametersPackage_Provided_IOParserRuleCall_3_1_1_0() { return cParametersPackage_Provided_IOParserRuleCall_3_1_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
		
		//'returns'
		public Keyword getReturnsKeyword_5() { return cReturnsKeyword_5; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_6() { return cLeftParenthesisKeyword_6; }
		
		//returned+=Package_Provided_IO
		public Assignment getReturnedAssignment_7() { return cReturnedAssignment_7; }
		
		//Package_Provided_IO
		public RuleCall getReturnedPackage_Provided_IOParserRuleCall_7_0() { return cReturnedPackage_Provided_IOParserRuleCall_7_0; }
		
		//(',' returned+=Package_Provided_IO)*
		public Group getGroup_8() { return cGroup_8; }
		
		//','
		public Keyword getCommaKeyword_8_0() { return cCommaKeyword_8_0; }
		
		//returned+=Package_Provided_IO
		public Assignment getReturnedAssignment_8_1() { return cReturnedAssignment_8_1; }
		
		//Package_Provided_IO
		public RuleCall getReturnedPackage_Provided_IOParserRuleCall_8_1_0() { return cReturnedPackage_Provided_IOParserRuleCall_8_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_9() { return cRightParenthesisKeyword_9; }
		
		//';'
		public Keyword getSemicolonKeyword_10() { return cSemicolonKeyword_10; }
	}
	public class Package_Provided_IOElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.Package_Provided_IO");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cNameVariable_DeclarationCrossReference_0_0 = (CrossReference)cNameAssignment_0.eContents().get(0);
		private final RuleCall cNameVariable_DeclarationIDENTTerminalRuleCall_0_0_1 = (RuleCall)cNameVariable_DeclarationCrossReference_0_0.eContents().get(1);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTypeAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTypeIDENTTerminalRuleCall_2_0 = (RuleCall)cTypeAssignment_2.eContents().get(0);
		
		//Package_Provided_IO:
		//	name=[Variable_Declaration|IDENT] ':' type=IDENT;
		@Override public ParserRule getRule() { return rule; }
		
		//name=[Variable_Declaration|IDENT] ':' type=IDENT
		public Group getGroup() { return cGroup; }
		
		//name=[Variable_Declaration|IDENT]
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//[Variable_Declaration|IDENT]
		public CrossReference getNameVariable_DeclarationCrossReference_0_0() { return cNameVariable_DeclarationCrossReference_0_0; }
		
		//IDENT
		public RuleCall getNameVariable_DeclarationIDENTTerminalRuleCall_0_0_1() { return cNameVariable_DeclarationIDENTTerminalRuleCall_0_0_1; }
		
		//':'
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }
		
		//type=IDENT
		public Assignment getTypeAssignment_2() { return cTypeAssignment_2; }
		
		//IDENT
		public RuleCall getTypeIDENTTerminalRuleCall_2_0() { return cTypeIDENTTerminalRuleCall_2_0; }
	}
	public class Entity_DeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.Entity_Declaration");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cNode_DeclarationParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cType_DeclarationParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cConstant_DeclarationParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//Entity_Declaration:
		//	Node_Declaration
		//	| Type_Declaration
		//	| Constant_Declaration;
		@Override public ParserRule getRule() { return rule; }
		
		//Node_Declaration | Type_Declaration | Constant_Declaration
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Node_Declaration
		public RuleCall getNode_DeclarationParserRuleCall_0() { return cNode_DeclarationParserRuleCall_0; }
		
		//Type_Declaration
		public RuleCall getType_DeclarationParserRuleCall_1() { return cType_DeclarationParserRuleCall_1; }
		
		//Constant_Declaration
		public RuleCall getConstant_DeclarationParserRuleCall_2() { return cConstant_DeclarationParserRuleCall_2; }
	}
	public class Type_DeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.Type_Declaration");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cTypeKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final Assignment cNameAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cNameIDENTTerminalRuleCall_0_1_0 = (RuleCall)cNameAssignment_0_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_0_2 = (Keyword)cGroup_0.eContents().get(2);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cTypeKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cNameAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cNameIDENTTerminalRuleCall_1_1_0 = (RuleCall)cNameAssignment_1_1.eContents().get(0);
		private final Keyword cEqualsSignKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		private final Assignment cTypeAssignment_1_3 = (Assignment)cGroup_1.eContents().get(3);
		private final RuleCall cTypeTypeParserRuleCall_1_3_0 = (RuleCall)cTypeAssignment_1_3.eContents().get(0);
		private final Keyword cSemicolonKeyword_1_4 = (Keyword)cGroup_1.eContents().get(4);
		
		/// *
		// * Identifiers
		// * / //Identifier:
		////    (package=[Package | IDENT] '::')? name=[Variable_Declaration | IDENT] | name=[Node_Declaration | IDENT];
		/// * 
		// * Types
		// * / Type_Declaration:
		//	'type' name=IDENT ';'
		//	| 'type' name=IDENT '=' type=Type ';';
		@Override public ParserRule getRule() { return rule; }
		
		//'type' name=IDENT ';' | 'type' name=IDENT '=' type=Type ';'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'type' name=IDENT ';'
		public Group getGroup_0() { return cGroup_0; }
		
		//'type'
		public Keyword getTypeKeyword_0_0() { return cTypeKeyword_0_0; }
		
		//name=IDENT
		public Assignment getNameAssignment_0_1() { return cNameAssignment_0_1; }
		
		//IDENT
		public RuleCall getNameIDENTTerminalRuleCall_0_1_0() { return cNameIDENTTerminalRuleCall_0_1_0; }
		
		//';'
		public Keyword getSemicolonKeyword_0_2() { return cSemicolonKeyword_0_2; }
		
		//'type' name=IDENT '=' type=Type ';'
		public Group getGroup_1() { return cGroup_1; }
		
		//'type'
		public Keyword getTypeKeyword_1_0() { return cTypeKeyword_1_0; }
		
		//name=IDENT
		public Assignment getNameAssignment_1_1() { return cNameAssignment_1_1; }
		
		//IDENT
		public RuleCall getNameIDENTTerminalRuleCall_1_1_0() { return cNameIDENTTerminalRuleCall_1_1_0; }
		
		//'='
		public Keyword getEqualsSignKeyword_1_2() { return cEqualsSignKeyword_1_2; }
		
		//type=Type
		public Assignment getTypeAssignment_1_3() { return cTypeAssignment_1_3; }
		
		//Type
		public RuleCall getTypeTypeParserRuleCall_1_3_0() { return cTypeTypeParserRuleCall_1_3_0; }
		
		//';'
		public Keyword getSemicolonKeyword_1_4() { return cSemicolonKeyword_1_4; }
	}
	public class TypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.Type");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final CrossReference cNameType_DeclarationCrossReference_0 = (CrossReference)cNameAssignment.eContents().get(0);
		private final RuleCall cNameType_DeclarationIDENTTerminalRuleCall_0_1 = (RuleCall)cNameType_DeclarationCrossReference_0.eContents().get(1);
		
		//Type:
		//	name=[Type_Declaration|IDENT];
		@Override public ParserRule getRule() { return rule; }
		
		//name=[Type_Declaration|IDENT]
		public Assignment getNameAssignment() { return cNameAssignment; }
		
		//[Type_Declaration|IDENT]
		public CrossReference getNameType_DeclarationCrossReference_0() { return cNameType_DeclarationCrossReference_0; }
		
		//IDENT
		public RuleCall getNameType_DeclarationIDENTTerminalRuleCall_0_1() { return cNameType_DeclarationIDENTTerminalRuleCall_0_1; }
	}
	public class Array_TypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.Array_Type");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTypeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cTypeType_DeclarationCrossReference_0_0 = (CrossReference)cTypeAssignment_0.eContents().get(0);
		private final RuleCall cTypeType_DeclarationIDENTTerminalRuleCall_0_0_1 = (RuleCall)cTypeType_DeclarationCrossReference_0_0.eContents().get(1);
		private final Keyword cCircumflexAccentKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cLengthAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cLengthINTTerminalRuleCall_2_0 = (RuleCall)cLengthAssignment_2.eContents().get(0);
		
		//Array_Type:
		//	type=[Type_Declaration|IDENT] '^' length=INT
		//	// XXX Original Lustre allows Type^Expression  
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//type=[Type_Declaration|IDENT] '^' length=INT
		public Group getGroup() { return cGroup; }
		
		//type=[Type_Declaration|IDENT]
		public Assignment getTypeAssignment_0() { return cTypeAssignment_0; }
		
		//[Type_Declaration|IDENT]
		public CrossReference getTypeType_DeclarationCrossReference_0_0() { return cTypeType_DeclarationCrossReference_0_0; }
		
		//IDENT
		public RuleCall getTypeType_DeclarationIDENTTerminalRuleCall_0_0_1() { return cTypeType_DeclarationIDENTTerminalRuleCall_0_0_1; }
		
		//'^'
		public Keyword getCircumflexAccentKeyword_1() { return cCircumflexAccentKeyword_1; }
		
		//length=INT
		public Assignment getLengthAssignment_2() { return cLengthAssignment_2; }
		
		//INT
		public RuleCall getLengthINTTerminalRuleCall_2_0() { return cLengthINTTerminalRuleCall_2_0; }
	}
	public class Record_TypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.Record_Type");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cStructKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cFieldsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cFieldsFieldParserRuleCall_2_0 = (RuleCall)cFieldsAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cCommaKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cFieldsAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cFieldsFieldParserRuleCall_3_1_0 = (RuleCall)cFieldsAssignment_3_1.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//Record_Type:
		//	'struct' '{' fields+=Field (',' fields+=Field)* '}';
		@Override public ParserRule getRule() { return rule; }
		
		//'struct' '{' fields+=Field (',' fields+=Field)* '}'
		public Group getGroup() { return cGroup; }
		
		//'struct'
		public Keyword getStructKeyword_0() { return cStructKeyword_0; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }
		
		//fields+=Field
		public Assignment getFieldsAssignment_2() { return cFieldsAssignment_2; }
		
		//Field
		public RuleCall getFieldsFieldParserRuleCall_2_0() { return cFieldsFieldParserRuleCall_2_0; }
		
		//(',' fields+=Field)*
		public Group getGroup_3() { return cGroup_3; }
		
		//','
		public Keyword getCommaKeyword_3_0() { return cCommaKeyword_3_0; }
		
		//fields+=Field
		public Assignment getFieldsAssignment_3_1() { return cFieldsAssignment_3_1; }
		
		//Field
		public RuleCall getFieldsFieldParserRuleCall_3_1_0() { return cFieldsFieldParserRuleCall_3_1_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_4() { return cRightCurlyBracketKeyword_4; }
	}
	public class FieldElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.Field");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIDENTTerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTypeAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final CrossReference cTypeTypeCrossReference_2_0 = (CrossReference)cTypeAssignment_2.eContents().get(0);
		private final RuleCall cTypeTypeIDENTTerminalRuleCall_2_0_1 = (RuleCall)cTypeTypeCrossReference_2_0.eContents().get(1);
		
		//Field:
		//	name=IDENT ':' type=[Type|IDENT];
		@Override public ParserRule getRule() { return rule; }
		
		//name=IDENT ':' type=[Type|IDENT]
		public Group getGroup() { return cGroup; }
		
		//name=IDENT
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//IDENT
		public RuleCall getNameIDENTTerminalRuleCall_0_0() { return cNameIDENTTerminalRuleCall_0_0; }
		
		//':'
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }
		
		//type=[Type|IDENT]
		public Assignment getTypeAssignment_2() { return cTypeAssignment_2; }
		
		//[Type|IDENT]
		public CrossReference getTypeTypeCrossReference_2_0() { return cTypeTypeCrossReference_2_0; }
		
		//IDENT
		public RuleCall getTypeTypeIDENTTerminalRuleCall_2_0_1() { return cTypeTypeIDENTTerminalRuleCall_2_0_1; }
	}
	public class Constant_DeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.Constant_Declaration");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cConstKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final Assignment cNameAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cNameIDENTTerminalRuleCall_0_1_0 = (RuleCall)cNameAssignment_0_1.eContents().get(0);
		private final Keyword cColonKeyword_0_2 = (Keyword)cGroup_0.eContents().get(2);
		private final Assignment cTypeAssignment_0_3 = (Assignment)cGroup_0.eContents().get(3);
		private final RuleCall cTypeTypeParserRuleCall_0_3_0 = (RuleCall)cTypeAssignment_0_3.eContents().get(0);
		private final Keyword cSemicolonKeyword_0_4 = (Keyword)cGroup_0.eContents().get(4);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cConstKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cNameAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cNameIDENTTerminalRuleCall_1_1_0 = (RuleCall)cNameAssignment_1_1.eContents().get(0);
		private final Keyword cEqualsSignKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		private final Assignment cExprAssignment_1_3 = (Assignment)cGroup_1.eContents().get(3);
		private final RuleCall cExprConstantExpressionParserRuleCall_1_3_0 = (RuleCall)cExprAssignment_1_3.eContents().get(0);
		private final Keyword cSemicolonKeyword_1_4 = (Keyword)cGroup_1.eContents().get(4);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Keyword cConstKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cNameAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cNameIDENTTerminalRuleCall_2_1_0 = (RuleCall)cNameAssignment_2_1.eContents().get(0);
		private final Keyword cColonKeyword_2_2 = (Keyword)cGroup_2.eContents().get(2);
		private final Assignment cTypeAssignment_2_3 = (Assignment)cGroup_2.eContents().get(3);
		private final RuleCall cTypeTypeParserRuleCall_2_3_0 = (RuleCall)cTypeAssignment_2_3.eContents().get(0);
		private final Keyword cEqualsSignKeyword_2_4 = (Keyword)cGroup_2.eContents().get(4);
		private final Assignment cExprAssignment_2_5 = (Assignment)cGroup_2.eContents().get(5);
		private final RuleCall cExprConstantExpressionParserRuleCall_2_5_0 = (RuleCall)cExprAssignment_2_5.eContents().get(0);
		private final Keyword cSemicolonKeyword_2_6 = (Keyword)cGroup_2.eContents().get(6);
		
		////Enum_Type:
		////    'enum' '{' nameList=Ident_List '}'
		////;
		/// *
		// * Constants and variables
		// * / Constant_Declaration:
		//	'const' name=IDENT ':' type=Type ';'
		//	| 'const' name=IDENT '=' expr=ConstantExpression ';'
		//	| 'const' name=IDENT ':' type=Type '=' expr=ConstantExpression ';'
		//	// XXX Original Lustre allows Expressions
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'const' name=IDENT ':' type=Type ';' | 'const' name=IDENT '=' expr=ConstantExpression ';' | 'const' name=IDENT ':'
		//type=Type '=' expr=ConstantExpression ';'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'const' name=IDENT ':' type=Type ';'
		public Group getGroup_0() { return cGroup_0; }
		
		//'const'
		public Keyword getConstKeyword_0_0() { return cConstKeyword_0_0; }
		
		//name=IDENT
		public Assignment getNameAssignment_0_1() { return cNameAssignment_0_1; }
		
		//IDENT
		public RuleCall getNameIDENTTerminalRuleCall_0_1_0() { return cNameIDENTTerminalRuleCall_0_1_0; }
		
		//':'
		public Keyword getColonKeyword_0_2() { return cColonKeyword_0_2; }
		
		//type=Type
		public Assignment getTypeAssignment_0_3() { return cTypeAssignment_0_3; }
		
		//Type
		public RuleCall getTypeTypeParserRuleCall_0_3_0() { return cTypeTypeParserRuleCall_0_3_0; }
		
		//';'
		public Keyword getSemicolonKeyword_0_4() { return cSemicolonKeyword_0_4; }
		
		//'const' name=IDENT '=' expr=ConstantExpression ';'
		public Group getGroup_1() { return cGroup_1; }
		
		//'const'
		public Keyword getConstKeyword_1_0() { return cConstKeyword_1_0; }
		
		//name=IDENT
		public Assignment getNameAssignment_1_1() { return cNameAssignment_1_1; }
		
		//IDENT
		public RuleCall getNameIDENTTerminalRuleCall_1_1_0() { return cNameIDENTTerminalRuleCall_1_1_0; }
		
		//'='
		public Keyword getEqualsSignKeyword_1_2() { return cEqualsSignKeyword_1_2; }
		
		//expr=ConstantExpression
		public Assignment getExprAssignment_1_3() { return cExprAssignment_1_3; }
		
		//ConstantExpression
		public RuleCall getExprConstantExpressionParserRuleCall_1_3_0() { return cExprConstantExpressionParserRuleCall_1_3_0; }
		
		//';'
		public Keyword getSemicolonKeyword_1_4() { return cSemicolonKeyword_1_4; }
		
		//'const' name=IDENT ':' type=Type '=' expr=ConstantExpression ';'
		public Group getGroup_2() { return cGroup_2; }
		
		//'const'
		public Keyword getConstKeyword_2_0() { return cConstKeyword_2_0; }
		
		//name=IDENT
		public Assignment getNameAssignment_2_1() { return cNameAssignment_2_1; }
		
		//IDENT
		public RuleCall getNameIDENTTerminalRuleCall_2_1_0() { return cNameIDENTTerminalRuleCall_2_1_0; }
		
		//':'
		public Keyword getColonKeyword_2_2() { return cColonKeyword_2_2; }
		
		//type=Type
		public Assignment getTypeAssignment_2_3() { return cTypeAssignment_2_3; }
		
		//Type
		public RuleCall getTypeTypeParserRuleCall_2_3_0() { return cTypeTypeParserRuleCall_2_3_0; }
		
		//'='
		public Keyword getEqualsSignKeyword_2_4() { return cEqualsSignKeyword_2_4; }
		
		//expr=ConstantExpression
		public Assignment getExprAssignment_2_5() { return cExprAssignment_2_5; }
		
		//ConstantExpression
		public RuleCall getExprConstantExpressionParserRuleCall_2_5_0() { return cExprConstantExpressionParserRuleCall_2_5_0; }
		
		//';'
		public Keyword getSemicolonKeyword_2_6() { return cSemicolonKeyword_2_6; }
	}
	public class Variable_DeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.Variable_Declaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIDENTTerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTypeAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTypeTypeParserRuleCall_2_0 = (RuleCall)cTypeAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cWhenKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cClockAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cClockIDENTTerminalRuleCall_3_1_0 = (RuleCall)cClockAssignment_3_1.eContents().get(0);
		
		//Variable_Declaration:
		//	name=IDENT ':' type=Type ('when' clock=IDENT)?;
		@Override public ParserRule getRule() { return rule; }
		
		//name=IDENT ':' type=Type ('when' clock=IDENT)?
		public Group getGroup() { return cGroup; }
		
		//name=IDENT
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//IDENT
		public RuleCall getNameIDENTTerminalRuleCall_0_0() { return cNameIDENTTerminalRuleCall_0_0; }
		
		//':'
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }
		
		//type=Type
		public Assignment getTypeAssignment_2() { return cTypeAssignment_2; }
		
		//Type
		public RuleCall getTypeTypeParserRuleCall_2_0() { return cTypeTypeParserRuleCall_2_0; }
		
		//('when' clock=IDENT)?
		public Group getGroup_3() { return cGroup_3; }
		
		//'when'
		public Keyword getWhenKeyword_3_0() { return cWhenKeyword_3_0; }
		
		//clock=IDENT
		public Assignment getClockAssignment_3_1() { return cClockAssignment_3_1; }
		
		//IDENT
		public RuleCall getClockIDENTTerminalRuleCall_3_1_0() { return cClockIDENTTerminalRuleCall_3_1_0; }
	}
	public class Local_Variable_DeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.Local_Variable_Declaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cVarKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cVariable_DeclarationParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Keyword cSemicolonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//Local_Variable_Declaration Variable_Declaration:
		//	'var' Variable_Declaration ';'
		@Override public ParserRule getRule() { return rule; }
		
		//'var' Variable_Declaration ';'
		public Group getGroup() { return cGroup; }
		
		//'var'
		public Keyword getVarKeyword_0() { return cVarKeyword_0; }
		
		//Variable_Declaration
		public RuleCall getVariable_DeclarationParserRuleCall_1() { return cVariable_DeclarationParserRuleCall_1; }
		
		//';'
		public Keyword getSemicolonKeyword_2() { return cSemicolonKeyword_2; }
	}
	public class Local_Constant_DeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.Local_Constant_Declaration");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cConstant_DeclarationAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Keyword cConstKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Assignment cNameAssignment_0_2 = (Assignment)cGroup_0.eContents().get(2);
		private final RuleCall cNameIDENTTerminalRuleCall_0_2_0 = (RuleCall)cNameAssignment_0_2.eContents().get(0);
		private final Keyword cEqualsSignKeyword_0_3 = (Keyword)cGroup_0.eContents().get(3);
		private final Assignment cExprAssignment_0_4 = (Assignment)cGroup_0.eContents().get(4);
		private final RuleCall cExprConstantExpressionParserRuleCall_0_4_0 = (RuleCall)cExprAssignment_0_4.eContents().get(0);
		private final Keyword cSemicolonKeyword_0_5 = (Keyword)cGroup_0.eContents().get(5);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cConstant_DeclarationAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cConstKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cNameAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cNameIDENTTerminalRuleCall_1_2_0 = (RuleCall)cNameAssignment_1_2.eContents().get(0);
		private final Keyword cColonKeyword_1_3 = (Keyword)cGroup_1.eContents().get(3);
		private final Assignment cTypeAssignment_1_4 = (Assignment)cGroup_1.eContents().get(4);
		private final RuleCall cTypeTypeParserRuleCall_1_4_0 = (RuleCall)cTypeAssignment_1_4.eContents().get(0);
		private final Keyword cEqualsSignKeyword_1_5 = (Keyword)cGroup_1.eContents().get(5);
		private final Assignment cExprAssignment_1_6 = (Assignment)cGroup_1.eContents().get(6);
		private final RuleCall cExprConstantExpressionParserRuleCall_1_6_0 = (RuleCall)cExprAssignment_1_6.eContents().get(0);
		private final Keyword cSemicolonKeyword_1_7 = (Keyword)cGroup_1.eContents().get(7);
		
		//Local_Constant_Declaration Constant_Declaration:
		//	{Constant_Declaration} 'const' name=IDENT '=' expr=ConstantExpression ';'
		//	| {Constant_Declaration} 'const' name=IDENT ':' type=Type '=' expr=ConstantExpression ';'
		@Override public ParserRule getRule() { return rule; }
		
		//{Constant_Declaration} 'const' name=IDENT '=' expr=ConstantExpression ';' | {Constant_Declaration} 'const' name=IDENT
		//':' type=Type '=' expr=ConstantExpression ';'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//{Constant_Declaration} 'const' name=IDENT '=' expr=ConstantExpression ';'
		public Group getGroup_0() { return cGroup_0; }
		
		//{Constant_Declaration}
		public Action getConstant_DeclarationAction_0_0() { return cConstant_DeclarationAction_0_0; }
		
		//'const'
		public Keyword getConstKeyword_0_1() { return cConstKeyword_0_1; }
		
		//name=IDENT
		public Assignment getNameAssignment_0_2() { return cNameAssignment_0_2; }
		
		//IDENT
		public RuleCall getNameIDENTTerminalRuleCall_0_2_0() { return cNameIDENTTerminalRuleCall_0_2_0; }
		
		//'='
		public Keyword getEqualsSignKeyword_0_3() { return cEqualsSignKeyword_0_3; }
		
		//expr=ConstantExpression
		public Assignment getExprAssignment_0_4() { return cExprAssignment_0_4; }
		
		//ConstantExpression
		public RuleCall getExprConstantExpressionParserRuleCall_0_4_0() { return cExprConstantExpressionParserRuleCall_0_4_0; }
		
		//';'
		public Keyword getSemicolonKeyword_0_5() { return cSemicolonKeyword_0_5; }
		
		//{Constant_Declaration} 'const' name=IDENT ':' type=Type '=' expr=ConstantExpression ';'
		public Group getGroup_1() { return cGroup_1; }
		
		//{Constant_Declaration}
		public Action getConstant_DeclarationAction_1_0() { return cConstant_DeclarationAction_1_0; }
		
		//'const'
		public Keyword getConstKeyword_1_1() { return cConstKeyword_1_1; }
		
		//name=IDENT
		public Assignment getNameAssignment_1_2() { return cNameAssignment_1_2; }
		
		//IDENT
		public RuleCall getNameIDENTTerminalRuleCall_1_2_0() { return cNameIDENTTerminalRuleCall_1_2_0; }
		
		//':'
		public Keyword getColonKeyword_1_3() { return cColonKeyword_1_3; }
		
		//type=Type
		public Assignment getTypeAssignment_1_4() { return cTypeAssignment_1_4; }
		
		//Type
		public RuleCall getTypeTypeParserRuleCall_1_4_0() { return cTypeTypeParserRuleCall_1_4_0; }
		
		//'='
		public Keyword getEqualsSignKeyword_1_5() { return cEqualsSignKeyword_1_5; }
		
		//expr=ConstantExpression
		public Assignment getExprAssignment_1_6() { return cExprAssignment_1_6; }
		
		//ConstantExpression
		public RuleCall getExprConstantExpressionParserRuleCall_1_6_0() { return cExprConstantExpressionParserRuleCall_1_6_0; }
		
		//';'
		public Keyword getSemicolonKeyword_1_7() { return cSemicolonKeyword_1_7; }
	}
	public class Node_DeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.Node_Declaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cNodeKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDENTTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Assignment cParametersAssignment_3_0 = (Assignment)cGroup_3.eContents().get(0);
		private final RuleCall cParametersVariable_DeclarationParserRuleCall_3_0_0 = (RuleCall)cParametersAssignment_3_0.eContents().get(0);
		private final Group cGroup_3_1 = (Group)cGroup_3.eContents().get(1);
		private final Keyword cCommaKeyword_3_1_0 = (Keyword)cGroup_3_1.eContents().get(0);
		private final Assignment cParametersAssignment_3_1_1 = (Assignment)cGroup_3_1.eContents().get(1);
		private final RuleCall cParametersVariable_DeclarationParserRuleCall_3_1_1_0 = (RuleCall)cParametersAssignment_3_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Keyword cReturnsKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Keyword cLeftParenthesisKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final Assignment cReturnedAssignment_7 = (Assignment)cGroup.eContents().get(7);
		private final RuleCall cReturnedVariable_DeclarationParserRuleCall_7_0 = (RuleCall)cReturnedAssignment_7.eContents().get(0);
		private final Group cGroup_8 = (Group)cGroup.eContents().get(8);
		private final Keyword cCommaKeyword_8_0 = (Keyword)cGroup_8.eContents().get(0);
		private final Assignment cReturnedAssignment_8_1 = (Assignment)cGroup_8.eContents().get(1);
		private final RuleCall cReturnedVariable_DeclarationParserRuleCall_8_1_0 = (RuleCall)cReturnedAssignment_8_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_9 = (Keyword)cGroup.eContents().get(9);
		private final Keyword cSemicolonKeyword_10 = (Keyword)cGroup.eContents().get(10);
		private final Alternatives cAlternatives_11 = (Alternatives)cGroup.eContents().get(11);
		private final Assignment cConstantsAssignment_11_0 = (Assignment)cAlternatives_11.eContents().get(0);
		private final RuleCall cConstantsLocal_Constant_DeclarationParserRuleCall_11_0_0 = (RuleCall)cConstantsAssignment_11_0.eContents().get(0);
		private final Assignment cVariablesAssignment_11_1 = (Assignment)cAlternatives_11.eContents().get(1);
		private final RuleCall cVariablesLocal_Variable_DeclarationParserRuleCall_11_1_0 = (RuleCall)cVariablesAssignment_11_1.eContents().get(0);
		private final Keyword cLetKeyword_12 = (Keyword)cGroup.eContents().get(12);
		private final Alternatives cAlternatives_13 = (Alternatives)cGroup.eContents().get(13);
		private final Assignment cEquationsAssignment_13_0 = (Assignment)cAlternatives_13.eContents().get(0);
		private final RuleCall cEquationsEquationParserRuleCall_13_0_0 = (RuleCall)cEquationsAssignment_13_0.eContents().get(0);
		private final Assignment cAssertionsAssignment_13_1 = (Assignment)cAlternatives_13.eContents().get(1);
		private final RuleCall cAssertionsAssertionParserRuleCall_13_1_0 = (RuleCall)cAssertionsAssignment_13_1.eContents().get(0);
		private final Keyword cTelKeyword_14 = (Keyword)cGroup.eContents().get(14);
		private final Keyword cSemicolonKeyword_15 = (Keyword)cGroup.eContents().get(15);
		
		/// *
		// * Nodes
		// * / Node_Declaration:
		//	'node'
		//	name=IDENT
		//	'(' (parameters+=Variable_Declaration (',' parameters+=Variable_Declaration)*)? ')'
		//	'returns' '(' returned+=Variable_Declaration (',' returned+=Variable_Declaration)* ')'
		//	';' (constants+=Local_Constant_Declaration | variables+=Local_Variable_Declaration)*
		//	'let' (equations+=Equation | assertions+=Assertion)*
		//	'tel' ';'?;
		@Override public ParserRule getRule() { return rule; }
		
		//'node' name=IDENT '(' (parameters+=Variable_Declaration (',' parameters+=Variable_Declaration)*)? ')' 'returns' '('
		//returned+=Variable_Declaration (',' returned+=Variable_Declaration)* ')' ';' (constants+=Local_Constant_Declaration |
		//variables+=Local_Variable_Declaration)* 'let' (equations+=Equation | assertions+=Assertion)* 'tel' ';'?
		public Group getGroup() { return cGroup; }
		
		//'node'
		public Keyword getNodeKeyword_0() { return cNodeKeyword_0; }
		
		//name=IDENT
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//IDENT
		public RuleCall getNameIDENTTerminalRuleCall_1_0() { return cNameIDENTTerminalRuleCall_1_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }
		
		//(parameters+=Variable_Declaration (',' parameters+=Variable_Declaration)*)?
		public Group getGroup_3() { return cGroup_3; }
		
		//parameters+=Variable_Declaration
		public Assignment getParametersAssignment_3_0() { return cParametersAssignment_3_0; }
		
		//Variable_Declaration
		public RuleCall getParametersVariable_DeclarationParserRuleCall_3_0_0() { return cParametersVariable_DeclarationParserRuleCall_3_0_0; }
		
		//(',' parameters+=Variable_Declaration)*
		public Group getGroup_3_1() { return cGroup_3_1; }
		
		//','
		public Keyword getCommaKeyword_3_1_0() { return cCommaKeyword_3_1_0; }
		
		//parameters+=Variable_Declaration
		public Assignment getParametersAssignment_3_1_1() { return cParametersAssignment_3_1_1; }
		
		//Variable_Declaration
		public RuleCall getParametersVariable_DeclarationParserRuleCall_3_1_1_0() { return cParametersVariable_DeclarationParserRuleCall_3_1_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
		
		//'returns'
		public Keyword getReturnsKeyword_5() { return cReturnsKeyword_5; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_6() { return cLeftParenthesisKeyword_6; }
		
		//returned+=Variable_Declaration
		public Assignment getReturnedAssignment_7() { return cReturnedAssignment_7; }
		
		//Variable_Declaration
		public RuleCall getReturnedVariable_DeclarationParserRuleCall_7_0() { return cReturnedVariable_DeclarationParserRuleCall_7_0; }
		
		//(',' returned+=Variable_Declaration)*
		public Group getGroup_8() { return cGroup_8; }
		
		//','
		public Keyword getCommaKeyword_8_0() { return cCommaKeyword_8_0; }
		
		//returned+=Variable_Declaration
		public Assignment getReturnedAssignment_8_1() { return cReturnedAssignment_8_1; }
		
		//Variable_Declaration
		public RuleCall getReturnedVariable_DeclarationParserRuleCall_8_1_0() { return cReturnedVariable_DeclarationParserRuleCall_8_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_9() { return cRightParenthesisKeyword_9; }
		
		//';'
		public Keyword getSemicolonKeyword_10() { return cSemicolonKeyword_10; }
		
		//(constants+=Local_Constant_Declaration | variables+=Local_Variable_Declaration)*
		public Alternatives getAlternatives_11() { return cAlternatives_11; }
		
		//constants+=Local_Constant_Declaration
		public Assignment getConstantsAssignment_11_0() { return cConstantsAssignment_11_0; }
		
		//Local_Constant_Declaration
		public RuleCall getConstantsLocal_Constant_DeclarationParserRuleCall_11_0_0() { return cConstantsLocal_Constant_DeclarationParserRuleCall_11_0_0; }
		
		//variables+=Local_Variable_Declaration
		public Assignment getVariablesAssignment_11_1() { return cVariablesAssignment_11_1; }
		
		//Local_Variable_Declaration
		public RuleCall getVariablesLocal_Variable_DeclarationParserRuleCall_11_1_0() { return cVariablesLocal_Variable_DeclarationParserRuleCall_11_1_0; }
		
		//'let'
		public Keyword getLetKeyword_12() { return cLetKeyword_12; }
		
		//(equations+=Equation | assertions+=Assertion)*
		public Alternatives getAlternatives_13() { return cAlternatives_13; }
		
		//equations+=Equation
		public Assignment getEquationsAssignment_13_0() { return cEquationsAssignment_13_0; }
		
		//Equation
		public RuleCall getEquationsEquationParserRuleCall_13_0_0() { return cEquationsEquationParserRuleCall_13_0_0; }
		
		//assertions+=Assertion
		public Assignment getAssertionsAssignment_13_1() { return cAssertionsAssignment_13_1; }
		
		//Assertion
		public RuleCall getAssertionsAssertionParserRuleCall_13_1_0() { return cAssertionsAssertionParserRuleCall_13_1_0; }
		
		//'tel'
		public Keyword getTelKeyword_14() { return cTelKeyword_14; }
		
		//';'?
		public Keyword getSemicolonKeyword_15() { return cSemicolonKeyword_15; }
	}
	public class EquationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.Equation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cLeftAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cLeftVariable_DeclarationCrossReference_0_0 = (CrossReference)cLeftAssignment_0.eContents().get(0);
		private final RuleCall cLeftVariable_DeclarationIDENTTerminalRuleCall_0_0_1 = (RuleCall)cLeftVariable_DeclarationCrossReference_0_0.eContents().get(1);
		private final Keyword cEqualsSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cRightAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cRightRight_PartParserRuleCall_2_0 = (RuleCall)cRightAssignment_2.eContents().get(0);
		private final Keyword cSemicolonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//Equation:
		//	left=[Variable_Declaration|IDENT] '=' right=Right_Part ';';
		@Override public ParserRule getRule() { return rule; }
		
		//left=[Variable_Declaration|IDENT] '=' right=Right_Part ';'
		public Group getGroup() { return cGroup; }
		
		//left=[Variable_Declaration|IDENT]
		public Assignment getLeftAssignment_0() { return cLeftAssignment_0; }
		
		//[Variable_Declaration|IDENT]
		public CrossReference getLeftVariable_DeclarationCrossReference_0_0() { return cLeftVariable_DeclarationCrossReference_0_0; }
		
		//IDENT
		public RuleCall getLeftVariable_DeclarationIDENTTerminalRuleCall_0_0_1() { return cLeftVariable_DeclarationIDENTTerminalRuleCall_0_0_1; }
		
		//'='
		public Keyword getEqualsSignKeyword_1() { return cEqualsSignKeyword_1; }
		
		//right=Right_Part
		public Assignment getRightAssignment_2() { return cRightAssignment_2; }
		
		//Right_Part
		public RuleCall getRightRight_PartParserRuleCall_2_0() { return cRightRight_PartParserRuleCall_2_0; }
		
		//';'
		public Keyword getSemicolonKeyword_3() { return cSemicolonKeyword_3; }
	}
	public class AssertionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.Assertion");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cAssertKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cExpressionParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Keyword cSemicolonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//Assertion:
		//	'assert' Expression ';';
		@Override public ParserRule getRule() { return rule; }
		
		//'assert' Expression ';'
		public Group getGroup() { return cGroup; }
		
		//'assert'
		public Keyword getAssertKeyword_0() { return cAssertKeyword_0; }
		
		//Expression
		public RuleCall getExpressionParserRuleCall_1() { return cExpressionParserRuleCall_1; }
		
		//';'
		public Keyword getSemicolonKeyword_2() { return cSemicolonKeyword_2; }
	}
	public class Left_PartElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.Left_Part");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final RuleCall cLeft_ListParserRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_0_2 = (Keyword)cGroup_0.eContents().get(2);
		private final RuleCall cLeft_ListParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//Left_Part:
		//	'(' Left_List ')'
		//	| Left_List;
		@Override public ParserRule getRule() { return rule; }
		
		//'(' Left_List ')' | Left_List
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'(' Left_List ')'
		public Group getGroup_0() { return cGroup_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_0_0() { return cLeftParenthesisKeyword_0_0; }
		
		//Left_List
		public RuleCall getLeft_ListParserRuleCall_0_1() { return cLeft_ListParserRuleCall_0_1; }
		
		//')'
		public Keyword getRightParenthesisKeyword_0_2() { return cRightParenthesisKeyword_0_2; }
		
		//Left_List
		public RuleCall getLeft_ListParserRuleCall_1() { return cLeft_ListParserRuleCall_1; }
	}
	public class Left_ListElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.Left_List");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cIdAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cIdLeftParserRuleCall_0_0 = (RuleCall)cIdAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCommaKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cIdAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cIdLeftParserRuleCall_1_1_0 = (RuleCall)cIdAssignment_1_1.eContents().get(0);
		
		//Left_List:
		//	id+=Left (',' id+=Left)*;
		@Override public ParserRule getRule() { return rule; }
		
		//id+=Left (',' id+=Left)*
		public Group getGroup() { return cGroup; }
		
		//id+=Left
		public Assignment getIdAssignment_0() { return cIdAssignment_0; }
		
		//Left
		public RuleCall getIdLeftParserRuleCall_0_0() { return cIdLeftParserRuleCall_0_0; }
		
		//(',' id+=Left)*
		public Group getGroup_1() { return cGroup_1; }
		
		//','
		public Keyword getCommaKeyword_1_0() { return cCommaKeyword_1_0; }
		
		//id+=Left
		public Assignment getIdAssignment_1_1() { return cIdAssignment_1_1; }
		
		//Left
		public RuleCall getIdLeftParserRuleCall_1_1_0() { return cIdLeftParserRuleCall_1_1_0; }
	}
	public class LeftElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.Left");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIDENTTerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Assignment cSelectorAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cSelectorSelectorParserRuleCall_1_0 = (RuleCall)cSelectorAssignment_1.eContents().get(0);
		
		//Left:
		//	name=IDENT selector=Selector?;
		@Override public ParserRule getRule() { return rule; }
		
		//name=IDENT selector=Selector?
		public Group getGroup() { return cGroup; }
		
		//name=IDENT
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//IDENT
		public RuleCall getNameIDENTTerminalRuleCall_0_0() { return cNameIDENTTerminalRuleCall_0_0; }
		
		//selector=Selector?
		public Assignment getSelectorAssignment_1() { return cSelectorAssignment_1; }
		
		//Selector
		public RuleCall getSelectorSelectorParserRuleCall_1_0() { return cSelectorSelectorParserRuleCall_1_0; }
	}
	public class SelectorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.Selector");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cFullStopKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final Assignment cNameAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cNameIDENTTerminalRuleCall_0_1_0 = (RuleCall)cNameAssignment_0_1.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cBeginAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cBeginExpressionParserRuleCall_1_1_0 = (RuleCall)cBeginAssignment_1_1.eContents().get(0);
		private final Assignment cEndAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cEndSelTrancheEndParserRuleCall_1_2_0 = (RuleCall)cEndAssignment_1_2.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_1_3 = (Keyword)cGroup_1.eContents().get(3);
		
		//Selector:
		//	'.' name=IDENT
		//	| '[' begin=Expression end=SelTrancheEnd? ']';
		@Override public ParserRule getRule() { return rule; }
		
		//'.' name=IDENT | '[' begin=Expression end=SelTrancheEnd? ']'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'.' name=IDENT
		public Group getGroup_0() { return cGroup_0; }
		
		//'.'
		public Keyword getFullStopKeyword_0_0() { return cFullStopKeyword_0_0; }
		
		//name=IDENT
		public Assignment getNameAssignment_0_1() { return cNameAssignment_0_1; }
		
		//IDENT
		public RuleCall getNameIDENTTerminalRuleCall_0_1_0() { return cNameIDENTTerminalRuleCall_0_1_0; }
		
		//'[' begin=Expression end=SelTrancheEnd? ']'
		public Group getGroup_1() { return cGroup_1; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_1_0() { return cLeftSquareBracketKeyword_1_0; }
		
		//begin=Expression
		public Assignment getBeginAssignment_1_1() { return cBeginAssignment_1_1; }
		
		//Expression
		public RuleCall getBeginExpressionParserRuleCall_1_1_0() { return cBeginExpressionParserRuleCall_1_1_0; }
		
		//end=SelTrancheEnd?
		public Assignment getEndAssignment_1_2() { return cEndAssignment_1_2; }
		
		//SelTrancheEnd
		public RuleCall getEndSelTrancheEndParserRuleCall_1_2_0() { return cEndSelTrancheEndParserRuleCall_1_2_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_1_3() { return cRightSquareBracketKeyword_1_3; }
	}
	public class SelTrancheEndElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.SelTrancheEnd");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cFullStopFullStopKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cExpressionParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		//SelTrancheEnd Expression:
		//	'..' Expression
		@Override public ParserRule getRule() { return rule; }
		
		//'..' Expression
		public Group getGroup() { return cGroup; }
		
		//'..'
		public Keyword getFullStopFullStopKeyword_0() { return cFullStopFullStopKeyword_0; }
		
		//Expression
		public RuleCall getExpressionParserRuleCall_1() { return cExpressionParserRuleCall_1; }
	}
	public class Right_PartElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.Right_Part");
		private final RuleCall cExpressionParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//Right_Part Expression:
		//	Expression
		@Override public ParserRule getRule() { return rule; }
		
		//Expression
		public RuleCall getExpressionParserRuleCall() { return cExpressionParserRuleCall; }
	}
	public class ExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.Expression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cIfThenElseAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Keyword cIfKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Assignment cIfexprAssignment_0_2 = (Assignment)cGroup_0.eContents().get(2);
		private final RuleCall cIfexprExpressionParserRuleCall_0_2_0 = (RuleCall)cIfexprAssignment_0_2.eContents().get(0);
		private final Keyword cThenKeyword_0_3 = (Keyword)cGroup_0.eContents().get(3);
		private final Assignment cThenexprAssignment_0_4 = (Assignment)cGroup_0.eContents().get(4);
		private final RuleCall cThenexprExpressionParserRuleCall_0_4_0 = (RuleCall)cThenexprAssignment_0_4.eContents().get(0);
		private final Keyword cElseKeyword_0_5 = (Keyword)cGroup_0.eContents().get(5);
		private final Assignment cElseexprAssignment_0_6 = (Assignment)cGroup_0.eContents().get(6);
		private final RuleCall cElseexprExpressionParserRuleCall_0_6_0 = (RuleCall)cElseexprAssignment_0_6.eContents().get(0);
		private final RuleCall cFbyParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		/// *
		// * Expressions
		// * / Expression:
		//	{IfThenElse} 'if' ifexpr=Expression 'then' thenexpr=Expression 'else' elseexpr=Expression
		//	| Fby;
		@Override public ParserRule getRule() { return rule; }
		
		//{IfThenElse} 'if' ifexpr=Expression 'then' thenexpr=Expression 'else' elseexpr=Expression | Fby
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//{IfThenElse} 'if' ifexpr=Expression 'then' thenexpr=Expression 'else' elseexpr=Expression
		public Group getGroup_0() { return cGroup_0; }
		
		//{IfThenElse}
		public Action getIfThenElseAction_0_0() { return cIfThenElseAction_0_0; }
		
		//'if'
		public Keyword getIfKeyword_0_1() { return cIfKeyword_0_1; }
		
		//ifexpr=Expression
		public Assignment getIfexprAssignment_0_2() { return cIfexprAssignment_0_2; }
		
		//Expression
		public RuleCall getIfexprExpressionParserRuleCall_0_2_0() { return cIfexprExpressionParserRuleCall_0_2_0; }
		
		//'then'
		public Keyword getThenKeyword_0_3() { return cThenKeyword_0_3; }
		
		//thenexpr=Expression
		public Assignment getThenexprAssignment_0_4() { return cThenexprAssignment_0_4; }
		
		//Expression
		public RuleCall getThenexprExpressionParserRuleCall_0_4_0() { return cThenexprExpressionParserRuleCall_0_4_0; }
		
		//'else'
		public Keyword getElseKeyword_0_5() { return cElseKeyword_0_5; }
		
		//elseexpr=Expression
		public Assignment getElseexprAssignment_0_6() { return cElseexprAssignment_0_6; }
		
		//Expression
		public RuleCall getElseexprExpressionParserRuleCall_0_6_0() { return cElseexprExpressionParserRuleCall_0_6_0; }
		
		//Fby
		public RuleCall getFbyParserRuleCall_1() { return cFbyParserRuleCall_1; }
	}
	public class FbyElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.Fby");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cArrowParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cFbySubExpressionsAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cGroup_1.eContents().get(1);
		private final Keyword cFbyKeyword_1_1_0 = (Keyword)cGroup_1_1.eContents().get(0);
		private final Assignment cSubExpressionsAssignment_1_1_1 = (Assignment)cGroup_1_1.eContents().get(1);
		private final RuleCall cSubExpressionsArrowParserRuleCall_1_1_1_0 = (RuleCall)cSubExpressionsAssignment_1_1_1.eContents().get(0);
		
		//Fby Expression:
		//	Arrow ({Fby.subExpressions+=current} ('fby' subExpressions+=Arrow)+)?
		@Override public ParserRule getRule() { return rule; }
		
		//Arrow ({Fby.subExpressions+=current} ('fby' subExpressions+=Arrow)+)?
		public Group getGroup() { return cGroup; }
		
		//Arrow
		public RuleCall getArrowParserRuleCall_0() { return cArrowParserRuleCall_0; }
		
		//({Fby.subExpressions+=current} ('fby' subExpressions+=Arrow)+)?
		public Group getGroup_1() { return cGroup_1; }
		
		//{Fby.subExpressions+=current}
		public Action getFbySubExpressionsAction_1_0() { return cFbySubExpressionsAction_1_0; }
		
		//('fby' subExpressions+=Arrow)+
		public Group getGroup_1_1() { return cGroup_1_1; }
		
		//'fby'
		public Keyword getFbyKeyword_1_1_0() { return cFbyKeyword_1_1_0; }
		
		//subExpressions+=Arrow
		public Assignment getSubExpressionsAssignment_1_1_1() { return cSubExpressionsAssignment_1_1_1; }
		
		//Arrow
		public RuleCall getSubExpressionsArrowParserRuleCall_1_1_1_0() { return cSubExpressionsArrowParserRuleCall_1_1_1_0; }
	}
	public class ArrowElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.Arrow");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cOrParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cArrowSubExpressionsAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cGroup_1.eContents().get(1);
		private final Keyword cHyphenMinusGreaterThanSignKeyword_1_1_0 = (Keyword)cGroup_1_1.eContents().get(0);
		private final Assignment cSubExpressionsAssignment_1_1_1 = (Assignment)cGroup_1_1.eContents().get(1);
		private final RuleCall cSubExpressionsOrParserRuleCall_1_1_1_0 = (RuleCall)cSubExpressionsAssignment_1_1_1.eContents().get(0);
		
		//Arrow Expression:
		//	Or ({Arrow.subExpressions+=current} ('->' subExpressions+=Or)+)?
		@Override public ParserRule getRule() { return rule; }
		
		//Or ({Arrow.subExpressions+=current} ('->' subExpressions+=Or)+)?
		public Group getGroup() { return cGroup; }
		
		//Or
		public RuleCall getOrParserRuleCall_0() { return cOrParserRuleCall_0; }
		
		//({Arrow.subExpressions+=current} ('->' subExpressions+=Or)+)?
		public Group getGroup_1() { return cGroup_1; }
		
		//{Arrow.subExpressions+=current}
		public Action getArrowSubExpressionsAction_1_0() { return cArrowSubExpressionsAction_1_0; }
		
		//('->' subExpressions+=Or)+
		public Group getGroup_1_1() { return cGroup_1_1; }
		
		//'->'
		public Keyword getHyphenMinusGreaterThanSignKeyword_1_1_0() { return cHyphenMinusGreaterThanSignKeyword_1_1_0; }
		
		//subExpressions+=Or
		public Assignment getSubExpressionsAssignment_1_1_1() { return cSubExpressionsAssignment_1_1_1; }
		
		//Or
		public RuleCall getSubExpressionsOrParserRuleCall_1_1_1_0() { return cSubExpressionsOrParserRuleCall_1_1_1_0; }
	}
	public class OrElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.Or");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAndParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cOrSubExpressionsAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cGroup_1.eContents().get(1);
		private final Keyword cOrKeyword_1_1_0 = (Keyword)cGroup_1_1.eContents().get(0);
		private final Assignment cSubExpressionsAssignment_1_1_1 = (Assignment)cGroup_1_1.eContents().get(1);
		private final RuleCall cSubExpressionsAndParserRuleCall_1_1_1_0 = (RuleCall)cSubExpressionsAssignment_1_1_1.eContents().get(0);
		
		//Or Expression:
		//	And ({Or.subExpressions+=current} ('or' subExpressions+=And)+)?
		@Override public ParserRule getRule() { return rule; }
		
		//And ({Or.subExpressions+=current} ('or' subExpressions+=And)+)?
		public Group getGroup() { return cGroup; }
		
		//And
		public RuleCall getAndParserRuleCall_0() { return cAndParserRuleCall_0; }
		
		//({Or.subExpressions+=current} ('or' subExpressions+=And)+)?
		public Group getGroup_1() { return cGroup_1; }
		
		//{Or.subExpressions+=current}
		public Action getOrSubExpressionsAction_1_0() { return cOrSubExpressionsAction_1_0; }
		
		//('or' subExpressions+=And)+
		public Group getGroup_1_1() { return cGroup_1_1; }
		
		//'or'
		public Keyword getOrKeyword_1_1_0() { return cOrKeyword_1_1_0; }
		
		//subExpressions+=And
		public Assignment getSubExpressionsAssignment_1_1_1() { return cSubExpressionsAssignment_1_1_1; }
		
		//And
		public RuleCall getSubExpressionsAndParserRuleCall_1_1_1_0() { return cSubExpressionsAndParserRuleCall_1_1_1_0; }
	}
	public class AndElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.And");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cEqualityParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cAndSubExpressionsAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cGroup_1.eContents().get(1);
		private final Keyword cAndKeyword_1_1_0 = (Keyword)cGroup_1_1.eContents().get(0);
		private final Assignment cSubExpressionsAssignment_1_1_1 = (Assignment)cGroup_1_1.eContents().get(1);
		private final RuleCall cSubExpressionsEqualityParserRuleCall_1_1_1_0 = (RuleCall)cSubExpressionsAssignment_1_1_1.eContents().get(0);
		
		//And Expression:
		//	Equality ({And.subExpressions+=current} ('and' subExpressions+=Equality)+)?
		@Override public ParserRule getRule() { return rule; }
		
		//Equality ({And.subExpressions+=current} ('and' subExpressions+=Equality)+)?
		public Group getGroup() { return cGroup; }
		
		//Equality
		public RuleCall getEqualityParserRuleCall_0() { return cEqualityParserRuleCall_0; }
		
		//({And.subExpressions+=current} ('and' subExpressions+=Equality)+)?
		public Group getGroup_1() { return cGroup_1; }
		
		//{And.subExpressions+=current}
		public Action getAndSubExpressionsAction_1_0() { return cAndSubExpressionsAction_1_0; }
		
		//('and' subExpressions+=Equality)+
		public Group getGroup_1_1() { return cGroup_1_1; }
		
		//'and'
		public Keyword getAndKeyword_1_1_0() { return cAndKeyword_1_1_0; }
		
		//subExpressions+=Equality
		public Assignment getSubExpressionsAssignment_1_1_1() { return cSubExpressionsAssignment_1_1_1; }
		
		//Equality
		public RuleCall getSubExpressionsEqualityParserRuleCall_1_1_1_0() { return cSubExpressionsEqualityParserRuleCall_1_1_1_0; }
	}
	public class EqualityElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.Equality");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cComparisonParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cEqualityLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Alternatives cOpAlternatives_1_1_0 = (Alternatives)cOpAssignment_1_1.eContents().get(0);
		private final Keyword cOpEqualsSignKeyword_1_1_0_0 = (Keyword)cOpAlternatives_1_1_0.eContents().get(0);
		private final Keyword cOpLessThanSignGreaterThanSignKeyword_1_1_0_1 = (Keyword)cOpAlternatives_1_1_0.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightComparisonParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Equality Expression:
		//	Comparison ({Equality.left=current} op=('=' | '<>') right=Comparison)*
		@Override public ParserRule getRule() { return rule; }
		
		//Comparison ({Equality.left=current} op=('=' | '<>') right=Comparison)*
		public Group getGroup() { return cGroup; }
		
		//Comparison
		public RuleCall getComparisonParserRuleCall_0() { return cComparisonParserRuleCall_0; }
		
		//({Equality.left=current} op=('=' | '<>') right=Comparison)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{Equality.left=current}
		public Action getEqualityLeftAction_1_0() { return cEqualityLeftAction_1_0; }
		
		//op=('=' | '<>')
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }
		
		//('=' | '<>')
		public Alternatives getOpAlternatives_1_1_0() { return cOpAlternatives_1_1_0; }
		
		//'='
		public Keyword getOpEqualsSignKeyword_1_1_0_0() { return cOpEqualsSignKeyword_1_1_0_0; }
		
		//'<>'
		public Keyword getOpLessThanSignGreaterThanSignKeyword_1_1_0_1() { return cOpLessThanSignGreaterThanSignKeyword_1_1_0_1; }
		
		//right=Comparison
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//Comparison
		public RuleCall getRightComparisonParserRuleCall_1_2_0() { return cRightComparisonParserRuleCall_1_2_0; }
	}
	public class ComparisonElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.Comparison");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cPlusOrMinusParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cComparisonLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Alternatives cOpAlternatives_1_1_0 = (Alternatives)cOpAssignment_1_1.eContents().get(0);
		private final Keyword cOpGreaterThanSignEqualsSignKeyword_1_1_0_0 = (Keyword)cOpAlternatives_1_1_0.eContents().get(0);
		private final Keyword cOpLessThanSignEqualsSignKeyword_1_1_0_1 = (Keyword)cOpAlternatives_1_1_0.eContents().get(1);
		private final Keyword cOpGreaterThanSignKeyword_1_1_0_2 = (Keyword)cOpAlternatives_1_1_0.eContents().get(2);
		private final Keyword cOpLessThanSignKeyword_1_1_0_3 = (Keyword)cOpAlternatives_1_1_0.eContents().get(3);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightPlusOrMinusParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Comparison Expression:
		//	PlusOrMinus ({Comparison.left=current} op=('>=' | '<=' | '>' | '<') right=PlusOrMinus)*
		@Override public ParserRule getRule() { return rule; }
		
		//PlusOrMinus ({Comparison.left=current} op=('>=' | '<=' | '>' | '<') right=PlusOrMinus)*
		public Group getGroup() { return cGroup; }
		
		//PlusOrMinus
		public RuleCall getPlusOrMinusParserRuleCall_0() { return cPlusOrMinusParserRuleCall_0; }
		
		//({Comparison.left=current} op=('>=' | '<=' | '>' | '<') right=PlusOrMinus)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{Comparison.left=current}
		public Action getComparisonLeftAction_1_0() { return cComparisonLeftAction_1_0; }
		
		//op=('>=' | '<=' | '>' | '<')
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }
		
		//('>=' | '<=' | '>' | '<')
		public Alternatives getOpAlternatives_1_1_0() { return cOpAlternatives_1_1_0; }
		
		//'>='
		public Keyword getOpGreaterThanSignEqualsSignKeyword_1_1_0_0() { return cOpGreaterThanSignEqualsSignKeyword_1_1_0_0; }
		
		//'<='
		public Keyword getOpLessThanSignEqualsSignKeyword_1_1_0_1() { return cOpLessThanSignEqualsSignKeyword_1_1_0_1; }
		
		//'>'
		public Keyword getOpGreaterThanSignKeyword_1_1_0_2() { return cOpGreaterThanSignKeyword_1_1_0_2; }
		
		//'<'
		public Keyword getOpLessThanSignKeyword_1_1_0_3() { return cOpLessThanSignKeyword_1_1_0_3; }
		
		//right=PlusOrMinus
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//PlusOrMinus
		public RuleCall getRightPlusOrMinusParserRuleCall_1_2_0() { return cRightPlusOrMinusParserRuleCall_1_2_0; }
	}
	public class PlusOrMinusElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.PlusOrMinus");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cMulOrDivParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_1_0 = (Alternatives)cGroup_1.eContents().get(0);
		private final Group cGroup_1_0_0 = (Group)cAlternatives_1_0.eContents().get(0);
		private final Action cPlusSubExpressionsAction_1_0_0_0 = (Action)cGroup_1_0_0.eContents().get(0);
		private final Keyword cPlusSignKeyword_1_0_0_1 = (Keyword)cGroup_1_0_0.eContents().get(1);
		private final Group cGroup_1_0_1 = (Group)cAlternatives_1_0.eContents().get(1);
		private final Action cMinusSubExpressionsAction_1_0_1_0 = (Action)cGroup_1_0_1.eContents().get(0);
		private final Keyword cHyphenMinusKeyword_1_0_1_1 = (Keyword)cGroup_1_0_1.eContents().get(1);
		private final Assignment cSubExpressionsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cSubExpressionsMulOrDivParserRuleCall_1_1_0 = (RuleCall)cSubExpressionsAssignment_1_1.eContents().get(0);
		
		//PlusOrMinus Expression:
		//	MulOrDiv (({Plus.subExpressions+=current} '+' | {Minus.subExpressions+=current} '-') subExpressions+=MulOrDiv)*
		@Override public ParserRule getRule() { return rule; }
		
		//MulOrDiv (({Plus.subExpressions+=current} '+' | {Minus.subExpressions+=current} '-') subExpressions+=MulOrDiv)*
		public Group getGroup() { return cGroup; }
		
		//MulOrDiv
		public RuleCall getMulOrDivParserRuleCall_0() { return cMulOrDivParserRuleCall_0; }
		
		//(({Plus.subExpressions+=current} '+' | {Minus.subExpressions+=current} '-') subExpressions+=MulOrDiv)*
		public Group getGroup_1() { return cGroup_1; }
		
		//({Plus.subExpressions+=current} '+' | {Minus.subExpressions+=current} '-')
		public Alternatives getAlternatives_1_0() { return cAlternatives_1_0; }
		
		//{Plus.subExpressions+=current} '+'
		public Group getGroup_1_0_0() { return cGroup_1_0_0; }
		
		//{Plus.subExpressions+=current}
		public Action getPlusSubExpressionsAction_1_0_0_0() { return cPlusSubExpressionsAction_1_0_0_0; }
		
		//'+'
		public Keyword getPlusSignKeyword_1_0_0_1() { return cPlusSignKeyword_1_0_0_1; }
		
		//{Minus.subExpressions+=current} '-'
		public Group getGroup_1_0_1() { return cGroup_1_0_1; }
		
		//{Minus.subExpressions+=current}
		public Action getMinusSubExpressionsAction_1_0_1_0() { return cMinusSubExpressionsAction_1_0_1_0; }
		
		//'-'
		public Keyword getHyphenMinusKeyword_1_0_1_1() { return cHyphenMinusKeyword_1_0_1_1; }
		
		//subExpressions+=MulOrDiv
		public Assignment getSubExpressionsAssignment_1_1() { return cSubExpressionsAssignment_1_1; }
		
		//MulOrDiv
		public RuleCall getSubExpressionsMulOrDivParserRuleCall_1_1_0() { return cSubExpressionsMulOrDivParserRuleCall_1_1_0; }
	}
	public class MulOrDivElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.MulOrDiv");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cPrimaryParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_1_0 = (Alternatives)cGroup_1.eContents().get(0);
		private final Group cGroup_1_0_0 = (Group)cAlternatives_1_0.eContents().get(0);
		private final Action cMulSubExpressionsAction_1_0_0_0 = (Action)cGroup_1_0_0.eContents().get(0);
		private final Keyword cAsteriskKeyword_1_0_0_1 = (Keyword)cGroup_1_0_0.eContents().get(1);
		private final Group cGroup_1_0_1 = (Group)cAlternatives_1_0.eContents().get(1);
		private final Action cDivSubExpressionsAction_1_0_1_0 = (Action)cGroup_1_0_1.eContents().get(0);
		private final Keyword cSolidusKeyword_1_0_1_1 = (Keyword)cGroup_1_0_1.eContents().get(1);
		private final Assignment cSubExpressionsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cSubExpressionsPrimaryParserRuleCall_1_1_0 = (RuleCall)cSubExpressionsAssignment_1_1.eContents().get(0);
		
		//MulOrDiv Expression:
		//	Primary (({Mul.subExpressions+=current} '*' | {Div.subExpressions+=current} '/') subExpressions+=Primary)*
		@Override public ParserRule getRule() { return rule; }
		
		//Primary (({Mul.subExpressions+=current} '*' | {Div.subExpressions+=current} '/') subExpressions+=Primary)*
		public Group getGroup() { return cGroup; }
		
		//Primary
		public RuleCall getPrimaryParserRuleCall_0() { return cPrimaryParserRuleCall_0; }
		
		//(({Mul.subExpressions+=current} '*' | {Div.subExpressions+=current} '/') subExpressions+=Primary)*
		public Group getGroup_1() { return cGroup_1; }
		
		//({Mul.subExpressions+=current} '*' | {Div.subExpressions+=current} '/')
		public Alternatives getAlternatives_1_0() { return cAlternatives_1_0; }
		
		//{Mul.subExpressions+=current} '*'
		public Group getGroup_1_0_0() { return cGroup_1_0_0; }
		
		//{Mul.subExpressions+=current}
		public Action getMulSubExpressionsAction_1_0_0_0() { return cMulSubExpressionsAction_1_0_0_0; }
		
		//'*'
		public Keyword getAsteriskKeyword_1_0_0_1() { return cAsteriskKeyword_1_0_0_1; }
		
		//{Div.subExpressions+=current} '/'
		public Group getGroup_1_0_1() { return cGroup_1_0_1; }
		
		//{Div.subExpressions+=current}
		public Action getDivSubExpressionsAction_1_0_1_0() { return cDivSubExpressionsAction_1_0_1_0; }
		
		//'/'
		public Keyword getSolidusKeyword_1_0_1_1() { return cSolidusKeyword_1_0_1_1; }
		
		//subExpressions+=Primary
		public Assignment getSubExpressionsAssignment_1_1() { return cSubExpressionsAssignment_1_1; }
		
		//Primary
		public RuleCall getSubExpressionsPrimaryParserRuleCall_1_1_0() { return cSubExpressionsPrimaryParserRuleCall_1_1_0; }
	}
	public class PrimaryElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.Primary");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final RuleCall cExpressionParserRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_0_2 = (Keyword)cGroup_0.eContents().get(2);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cNotAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cNotKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cExpressionAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cExpressionPrimaryParserRuleCall_1_2_0 = (RuleCall)cExpressionAssignment_1_2.eContents().get(0);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Action cUMinusAction_2_0 = (Action)cGroup_2.eContents().get(0);
		private final Keyword cHyphenMinusKeyword_2_1 = (Keyword)cGroup_2.eContents().get(1);
		private final Assignment cExpressionAssignment_2_2 = (Assignment)cGroup_2.eContents().get(2);
		private final RuleCall cExpressionPrimaryParserRuleCall_2_2_0 = (RuleCall)cExpressionAssignment_2_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cAlternatives.eContents().get(3);
		private final Action cPreAction_3_0 = (Action)cGroup_3.eContents().get(0);
		private final Keyword cPreKeyword_3_1 = (Keyword)cGroup_3.eContents().get(1);
		private final Assignment cExpressionAssignment_3_2 = (Assignment)cGroup_3.eContents().get(2);
		private final RuleCall cExpressionPrimaryParserRuleCall_3_2_0 = (RuleCall)cExpressionAssignment_3_2.eContents().get(0);
		private final Group cGroup_4 = (Group)cAlternatives.eContents().get(4);
		private final Action cCurrentAction_4_0 = (Action)cGroup_4.eContents().get(0);
		private final Keyword cCurrentKeyword_4_1 = (Keyword)cGroup_4.eContents().get(1);
		private final Assignment cExpressionAssignment_4_2 = (Assignment)cGroup_4.eContents().get(2);
		private final RuleCall cExpressionPrimaryParserRuleCall_4_2_0 = (RuleCall)cExpressionAssignment_4_2.eContents().get(0);
		private final RuleCall cAtomicExpressionParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		
		//Primary Expression:
		//	'(' Expression ')'
		//	| {Not} 'not' expression=Primary
		//	| {UMinus} '-' expression=Primary
		//	| {Pre} 'pre' expression=Primary
		//	| {Current} 'current' expression=Primary
		//	| AtomicExpression
		@Override public ParserRule getRule() { return rule; }
		
		//'(' Expression ')' | {Not} 'not' expression=Primary | {UMinus} '-' expression=Primary | {Pre} 'pre' expression=Primary |
		//{Current} 'current' expression=Primary | AtomicExpression
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'(' Expression ')'
		public Group getGroup_0() { return cGroup_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_0_0() { return cLeftParenthesisKeyword_0_0; }
		
		//Expression
		public RuleCall getExpressionParserRuleCall_0_1() { return cExpressionParserRuleCall_0_1; }
		
		//')'
		public Keyword getRightParenthesisKeyword_0_2() { return cRightParenthesisKeyword_0_2; }
		
		//{Not} 'not' expression=Primary
		public Group getGroup_1() { return cGroup_1; }
		
		//{Not}
		public Action getNotAction_1_0() { return cNotAction_1_0; }
		
		//'not'
		public Keyword getNotKeyword_1_1() { return cNotKeyword_1_1; }
		
		//expression=Primary
		public Assignment getExpressionAssignment_1_2() { return cExpressionAssignment_1_2; }
		
		//Primary
		public RuleCall getExpressionPrimaryParserRuleCall_1_2_0() { return cExpressionPrimaryParserRuleCall_1_2_0; }
		
		//{UMinus} '-' expression=Primary
		public Group getGroup_2() { return cGroup_2; }
		
		//{UMinus}
		public Action getUMinusAction_2_0() { return cUMinusAction_2_0; }
		
		//'-'
		public Keyword getHyphenMinusKeyword_2_1() { return cHyphenMinusKeyword_2_1; }
		
		//expression=Primary
		public Assignment getExpressionAssignment_2_2() { return cExpressionAssignment_2_2; }
		
		//Primary
		public RuleCall getExpressionPrimaryParserRuleCall_2_2_0() { return cExpressionPrimaryParserRuleCall_2_2_0; }
		
		//{Pre} 'pre' expression=Primary
		public Group getGroup_3() { return cGroup_3; }
		
		//{Pre}
		public Action getPreAction_3_0() { return cPreAction_3_0; }
		
		//'pre'
		public Keyword getPreKeyword_3_1() { return cPreKeyword_3_1; }
		
		//expression=Primary
		public Assignment getExpressionAssignment_3_2() { return cExpressionAssignment_3_2; }
		
		//Primary
		public RuleCall getExpressionPrimaryParserRuleCall_3_2_0() { return cExpressionPrimaryParserRuleCall_3_2_0; }
		
		//{Current} 'current' expression=Primary
		public Group getGroup_4() { return cGroup_4; }
		
		//{Current}
		public Action getCurrentAction_4_0() { return cCurrentAction_4_0; }
		
		//'current'
		public Keyword getCurrentKeyword_4_1() { return cCurrentKeyword_4_1; }
		
		//expression=Primary
		public Assignment getExpressionAssignment_4_2() { return cExpressionAssignment_4_2; }
		
		//Primary
		public RuleCall getExpressionPrimaryParserRuleCall_4_2_0() { return cExpressionPrimaryParserRuleCall_4_2_0; }
		
		//AtomicExpression
		public RuleCall getAtomicExpressionParserRuleCall_5() { return cAtomicExpressionParserRuleCall_5; }
	}
	public class AtomicExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.AtomicExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cConstantExpressionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cVariableReferenceParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//AtomicExpression Expression:
		//	ConstantExpression | VariableReference
		@Override public ParserRule getRule() { return rule; }
		
		//ConstantExpression | VariableReference
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//ConstantExpression
		public RuleCall getConstantExpressionParserRuleCall_0() { return cConstantExpressionParserRuleCall_0; }
		
		//VariableReference
		public RuleCall getVariableReferenceParserRuleCall_1() { return cVariableReferenceParserRuleCall_1; }
	}
	public class VariableReferenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.VariableReference");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cVariableReferenceAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cValueAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cValueVariable_DeclarationCrossReference_1_0 = (CrossReference)cValueAssignment_1.eContents().get(0);
		private final RuleCall cValueVariable_DeclarationIDENTTerminalRuleCall_1_0_1 = (RuleCall)cValueVariable_DeclarationCrossReference_1_0.eContents().get(1);
		
		//VariableReference:
		//	{VariableReference} value=[Variable_Declaration|IDENT];
		@Override public ParserRule getRule() { return rule; }
		
		//{VariableReference} value=[Variable_Declaration|IDENT]
		public Group getGroup() { return cGroup; }
		
		//{VariableReference}
		public Action getVariableReferenceAction_0() { return cVariableReferenceAction_0; }
		
		//value=[Variable_Declaration|IDENT]
		public Assignment getValueAssignment_1() { return cValueAssignment_1; }
		
		//[Variable_Declaration|IDENT]
		public CrossReference getValueVariable_DeclarationCrossReference_1_0() { return cValueVariable_DeclarationCrossReference_1_0; }
		
		//IDENT
		public RuleCall getValueVariable_DeclarationIDENTTerminalRuleCall_1_0_1() { return cValueVariable_DeclarationIDENTTerminalRuleCall_1_0_1; }
	}
	public class ConstantExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.ConstantExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cBoolConstantAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Assignment cValueAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cValueBOOLTerminalRuleCall_0_1_0 = (RuleCall)cValueAssignment_0_1.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cFloatConstantAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cValueAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cValueFLOATTerminalRuleCall_1_1_0 = (RuleCall)cValueAssignment_1_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Action cIntConstantAction_2_0 = (Action)cGroup_2.eContents().get(0);
		private final Assignment cValueAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cValueINTTerminalRuleCall_2_1_0 = (RuleCall)cValueAssignment_2_1.eContents().get(0);
		
		//ConstantExpression Expression:
		//	{BoolConstant} value=BOOL
		//	| {FloatConstant} value=FLOAT
		//	| {IntConstant} value=INT
		@Override public ParserRule getRule() { return rule; }
		
		//{BoolConstant} value=BOOL | {FloatConstant} value=FLOAT | {IntConstant} value=INT
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//{BoolConstant} value=BOOL
		public Group getGroup_0() { return cGroup_0; }
		
		//{BoolConstant}
		public Action getBoolConstantAction_0_0() { return cBoolConstantAction_0_0; }
		
		//value=BOOL
		public Assignment getValueAssignment_0_1() { return cValueAssignment_0_1; }
		
		//BOOL
		public RuleCall getValueBOOLTerminalRuleCall_0_1_0() { return cValueBOOLTerminalRuleCall_0_1_0; }
		
		//{FloatConstant} value=FLOAT
		public Group getGroup_1() { return cGroup_1; }
		
		//{FloatConstant}
		public Action getFloatConstantAction_1_0() { return cFloatConstantAction_1_0; }
		
		//value=FLOAT
		public Assignment getValueAssignment_1_1() { return cValueAssignment_1_1; }
		
		//FLOAT
		public RuleCall getValueFLOATTerminalRuleCall_1_1_0() { return cValueFLOATTerminalRuleCall_1_1_0; }
		
		//{IntConstant} value=INT
		public Group getGroup_2() { return cGroup_2; }
		
		//{IntConstant}
		public Action getIntConstantAction_2_0() { return cIntConstantAction_2_0; }
		
		//value=INT
		public Assignment getValueAssignment_2_1() { return cValueAssignment_2_1; }
		
		//INT
		public RuleCall getValueINTTerminalRuleCall_2_1_0() { return cValueINTTerminalRuleCall_2_1_0; }
	}
	
	
	private final ProgramElements pProgram;
	private final Package_DeclarationElements pPackage_Declaration;
	private final Package_ProvidedElements pPackage_Provided;
	private final Package_Provided_IOElements pPackage_Provided_IO;
	private final Entity_DeclarationElements pEntity_Declaration;
	private final Type_DeclarationElements pType_Declaration;
	private final TypeElements pType;
	private final Array_TypeElements pArray_Type;
	private final Record_TypeElements pRecord_Type;
	private final FieldElements pField;
	private final Constant_DeclarationElements pConstant_Declaration;
	private final Variable_DeclarationElements pVariable_Declaration;
	private final Local_Variable_DeclarationElements pLocal_Variable_Declaration;
	private final Local_Constant_DeclarationElements pLocal_Constant_Declaration;
	private final Node_DeclarationElements pNode_Declaration;
	private final EquationElements pEquation;
	private final AssertionElements pAssertion;
	private final Left_PartElements pLeft_Part;
	private final Left_ListElements pLeft_List;
	private final LeftElements pLeft;
	private final SelectorElements pSelector;
	private final SelTrancheEndElements pSelTrancheEnd;
	private final Right_PartElements pRight_Part;
	private final ExpressionElements pExpression;
	private final FbyElements pFby;
	private final ArrowElements pArrow;
	private final OrElements pOr;
	private final AndElements pAnd;
	private final EqualityElements pEquality;
	private final ComparisonElements pComparison;
	private final PlusOrMinusElements pPlusOrMinus;
	private final MulOrDivElements pMulOrDiv;
	private final PrimaryElements pPrimary;
	private final AtomicExpressionElements pAtomicExpression;
	private final VariableReferenceElements pVariableReference;
	private final ConstantExpressionElements pConstantExpression;
	private final TerminalRule tBOOL;
	private final TerminalRule tIDENT;
	private final TerminalRule tINT;
	private final TerminalRule tFLOAT;
	private final TerminalRule tSTRING_CONSTANT;
	private final TerminalRule tLUSTRE_COMMENT;
	private final TerminalRule tML_COMMENT;
	private final TerminalRule tSL_COMMENT;
	private final TerminalRule tWS;
	
	private final Grammar grammar;

	@Inject
	public LustreGrammarAccess(GrammarProvider grammarProvider) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.pProgram = new ProgramElements();
		this.pPackage_Declaration = new Package_DeclarationElements();
		this.pPackage_Provided = new Package_ProvidedElements();
		this.pPackage_Provided_IO = new Package_Provided_IOElements();
		this.pEntity_Declaration = new Entity_DeclarationElements();
		this.pType_Declaration = new Type_DeclarationElements();
		this.pType = new TypeElements();
		this.pArray_Type = new Array_TypeElements();
		this.pRecord_Type = new Record_TypeElements();
		this.pField = new FieldElements();
		this.pConstant_Declaration = new Constant_DeclarationElements();
		this.pVariable_Declaration = new Variable_DeclarationElements();
		this.pLocal_Variable_Declaration = new Local_Variable_DeclarationElements();
		this.pLocal_Constant_Declaration = new Local_Constant_DeclarationElements();
		this.pNode_Declaration = new Node_DeclarationElements();
		this.pEquation = new EquationElements();
		this.pAssertion = new AssertionElements();
		this.pLeft_Part = new Left_PartElements();
		this.pLeft_List = new Left_ListElements();
		this.pLeft = new LeftElements();
		this.pSelector = new SelectorElements();
		this.pSelTrancheEnd = new SelTrancheEndElements();
		this.pRight_Part = new Right_PartElements();
		this.pExpression = new ExpressionElements();
		this.pFby = new FbyElements();
		this.pArrow = new ArrowElements();
		this.pOr = new OrElements();
		this.pAnd = new AndElements();
		this.pEquality = new EqualityElements();
		this.pComparison = new ComparisonElements();
		this.pPlusOrMinus = new PlusOrMinusElements();
		this.pMulOrDiv = new MulOrDivElements();
		this.pPrimary = new PrimaryElements();
		this.pAtomicExpression = new AtomicExpressionElements();
		this.pVariableReference = new VariableReferenceElements();
		this.pConstantExpression = new ConstantExpressionElements();
		this.tBOOL = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.BOOL");
		this.tIDENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.IDENT");
		this.tINT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.INT");
		this.tFLOAT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.FLOAT");
		this.tSTRING_CONSTANT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.STRING_CONSTANT");
		this.tLUSTRE_COMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.LUSTRE_COMMENT");
		this.tML_COMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.ML_COMMENT");
		this.tSL_COMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.SL_COMMENT");
		this.tWS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.WS");
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("de.cau.cs.kieler.lustre.Lustre".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	

	
	/// **
	// * @author cpa
	// * / Program hidden(WS, LUSTRE_COMMENT):
	//	packages+=Package_Declaration+;
	public ProgramElements getProgramAccess() {
		return pProgram;
	}
	
	public ParserRule getProgramRule() {
		return getProgramAccess().getRule();
	}
	
	/// *
	// * Packages
	// * / Package_Declaration:
	//	'package' name=IDENT ('uses' uses+=IDENT (',' uses+=IDENT)*)?
	//	'provides' provides+=Package_Provided+
	//	'body' (nodes+=Node_Declaration | types+=Type_Declaration | constants+=Constant_Declaration)*
	//	'end';
	public Package_DeclarationElements getPackage_DeclarationAccess() {
		return pPackage_Declaration;
	}
	
	public ParserRule getPackage_DeclarationRule() {
		return getPackage_DeclarationAccess().getRule();
	}
	
	//Package_Provided:
	//	'node' name=[Node_Declaration|IDENT]
	//	'(' (parameters+=Package_Provided_IO (',' parameters+=Package_Provided_IO)*)? ')'
	//	'returns' '(' returned+=Package_Provided_IO (',' returned+=Package_Provided_IO)* ')'
	//	';';
	public Package_ProvidedElements getPackage_ProvidedAccess() {
		return pPackage_Provided;
	}
	
	public ParserRule getPackage_ProvidedRule() {
		return getPackage_ProvidedAccess().getRule();
	}
	
	//Package_Provided_IO:
	//	name=[Variable_Declaration|IDENT] ':' type=IDENT;
	public Package_Provided_IOElements getPackage_Provided_IOAccess() {
		return pPackage_Provided_IO;
	}
	
	public ParserRule getPackage_Provided_IORule() {
		return getPackage_Provided_IOAccess().getRule();
	}
	
	//Entity_Declaration:
	//	Node_Declaration
	//	| Type_Declaration
	//	| Constant_Declaration;
	public Entity_DeclarationElements getEntity_DeclarationAccess() {
		return pEntity_Declaration;
	}
	
	public ParserRule getEntity_DeclarationRule() {
		return getEntity_DeclarationAccess().getRule();
	}
	
	/// *
	// * Identifiers
	// * / //Identifier:
	////    (package=[Package | IDENT] '::')? name=[Variable_Declaration | IDENT] | name=[Node_Declaration | IDENT];
	/// * 
	// * Types
	// * / Type_Declaration:
	//	'type' name=IDENT ';'
	//	| 'type' name=IDENT '=' type=Type ';';
	public Type_DeclarationElements getType_DeclarationAccess() {
		return pType_Declaration;
	}
	
	public ParserRule getType_DeclarationRule() {
		return getType_DeclarationAccess().getRule();
	}
	
	//Type:
	//	name=[Type_Declaration|IDENT];
	public TypeElements getTypeAccess() {
		return pType;
	}
	
	public ParserRule getTypeRule() {
		return getTypeAccess().getRule();
	}
	
	//Array_Type:
	//	type=[Type_Declaration|IDENT] '^' length=INT
	//	// XXX Original Lustre allows Type^Expression  
	//;
	public Array_TypeElements getArray_TypeAccess() {
		return pArray_Type;
	}
	
	public ParserRule getArray_TypeRule() {
		return getArray_TypeAccess().getRule();
	}
	
	//Record_Type:
	//	'struct' '{' fields+=Field (',' fields+=Field)* '}';
	public Record_TypeElements getRecord_TypeAccess() {
		return pRecord_Type;
	}
	
	public ParserRule getRecord_TypeRule() {
		return getRecord_TypeAccess().getRule();
	}
	
	//Field:
	//	name=IDENT ':' type=[Type|IDENT];
	public FieldElements getFieldAccess() {
		return pField;
	}
	
	public ParserRule getFieldRule() {
		return getFieldAccess().getRule();
	}
	
	////Enum_Type:
	////    'enum' '{' nameList=Ident_List '}'
	////;
	/// *
	// * Constants and variables
	// * / Constant_Declaration:
	//	'const' name=IDENT ':' type=Type ';'
	//	| 'const' name=IDENT '=' expr=ConstantExpression ';'
	//	| 'const' name=IDENT ':' type=Type '=' expr=ConstantExpression ';'
	//	// XXX Original Lustre allows Expressions
	//;
	public Constant_DeclarationElements getConstant_DeclarationAccess() {
		return pConstant_Declaration;
	}
	
	public ParserRule getConstant_DeclarationRule() {
		return getConstant_DeclarationAccess().getRule();
	}
	
	//Variable_Declaration:
	//	name=IDENT ':' type=Type ('when' clock=IDENT)?;
	public Variable_DeclarationElements getVariable_DeclarationAccess() {
		return pVariable_Declaration;
	}
	
	public ParserRule getVariable_DeclarationRule() {
		return getVariable_DeclarationAccess().getRule();
	}
	
	//Local_Variable_Declaration Variable_Declaration:
	//	'var' Variable_Declaration ';'
	public Local_Variable_DeclarationElements getLocal_Variable_DeclarationAccess() {
		return pLocal_Variable_Declaration;
	}
	
	public ParserRule getLocal_Variable_DeclarationRule() {
		return getLocal_Variable_DeclarationAccess().getRule();
	}
	
	//Local_Constant_Declaration Constant_Declaration:
	//	{Constant_Declaration} 'const' name=IDENT '=' expr=ConstantExpression ';'
	//	| {Constant_Declaration} 'const' name=IDENT ':' type=Type '=' expr=ConstantExpression ';'
	public Local_Constant_DeclarationElements getLocal_Constant_DeclarationAccess() {
		return pLocal_Constant_Declaration;
	}
	
	public ParserRule getLocal_Constant_DeclarationRule() {
		return getLocal_Constant_DeclarationAccess().getRule();
	}
	
	/// *
	// * Nodes
	// * / Node_Declaration:
	//	'node'
	//	name=IDENT
	//	'(' (parameters+=Variable_Declaration (',' parameters+=Variable_Declaration)*)? ')'
	//	'returns' '(' returned+=Variable_Declaration (',' returned+=Variable_Declaration)* ')'
	//	';' (constants+=Local_Constant_Declaration | variables+=Local_Variable_Declaration)*
	//	'let' (equations+=Equation | assertions+=Assertion)*
	//	'tel' ';'?;
	public Node_DeclarationElements getNode_DeclarationAccess() {
		return pNode_Declaration;
	}
	
	public ParserRule getNode_DeclarationRule() {
		return getNode_DeclarationAccess().getRule();
	}
	
	//Equation:
	//	left=[Variable_Declaration|IDENT] '=' right=Right_Part ';';
	public EquationElements getEquationAccess() {
		return pEquation;
	}
	
	public ParserRule getEquationRule() {
		return getEquationAccess().getRule();
	}
	
	//Assertion:
	//	'assert' Expression ';';
	public AssertionElements getAssertionAccess() {
		return pAssertion;
	}
	
	public ParserRule getAssertionRule() {
		return getAssertionAccess().getRule();
	}
	
	//Left_Part:
	//	'(' Left_List ')'
	//	| Left_List;
	public Left_PartElements getLeft_PartAccess() {
		return pLeft_Part;
	}
	
	public ParserRule getLeft_PartRule() {
		return getLeft_PartAccess().getRule();
	}
	
	//Left_List:
	//	id+=Left (',' id+=Left)*;
	public Left_ListElements getLeft_ListAccess() {
		return pLeft_List;
	}
	
	public ParserRule getLeft_ListRule() {
		return getLeft_ListAccess().getRule();
	}
	
	//Left:
	//	name=IDENT selector=Selector?;
	public LeftElements getLeftAccess() {
		return pLeft;
	}
	
	public ParserRule getLeftRule() {
		return getLeftAccess().getRule();
	}
	
	//Selector:
	//	'.' name=IDENT
	//	| '[' begin=Expression end=SelTrancheEnd? ']';
	public SelectorElements getSelectorAccess() {
		return pSelector;
	}
	
	public ParserRule getSelectorRule() {
		return getSelectorAccess().getRule();
	}
	
	//SelTrancheEnd Expression:
	//	'..' Expression
	public SelTrancheEndElements getSelTrancheEndAccess() {
		return pSelTrancheEnd;
	}
	
	public ParserRule getSelTrancheEndRule() {
		return getSelTrancheEndAccess().getRule();
	}
	
	//Right_Part Expression:
	//	Expression
	public Right_PartElements getRight_PartAccess() {
		return pRight_Part;
	}
	
	public ParserRule getRight_PartRule() {
		return getRight_PartAccess().getRule();
	}
	
	/// *
	// * Expressions
	// * / Expression:
	//	{IfThenElse} 'if' ifexpr=Expression 'then' thenexpr=Expression 'else' elseexpr=Expression
	//	| Fby;
	public ExpressionElements getExpressionAccess() {
		return pExpression;
	}
	
	public ParserRule getExpressionRule() {
		return getExpressionAccess().getRule();
	}
	
	//Fby Expression:
	//	Arrow ({Fby.subExpressions+=current} ('fby' subExpressions+=Arrow)+)?
	public FbyElements getFbyAccess() {
		return pFby;
	}
	
	public ParserRule getFbyRule() {
		return getFbyAccess().getRule();
	}
	
	//Arrow Expression:
	//	Or ({Arrow.subExpressions+=current} ('->' subExpressions+=Or)+)?
	public ArrowElements getArrowAccess() {
		return pArrow;
	}
	
	public ParserRule getArrowRule() {
		return getArrowAccess().getRule();
	}
	
	//Or Expression:
	//	And ({Or.subExpressions+=current} ('or' subExpressions+=And)+)?
	public OrElements getOrAccess() {
		return pOr;
	}
	
	public ParserRule getOrRule() {
		return getOrAccess().getRule();
	}
	
	//And Expression:
	//	Equality ({And.subExpressions+=current} ('and' subExpressions+=Equality)+)?
	public AndElements getAndAccess() {
		return pAnd;
	}
	
	public ParserRule getAndRule() {
		return getAndAccess().getRule();
	}
	
	//Equality Expression:
	//	Comparison ({Equality.left=current} op=('=' | '<>') right=Comparison)*
	public EqualityElements getEqualityAccess() {
		return pEquality;
	}
	
	public ParserRule getEqualityRule() {
		return getEqualityAccess().getRule();
	}
	
	//Comparison Expression:
	//	PlusOrMinus ({Comparison.left=current} op=('>=' | '<=' | '>' | '<') right=PlusOrMinus)*
	public ComparisonElements getComparisonAccess() {
		return pComparison;
	}
	
	public ParserRule getComparisonRule() {
		return getComparisonAccess().getRule();
	}
	
	//PlusOrMinus Expression:
	//	MulOrDiv (({Plus.subExpressions+=current} '+' | {Minus.subExpressions+=current} '-') subExpressions+=MulOrDiv)*
	public PlusOrMinusElements getPlusOrMinusAccess() {
		return pPlusOrMinus;
	}
	
	public ParserRule getPlusOrMinusRule() {
		return getPlusOrMinusAccess().getRule();
	}
	
	//MulOrDiv Expression:
	//	Primary (({Mul.subExpressions+=current} '*' | {Div.subExpressions+=current} '/') subExpressions+=Primary)*
	public MulOrDivElements getMulOrDivAccess() {
		return pMulOrDiv;
	}
	
	public ParserRule getMulOrDivRule() {
		return getMulOrDivAccess().getRule();
	}
	
	//Primary Expression:
	//	'(' Expression ')'
	//	| {Not} 'not' expression=Primary
	//	| {UMinus} '-' expression=Primary
	//	| {Pre} 'pre' expression=Primary
	//	| {Current} 'current' expression=Primary
	//	| AtomicExpression
	public PrimaryElements getPrimaryAccess() {
		return pPrimary;
	}
	
	public ParserRule getPrimaryRule() {
		return getPrimaryAccess().getRule();
	}
	
	//AtomicExpression Expression:
	//	ConstantExpression | VariableReference
	public AtomicExpressionElements getAtomicExpressionAccess() {
		return pAtomicExpression;
	}
	
	public ParserRule getAtomicExpressionRule() {
		return getAtomicExpressionAccess().getRule();
	}
	
	//VariableReference:
	//	{VariableReference} value=[Variable_Declaration|IDENT];
	public VariableReferenceElements getVariableReferenceAccess() {
		return pVariableReference;
	}
	
	public ParserRule getVariableReferenceRule() {
		return getVariableReferenceAccess().getRule();
	}
	
	//ConstantExpression Expression:
	//	{BoolConstant} value=BOOL
	//	| {FloatConstant} value=FLOAT
	//	| {IntConstant} value=INT
	public ConstantExpressionElements getConstantExpressionAccess() {
		return pConstantExpression;
	}
	
	public ParserRule getConstantExpressionRule() {
		return getConstantExpressionAccess().getRule();
	}
	
	//terminal BOOL returns ecore::EBoolean:
	//	'true' | 'false';
	public TerminalRule getBOOLRule() {
		return tBOOL;
	}
	
	//terminal IDENT:
	//	'^'? ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;
	public TerminalRule getIDENTRule() {
		return tIDENT;
	}
	
	//terminal INT returns ecore::EInt:
	//	'0'..'9'+;
	public TerminalRule getINTRule() {
		return tINT;
	}
	
	//terminal FLOAT returns ecore::EFloat:
	//	'0'..'9'+ '.' '0'..'9'*
	//	| '.' '0'..'9'+;
	public TerminalRule getFLOATRule() {
		return tFLOAT;
	}
	
	//terminal STRING_CONSTANT:
	//	'"' ('\\' ('b' | 't' | 'n' | 'f' | 'r' | 'u' | '"' | "'" | '\\') | !('\\' | '"'))* '"' |
	//	"'" ('\\' ('b' | 't' | 'n' | 'f' | 'r' | 'u' | '"' | "'" | '\\') | !('\\' | "'"))* "'";
	public TerminalRule getSTRING_CONSTANTRule() {
		return tSTRING_CONSTANT;
	}
	
	//terminal LUSTRE_COMMENT:
	//	ML_COMMENT | SL_COMMENT;
	public TerminalRule getLUSTRE_COMMENTRule() {
		return tLUSTRE_COMMENT;
	}
	
	//terminal ML_COMMENT:
	//	'(*'->'*)';
	public TerminalRule getML_COMMENTRule() {
		return tML_COMMENT;
	}
	
	//terminal SL_COMMENT:
	//	'--' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return tSL_COMMENT;
	}
	
	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return tWS;
	}
}
