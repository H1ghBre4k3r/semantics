/*
 * generated by Xtext 2.10.0
 */
package de.cau.cs.kieler.lustre.serializer;

import com.google.inject.Inject;
import de.cau.cs.kieler.lustre.lustre.And;
import de.cau.cs.kieler.lustre.lustre.Arrow;
import de.cau.cs.kieler.lustre.lustre.BooleanConstant;
import de.cau.cs.kieler.lustre.lustre.Comparison;
import de.cau.cs.kieler.lustre.lustre.Const_Decl;
import de.cau.cs.kieler.lustre.lustre.Current;
import de.cau.cs.kieler.lustre.lustre.Declared_Clock;
import de.cau.cs.kieler.lustre.lustre.Div;
import de.cau.cs.kieler.lustre.lustre.Enum_Type;
import de.cau.cs.kieler.lustre.lustre.Equality;
import de.cau.cs.kieler.lustre.lustre.Equation;
import de.cau.cs.kieler.lustre.lustre.Equation_List;
import de.cau.cs.kieler.lustre.lustre.FN_Body;
import de.cau.cs.kieler.lustre.lustre.Fby;
import de.cau.cs.kieler.lustre.lustre.Field;
import de.cau.cs.kieler.lustre.lustre.Field_List;
import de.cau.cs.kieler.lustre.lustre.FloatConstant;
import de.cau.cs.kieler.lustre.lustre.Ident_List;
import de.cau.cs.kieler.lustre.lustre.Identifier;
import de.cau.cs.kieler.lustre.lustre.IfThenElse;
import de.cau.cs.kieler.lustre.lustre.IntConstant;
import de.cau.cs.kieler.lustre.lustre.Left;
import de.cau.cs.kieler.lustre.lustre.Left_List;
import de.cau.cs.kieler.lustre.lustre.LustrePackage;
import de.cau.cs.kieler.lustre.lustre.Minus;
import de.cau.cs.kieler.lustre.lustre.Mul;
import de.cau.cs.kieler.lustre.lustre.Node_Decl;
import de.cau.cs.kieler.lustre.lustre.Node_Header;
import de.cau.cs.kieler.lustre.lustre.Not;
import de.cau.cs.kieler.lustre.lustre.Or;
import de.cau.cs.kieler.lustre.lustre.Package_Body_Content;
import de.cau.cs.kieler.lustre.lustre.Package_Header;
import de.cau.cs.kieler.lustre.lustre.Package_Provide;
import de.cau.cs.kieler.lustre.lustre.Plus;
import de.cau.cs.kieler.lustre.lustre.Pre;
import de.cau.cs.kieler.lustre.lustre.Program;
import de.cau.cs.kieler.lustre.lustre.Record_Type;
import de.cau.cs.kieler.lustre.lustre.Selector;
import de.cau.cs.kieler.lustre.lustre.Type;
import de.cau.cs.kieler.lustre.lustre.Type_Decl;
import de.cau.cs.kieler.lustre.lustre.UMinus;
import de.cau.cs.kieler.lustre.lustre.Var_Decl;
import de.cau.cs.kieler.lustre.lustre.Var_Decl_List;
import de.cau.cs.kieler.lustre.lustre.Variableref;
import de.cau.cs.kieler.lustre.services.LustreGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class LustreSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private LustreGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == LustrePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case LustrePackage.AND:
				sequence_And(context, (And) semanticObject); 
				return; 
			case LustrePackage.ARROW:
				sequence_Arrow(context, (Arrow) semanticObject); 
				return; 
			case LustrePackage.BOOLEAN_CONSTANT:
				sequence_ConstantExpression(context, (BooleanConstant) semanticObject); 
				return; 
			case LustrePackage.COMPARISON:
				sequence_Comparison(context, (Comparison) semanticObject); 
				return; 
			case LustrePackage.CONST_DECL:
				sequence_Const_Decl(context, (Const_Decl) semanticObject); 
				return; 
			case LustrePackage.CURRENT:
				sequence_Primary(context, (Current) semanticObject); 
				return; 
			case LustrePackage.DECLARED_CLOCK:
				sequence_Declared_Clock(context, (Declared_Clock) semanticObject); 
				return; 
			case LustrePackage.DIV:
				sequence_MulOrDiv(context, (Div) semanticObject); 
				return; 
			case LustrePackage.ENUM_TYPE:
				sequence_Enum_Type(context, (Enum_Type) semanticObject); 
				return; 
			case LustrePackage.EQUALITY:
				sequence_Equality(context, (Equality) semanticObject); 
				return; 
			case LustrePackage.EQUATION:
				sequence_Equation(context, (Equation) semanticObject); 
				return; 
			case LustrePackage.EQUATION_LIST:
				sequence_Equation_List(context, (Equation_List) semanticObject); 
				return; 
			case LustrePackage.FN_BODY:
				sequence_FN_Body(context, (FN_Body) semanticObject); 
				return; 
			case LustrePackage.FBY:
				sequence_Fby(context, (Fby) semanticObject); 
				return; 
			case LustrePackage.FIELD:
				sequence_Field(context, (Field) semanticObject); 
				return; 
			case LustrePackage.FIELD_LIST:
				sequence_Field_List(context, (Field_List) semanticObject); 
				return; 
			case LustrePackage.FLOAT_CONSTANT:
				sequence_ConstantExpression(context, (FloatConstant) semanticObject); 
				return; 
			case LustrePackage.IDENT_LIST:
				sequence_Ident_List(context, (Ident_List) semanticObject); 
				return; 
			case LustrePackage.IDENTIFIER:
				sequence_Identifier(context, (Identifier) semanticObject); 
				return; 
			case LustrePackage.IF_THEN_ELSE:
				sequence_Expression(context, (IfThenElse) semanticObject); 
				return; 
			case LustrePackage.INT_CONSTANT:
				sequence_ConstantExpression(context, (IntConstant) semanticObject); 
				return; 
			case LustrePackage.LEFT:
				sequence_Left(context, (Left) semanticObject); 
				return; 
			case LustrePackage.LEFT_LIST:
				sequence_Left_List(context, (Left_List) semanticObject); 
				return; 
			case LustrePackage.MINUS:
				sequence_PlusOrMinus(context, (Minus) semanticObject); 
				return; 
			case LustrePackage.MUL:
				sequence_MulOrDiv(context, (Mul) semanticObject); 
				return; 
			case LustrePackage.NODE_DECL:
				sequence_Node_Decl(context, (Node_Decl) semanticObject); 
				return; 
			case LustrePackage.NODE_HEADER:
				sequence_Node_Header(context, (Node_Header) semanticObject); 
				return; 
			case LustrePackage.NOT:
				sequence_Primary(context, (Not) semanticObject); 
				return; 
			case LustrePackage.OR:
				sequence_Or(context, (Or) semanticObject); 
				return; 
			case LustrePackage.PACKAGE:
				sequence_Package(context, (de.cau.cs.kieler.lustre.lustre.Package) semanticObject); 
				return; 
			case LustrePackage.PACKAGE_BODY_CONTENT:
				sequence_Package_Body_Content(context, (Package_Body_Content) semanticObject); 
				return; 
			case LustrePackage.PACKAGE_HEADER:
				sequence_Package_Header(context, (Package_Header) semanticObject); 
				return; 
			case LustrePackage.PACKAGE_PROVIDE:
				sequence_Package_Provide(context, (Package_Provide) semanticObject); 
				return; 
			case LustrePackage.PLUS:
				sequence_PlusOrMinus(context, (Plus) semanticObject); 
				return; 
			case LustrePackage.PRE:
				sequence_Primary(context, (Pre) semanticObject); 
				return; 
			case LustrePackage.PROGRAM:
				sequence_Program(context, (Program) semanticObject); 
				return; 
			case LustrePackage.RECORD_TYPE:
				sequence_Record_Type(context, (Record_Type) semanticObject); 
				return; 
			case LustrePackage.SELECTOR:
				sequence_Selector(context, (Selector) semanticObject); 
				return; 
			case LustrePackage.TYPE:
				sequence_Type(context, (Type) semanticObject); 
				return; 
			case LustrePackage.TYPE_DECL:
				sequence_Type_Decl(context, (Type_Decl) semanticObject); 
				return; 
			case LustrePackage.UMINUS:
				sequence_Primary(context, (UMinus) semanticObject); 
				return; 
			case LustrePackage.VAR_DECL:
				sequence_Var_Decl(context, (Var_Decl) semanticObject); 
				return; 
			case LustrePackage.VAR_DECL_LIST:
				sequence_Var_Decl_List(context, (Var_Decl_List) semanticObject); 
				return; 
			case LustrePackage.VARIABLEREF:
				sequence_AtomicExpression(context, (Variableref) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Eq_or_Ast returns And
	 *     SelTrancheEnd returns And
	 *     Right_Part returns And
	 *     Assertion returns And
	 *     Expression returns And
	 *     Fby returns And
	 *     Fby.Fby_1_0 returns And
	 *     Arrow returns And
	 *     Arrow.Arrow_1_0 returns And
	 *     Or returns And
	 *     Or.Or_1_0 returns And
	 *     And returns And
	 *     And.And_1_0 returns And
	 *     Equality returns And
	 *     Equality.Equality_1_0 returns And
	 *     Comparison returns And
	 *     Comparison.Comparison_1_0 returns And
	 *     PlusOrMinus returns And
	 *     PlusOrMinus.Plus_1_0_0_0 returns And
	 *     PlusOrMinus.Minus_1_0_1_0 returns And
	 *     MulOrDiv returns And
	 *     MulOrDiv.Mul_1_0_0_0 returns And
	 *     MulOrDiv.Div_1_0_1_0 returns And
	 *     Primary returns And
	 *
	 * Constraint:
	 *     (left=And_And_1_0 right=Equality)
	 */
	protected void sequence_And(ISerializationContext context, And semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LustrePackage.Literals.AND__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LustrePackage.Literals.AND__LEFT));
			if (transientValues.isValueTransient(semanticObject, LustrePackage.Literals.AND__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LustrePackage.Literals.AND__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAndAccess().getAndLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAndAccess().getRightEqualityParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Eq_or_Ast returns Arrow
	 *     SelTrancheEnd returns Arrow
	 *     Right_Part returns Arrow
	 *     Assertion returns Arrow
	 *     Expression returns Arrow
	 *     Fby returns Arrow
	 *     Fby.Fby_1_0 returns Arrow
	 *     Arrow returns Arrow
	 *     Arrow.Arrow_1_0 returns Arrow
	 *     Or returns Arrow
	 *     Or.Or_1_0 returns Arrow
	 *     And returns Arrow
	 *     And.And_1_0 returns Arrow
	 *     Equality returns Arrow
	 *     Equality.Equality_1_0 returns Arrow
	 *     Comparison returns Arrow
	 *     Comparison.Comparison_1_0 returns Arrow
	 *     PlusOrMinus returns Arrow
	 *     PlusOrMinus.Plus_1_0_0_0 returns Arrow
	 *     PlusOrMinus.Minus_1_0_1_0 returns Arrow
	 *     MulOrDiv returns Arrow
	 *     MulOrDiv.Mul_1_0_0_0 returns Arrow
	 *     MulOrDiv.Div_1_0_1_0 returns Arrow
	 *     Primary returns Arrow
	 *
	 * Constraint:
	 *     (left=Arrow_Arrow_1_0 right=Or)
	 */
	protected void sequence_Arrow(ISerializationContext context, Arrow semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LustrePackage.Literals.ARROW__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LustrePackage.Literals.ARROW__LEFT));
			if (transientValues.isValueTransient(semanticObject, LustrePackage.Literals.ARROW__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LustrePackage.Literals.ARROW__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getArrowAccess().getArrowLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getArrowAccess().getRightOrParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Eq_or_Ast returns Variableref
	 *     SelTrancheEnd returns Variableref
	 *     Right_Part returns Variableref
	 *     Assertion returns Variableref
	 *     Expression returns Variableref
	 *     Fby returns Variableref
	 *     Fby.Fby_1_0 returns Variableref
	 *     Arrow returns Variableref
	 *     Arrow.Arrow_1_0 returns Variableref
	 *     Or returns Variableref
	 *     Or.Or_1_0 returns Variableref
	 *     And returns Variableref
	 *     And.And_1_0 returns Variableref
	 *     Equality returns Variableref
	 *     Equality.Equality_1_0 returns Variableref
	 *     Comparison returns Variableref
	 *     Comparison.Comparison_1_0 returns Variableref
	 *     PlusOrMinus returns Variableref
	 *     PlusOrMinus.Plus_1_0_0_0 returns Variableref
	 *     PlusOrMinus.Minus_1_0_1_0 returns Variableref
	 *     MulOrDiv returns Variableref
	 *     MulOrDiv.Mul_1_0_0_0 returns Variableref
	 *     MulOrDiv.Div_1_0_1_0 returns Variableref
	 *     Primary returns Variableref
	 *     AtomicExpression returns Variableref
	 *
	 * Constraint:
	 *     value=IDENT
	 */
	protected void sequence_AtomicExpression(ISerializationContext context, Variableref semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LustrePackage.Literals.VARIABLEREF__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LustrePackage.Literals.VARIABLEREF__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicExpressionAccess().getValueIDENTTerminalRuleCall_1_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Eq_or_Ast returns Comparison
	 *     SelTrancheEnd returns Comparison
	 *     Right_Part returns Comparison
	 *     Assertion returns Comparison
	 *     Expression returns Comparison
	 *     Fby returns Comparison
	 *     Fby.Fby_1_0 returns Comparison
	 *     Arrow returns Comparison
	 *     Arrow.Arrow_1_0 returns Comparison
	 *     Or returns Comparison
	 *     Or.Or_1_0 returns Comparison
	 *     And returns Comparison
	 *     And.And_1_0 returns Comparison
	 *     Equality returns Comparison
	 *     Equality.Equality_1_0 returns Comparison
	 *     Comparison returns Comparison
	 *     Comparison.Comparison_1_0 returns Comparison
	 *     PlusOrMinus returns Comparison
	 *     PlusOrMinus.Plus_1_0_0_0 returns Comparison
	 *     PlusOrMinus.Minus_1_0_1_0 returns Comparison
	 *     MulOrDiv returns Comparison
	 *     MulOrDiv.Mul_1_0_0_0 returns Comparison
	 *     MulOrDiv.Div_1_0_1_0 returns Comparison
	 *     Primary returns Comparison
	 *
	 * Constraint:
	 *     (left=Comparison_Comparison_1_0 (op='>=' | op='<=' | op='>' | op='<') right=PlusOrMinus)
	 */
	protected void sequence_Comparison(ISerializationContext context, Comparison semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Const_Decl returns Const_Decl
	 *
	 * Constraint:
	 *     ((name=IDENT type=Type) | (name=IDENT expr=Expression) | (name=IDENT type=Type expr=Expression))
	 */
	protected void sequence_Const_Decl(ISerializationContext context, Const_Decl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Eq_or_Ast returns BooleanConstant
	 *     SelTrancheEnd returns BooleanConstant
	 *     Right_Part returns BooleanConstant
	 *     Assertion returns BooleanConstant
	 *     Expression returns BooleanConstant
	 *     Fby returns BooleanConstant
	 *     Fby.Fby_1_0 returns BooleanConstant
	 *     Arrow returns BooleanConstant
	 *     Arrow.Arrow_1_0 returns BooleanConstant
	 *     Or returns BooleanConstant
	 *     Or.Or_1_0 returns BooleanConstant
	 *     And returns BooleanConstant
	 *     And.And_1_0 returns BooleanConstant
	 *     Equality returns BooleanConstant
	 *     Equality.Equality_1_0 returns BooleanConstant
	 *     Comparison returns BooleanConstant
	 *     Comparison.Comparison_1_0 returns BooleanConstant
	 *     PlusOrMinus returns BooleanConstant
	 *     PlusOrMinus.Plus_1_0_0_0 returns BooleanConstant
	 *     PlusOrMinus.Minus_1_0_1_0 returns BooleanConstant
	 *     MulOrDiv returns BooleanConstant
	 *     MulOrDiv.Mul_1_0_0_0 returns BooleanConstant
	 *     MulOrDiv.Div_1_0_1_0 returns BooleanConstant
	 *     Primary returns BooleanConstant
	 *     AtomicExpression returns BooleanConstant
	 *     ConstantExpression returns BooleanConstant
	 *
	 * Constraint:
	 *     value=BOOL
	 */
	protected void sequence_ConstantExpression(ISerializationContext context, BooleanConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LustrePackage.Literals.BOOLEAN_CONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LustrePackage.Literals.BOOLEAN_CONSTANT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConstantExpressionAccess().getValueBOOLTerminalRuleCall_0_1_0(), semanticObject.isValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Eq_or_Ast returns FloatConstant
	 *     SelTrancheEnd returns FloatConstant
	 *     Right_Part returns FloatConstant
	 *     Assertion returns FloatConstant
	 *     Expression returns FloatConstant
	 *     Fby returns FloatConstant
	 *     Fby.Fby_1_0 returns FloatConstant
	 *     Arrow returns FloatConstant
	 *     Arrow.Arrow_1_0 returns FloatConstant
	 *     Or returns FloatConstant
	 *     Or.Or_1_0 returns FloatConstant
	 *     And returns FloatConstant
	 *     And.And_1_0 returns FloatConstant
	 *     Equality returns FloatConstant
	 *     Equality.Equality_1_0 returns FloatConstant
	 *     Comparison returns FloatConstant
	 *     Comparison.Comparison_1_0 returns FloatConstant
	 *     PlusOrMinus returns FloatConstant
	 *     PlusOrMinus.Plus_1_0_0_0 returns FloatConstant
	 *     PlusOrMinus.Minus_1_0_1_0 returns FloatConstant
	 *     MulOrDiv returns FloatConstant
	 *     MulOrDiv.Mul_1_0_0_0 returns FloatConstant
	 *     MulOrDiv.Div_1_0_1_0 returns FloatConstant
	 *     Primary returns FloatConstant
	 *     AtomicExpression returns FloatConstant
	 *     ConstantExpression returns FloatConstant
	 *
	 * Constraint:
	 *     value=FLOAT
	 */
	protected void sequence_ConstantExpression(ISerializationContext context, FloatConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LustrePackage.Literals.FLOAT_CONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LustrePackage.Literals.FLOAT_CONSTANT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConstantExpressionAccess().getValueFLOATTerminalRuleCall_1_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Eq_or_Ast returns IntConstant
	 *     SelTrancheEnd returns IntConstant
	 *     Right_Part returns IntConstant
	 *     Assertion returns IntConstant
	 *     Expression returns IntConstant
	 *     Fby returns IntConstant
	 *     Fby.Fby_1_0 returns IntConstant
	 *     Arrow returns IntConstant
	 *     Arrow.Arrow_1_0 returns IntConstant
	 *     Or returns IntConstant
	 *     Or.Or_1_0 returns IntConstant
	 *     And returns IntConstant
	 *     And.And_1_0 returns IntConstant
	 *     Equality returns IntConstant
	 *     Equality.Equality_1_0 returns IntConstant
	 *     Comparison returns IntConstant
	 *     Comparison.Comparison_1_0 returns IntConstant
	 *     PlusOrMinus returns IntConstant
	 *     PlusOrMinus.Plus_1_0_0_0 returns IntConstant
	 *     PlusOrMinus.Minus_1_0_1_0 returns IntConstant
	 *     MulOrDiv returns IntConstant
	 *     MulOrDiv.Mul_1_0_0_0 returns IntConstant
	 *     MulOrDiv.Div_1_0_1_0 returns IntConstant
	 *     Primary returns IntConstant
	 *     AtomicExpression returns IntConstant
	 *     ConstantExpression returns IntConstant
	 *
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_ConstantExpression(ISerializationContext context, IntConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LustrePackage.Literals.INT_CONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LustrePackage.Literals.INT_CONSTANT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConstantExpressionAccess().getValueINTTerminalRuleCall_2_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Declared_Clock returns Declared_Clock
	 *
	 * Constraint:
	 *     name=Identifier
	 */
	protected void sequence_Declared_Clock(ISerializationContext context, Declared_Clock semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LustrePackage.Literals.DECLARED_CLOCK__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LustrePackage.Literals.DECLARED_CLOCK__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDeclared_ClockAccess().getNameIdentifierParserRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Enum_Type returns Enum_Type
	 *
	 * Constraint:
	 *     nameList=Ident_List
	 */
	protected void sequence_Enum_Type(ISerializationContext context, Enum_Type semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LustrePackage.Literals.ENUM_TYPE__NAME_LIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LustrePackage.Literals.ENUM_TYPE__NAME_LIST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEnum_TypeAccess().getNameListIdent_ListParserRuleCall_2_0(), semanticObject.getNameList());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Eq_or_Ast returns Equality
	 *     SelTrancheEnd returns Equality
	 *     Right_Part returns Equality
	 *     Assertion returns Equality
	 *     Expression returns Equality
	 *     Fby returns Equality
	 *     Fby.Fby_1_0 returns Equality
	 *     Arrow returns Equality
	 *     Arrow.Arrow_1_0 returns Equality
	 *     Or returns Equality
	 *     Or.Or_1_0 returns Equality
	 *     And returns Equality
	 *     And.And_1_0 returns Equality
	 *     Equality returns Equality
	 *     Equality.Equality_1_0 returns Equality
	 *     Comparison returns Equality
	 *     Comparison.Comparison_1_0 returns Equality
	 *     PlusOrMinus returns Equality
	 *     PlusOrMinus.Plus_1_0_0_0 returns Equality
	 *     PlusOrMinus.Minus_1_0_1_0 returns Equality
	 *     MulOrDiv returns Equality
	 *     MulOrDiv.Mul_1_0_0_0 returns Equality
	 *     MulOrDiv.Div_1_0_1_0 returns Equality
	 *     Primary returns Equality
	 *
	 * Constraint:
	 *     (left=Equality_Equality_1_0 (op='=' | op='<>') right=Comparison)
	 */
	protected void sequence_Equality(ISerializationContext context, Equality semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Eq_or_Ast returns Equation
	 *     Equation returns Equation
	 *
	 * Constraint:
	 *     (left=IDENT right=Right_Part)
	 */
	protected void sequence_Equation(ISerializationContext context, Equation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LustrePackage.Literals.EQUATION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LustrePackage.Literals.EQUATION__LEFT));
			if (transientValues.isValueTransient(semanticObject, LustrePackage.Literals.EQUATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LustrePackage.Literals.EQUATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEquationAccess().getLeftIDENTTerminalRuleCall_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getEquationAccess().getRightRight_PartParserRuleCall_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Equation_List returns Equation_List
	 *
	 * Constraint:
	 *     eq+=Eq_or_Ast*
	 */
	protected void sequence_Equation_List(ISerializationContext context, Equation_List semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Eq_or_Ast returns IfThenElse
	 *     SelTrancheEnd returns IfThenElse
	 *     Right_Part returns IfThenElse
	 *     Assertion returns IfThenElse
	 *     Expression returns IfThenElse
	 *     Fby returns IfThenElse
	 *     Fby.Fby_1_0 returns IfThenElse
	 *     Arrow returns IfThenElse
	 *     Arrow.Arrow_1_0 returns IfThenElse
	 *     Or returns IfThenElse
	 *     Or.Or_1_0 returns IfThenElse
	 *     And returns IfThenElse
	 *     And.And_1_0 returns IfThenElse
	 *     Equality returns IfThenElse
	 *     Equality.Equality_1_0 returns IfThenElse
	 *     Comparison returns IfThenElse
	 *     Comparison.Comparison_1_0 returns IfThenElse
	 *     PlusOrMinus returns IfThenElse
	 *     PlusOrMinus.Plus_1_0_0_0 returns IfThenElse
	 *     PlusOrMinus.Minus_1_0_1_0 returns IfThenElse
	 *     MulOrDiv returns IfThenElse
	 *     MulOrDiv.Mul_1_0_0_0 returns IfThenElse
	 *     MulOrDiv.Div_1_0_1_0 returns IfThenElse
	 *     Primary returns IfThenElse
	 *
	 * Constraint:
	 *     (ifexpr=Expression thenexpr=Expression elseexpr=Expression)
	 */
	protected void sequence_Expression(ISerializationContext context, IfThenElse semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LustrePackage.Literals.IF_THEN_ELSE__IFEXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LustrePackage.Literals.IF_THEN_ELSE__IFEXPR));
			if (transientValues.isValueTransient(semanticObject, LustrePackage.Literals.IF_THEN_ELSE__THENEXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LustrePackage.Literals.IF_THEN_ELSE__THENEXPR));
			if (transientValues.isValueTransient(semanticObject, LustrePackage.Literals.IF_THEN_ELSE__ELSEEXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LustrePackage.Literals.IF_THEN_ELSE__ELSEEXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionAccess().getIfexprExpressionParserRuleCall_0_2_0(), semanticObject.getIfexpr());
		feeder.accept(grammarAccess.getExpressionAccess().getThenexprExpressionParserRuleCall_0_4_0(), semanticObject.getThenexpr());
		feeder.accept(grammarAccess.getExpressionAccess().getElseexprExpressionParserRuleCall_0_6_0(), semanticObject.getElseexpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FN_Body returns FN_Body
	 *
	 * Constraint:
	 *     (decl+=Local_Var_Decl* eq+=Equation*)
	 */
	protected void sequence_FN_Body(ISerializationContext context, FN_Body semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Eq_or_Ast returns Fby
	 *     SelTrancheEnd returns Fby
	 *     Right_Part returns Fby
	 *     Assertion returns Fby
	 *     Expression returns Fby
	 *     Fby returns Fby
	 *     Fby.Fby_1_0 returns Fby
	 *     Arrow returns Fby
	 *     Arrow.Arrow_1_0 returns Fby
	 *     Or returns Fby
	 *     Or.Or_1_0 returns Fby
	 *     And returns Fby
	 *     And.And_1_0 returns Fby
	 *     Equality returns Fby
	 *     Equality.Equality_1_0 returns Fby
	 *     Comparison returns Fby
	 *     Comparison.Comparison_1_0 returns Fby
	 *     PlusOrMinus returns Fby
	 *     PlusOrMinus.Plus_1_0_0_0 returns Fby
	 *     PlusOrMinus.Minus_1_0_1_0 returns Fby
	 *     MulOrDiv returns Fby
	 *     MulOrDiv.Mul_1_0_0_0 returns Fby
	 *     MulOrDiv.Div_1_0_1_0 returns Fby
	 *     Primary returns Fby
	 *
	 * Constraint:
	 *     (left=Fby_Fby_1_0 right=Arrow)
	 */
	protected void sequence_Fby(ISerializationContext context, Fby semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LustrePackage.Literals.FBY__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LustrePackage.Literals.FBY__LEFT));
			if (transientValues.isValueTransient(semanticObject, LustrePackage.Literals.FBY__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LustrePackage.Literals.FBY__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFbyAccess().getFbyLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getFbyAccess().getRightArrowParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Field returns Field
	 *
	 * Constraint:
	 *     (name=IDENT type=Type)
	 */
	protected void sequence_Field(ISerializationContext context, Field semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LustrePackage.Literals.FIELD__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LustrePackage.Literals.FIELD__NAME));
			if (transientValues.isValueTransient(semanticObject, LustrePackage.Literals.FIELD__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LustrePackage.Literals.FIELD__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFieldAccess().getNameIDENTTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getFieldAccess().getTypeTypeParserRuleCall_2_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Field_List returns Field_List
	 *
	 * Constraint:
	 *     (fields+=Field fields+=Field*)
	 */
	protected void sequence_Field_List(ISerializationContext context, Field_List semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Ident_List returns Ident_List
	 *
	 * Constraint:
	 *     (names+=IDENT names+=IDENT*)
	 */
	protected void sequence_Ident_List(ISerializationContext context, Ident_List semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Identifier returns Identifier
	 *
	 * Constraint:
	 *     ((pkg=IDENT fromPgk?='::')? name=IDENT)
	 */
	protected void sequence_Identifier(ISerializationContext context, Identifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Left returns Left
	 *
	 * Constraint:
	 *     (name=Identifier sel=Selector?)
	 */
	protected void sequence_Left(ISerializationContext context, Left semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Left_Part returns Left_List
	 *     Left_List returns Left_List
	 *
	 * Constraint:
	 *     (id+=Left id+=Left*)
	 */
	protected void sequence_Left_List(ISerializationContext context, Left_List semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Eq_or_Ast returns Div
	 *     SelTrancheEnd returns Div
	 *     Right_Part returns Div
	 *     Assertion returns Div
	 *     Expression returns Div
	 *     Fby returns Div
	 *     Fby.Fby_1_0 returns Div
	 *     Arrow returns Div
	 *     Arrow.Arrow_1_0 returns Div
	 *     Or returns Div
	 *     Or.Or_1_0 returns Div
	 *     And returns Div
	 *     And.And_1_0 returns Div
	 *     Equality returns Div
	 *     Equality.Equality_1_0 returns Div
	 *     Comparison returns Div
	 *     Comparison.Comparison_1_0 returns Div
	 *     PlusOrMinus returns Div
	 *     PlusOrMinus.Plus_1_0_0_0 returns Div
	 *     PlusOrMinus.Minus_1_0_1_0 returns Div
	 *     MulOrDiv returns Div
	 *     MulOrDiv.Mul_1_0_0_0 returns Div
	 *     MulOrDiv.Div_1_0_1_0 returns Div
	 *     Primary returns Div
	 *
	 * Constraint:
	 *     (left=MulOrDiv_Div_1_0_1_0 right=Primary)
	 */
	protected void sequence_MulOrDiv(ISerializationContext context, Div semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LustrePackage.Literals.DIV__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LustrePackage.Literals.DIV__LEFT));
			if (transientValues.isValueTransient(semanticObject, LustrePackage.Literals.DIV__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LustrePackage.Literals.DIV__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMulOrDivAccess().getDivLeftAction_1_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMulOrDivAccess().getRightPrimaryParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Eq_or_Ast returns Mul
	 *     SelTrancheEnd returns Mul
	 *     Right_Part returns Mul
	 *     Assertion returns Mul
	 *     Expression returns Mul
	 *     Fby returns Mul
	 *     Fby.Fby_1_0 returns Mul
	 *     Arrow returns Mul
	 *     Arrow.Arrow_1_0 returns Mul
	 *     Or returns Mul
	 *     Or.Or_1_0 returns Mul
	 *     And returns Mul
	 *     And.And_1_0 returns Mul
	 *     Equality returns Mul
	 *     Equality.Equality_1_0 returns Mul
	 *     Comparison returns Mul
	 *     Comparison.Comparison_1_0 returns Mul
	 *     PlusOrMinus returns Mul
	 *     PlusOrMinus.Plus_1_0_0_0 returns Mul
	 *     PlusOrMinus.Minus_1_0_1_0 returns Mul
	 *     MulOrDiv returns Mul
	 *     MulOrDiv.Mul_1_0_0_0 returns Mul
	 *     MulOrDiv.Div_1_0_1_0 returns Mul
	 *     Primary returns Mul
	 *
	 * Constraint:
	 *     (left=MulOrDiv_Mul_1_0_0_0 right=Primary)
	 */
	protected void sequence_MulOrDiv(ISerializationContext context, Mul semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LustrePackage.Literals.MUL__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LustrePackage.Literals.MUL__LEFT));
			if (transientValues.isValueTransient(semanticObject, LustrePackage.Literals.MUL__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LustrePackage.Literals.MUL__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMulOrDivAccess().getMulLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMulOrDivAccess().getRightPrimaryParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Entity_Decl returns Node_Decl
	 *     Node_Decl returns Node_Decl
	 *
	 * Constraint:
	 *     (head=Node_Header bdy=FN_Body)
	 */
	protected void sequence_Node_Decl(ISerializationContext context, Node_Decl semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LustrePackage.Literals.NODE_DECL__HEAD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LustrePackage.Literals.NODE_DECL__HEAD));
			if (transientValues.isValueTransient(semanticObject, LustrePackage.Literals.NODE_DECL__BDY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LustrePackage.Literals.NODE_DECL__BDY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNode_DeclAccess().getHeadNode_HeaderParserRuleCall_0_0(), semanticObject.getHead());
		feeder.accept(grammarAccess.getNode_DeclAccess().getBdyFN_BodyParserRuleCall_1_0(), semanticObject.getBdy());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Node_Header returns Node_Header
	 *
	 * Constraint:
	 *     (name=IDENT param=Var_Decl_List ret=Var_Decl_List)
	 */
	protected void sequence_Node_Header(ISerializationContext context, Node_Header semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LustrePackage.Literals.NODE_HEADER__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LustrePackage.Literals.NODE_HEADER__NAME));
			if (transientValues.isValueTransient(semanticObject, LustrePackage.Literals.NODE_HEADER__PARAM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LustrePackage.Literals.NODE_HEADER__PARAM));
			if (transientValues.isValueTransient(semanticObject, LustrePackage.Literals.NODE_HEADER__RET) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LustrePackage.Literals.NODE_HEADER__RET));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNode_HeaderAccess().getNameIDENTTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getNode_HeaderAccess().getParamVar_Decl_ListParserRuleCall_3_0(), semanticObject.getParam());
		feeder.accept(grammarAccess.getNode_HeaderAccess().getRetVar_Decl_ListParserRuleCall_7_0(), semanticObject.getRet());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Eq_or_Ast returns Or
	 *     SelTrancheEnd returns Or
	 *     Right_Part returns Or
	 *     Assertion returns Or
	 *     Expression returns Or
	 *     Fby returns Or
	 *     Fby.Fby_1_0 returns Or
	 *     Arrow returns Or
	 *     Arrow.Arrow_1_0 returns Or
	 *     Or returns Or
	 *     Or.Or_1_0 returns Or
	 *     And returns Or
	 *     And.And_1_0 returns Or
	 *     Equality returns Or
	 *     Equality.Equality_1_0 returns Or
	 *     Comparison returns Or
	 *     Comparison.Comparison_1_0 returns Or
	 *     PlusOrMinus returns Or
	 *     PlusOrMinus.Plus_1_0_0_0 returns Or
	 *     PlusOrMinus.Minus_1_0_1_0 returns Or
	 *     MulOrDiv returns Or
	 *     MulOrDiv.Mul_1_0_0_0 returns Or
	 *     MulOrDiv.Div_1_0_1_0 returns Or
	 *     Primary returns Or
	 *
	 * Constraint:
	 *     (left=Or_Or_1_0 right=And)
	 */
	protected void sequence_Or(ISerializationContext context, Or semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LustrePackage.Literals.OR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LustrePackage.Literals.OR__LEFT));
			if (transientValues.isValueTransient(semanticObject, LustrePackage.Literals.OR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LustrePackage.Literals.OR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOrAccess().getOrLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getOrAccess().getRightAndParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Package_Body_Content returns Package_Body_Content
	 *
	 * Constraint:
	 *     entities+=Entity_Decl+
	 */
	protected void sequence_Package_Body_Content(ISerializationContext context, Package_Body_Content semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Package_Header returns Package_Header
	 *
	 * Constraint:
	 *     (name=IDENT uses=Ident_List? provides+=Package_Provide+)
	 */
	protected void sequence_Package_Header(ISerializationContext context, Package_Header semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Package returns Package
	 *
	 * Constraint:
	 *     (head=Package_Header body=Package_Body_Content)
	 */
	protected void sequence_Package(ISerializationContext context, de.cau.cs.kieler.lustre.lustre.Package semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LustrePackage.Literals.PACKAGE__HEAD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LustrePackage.Literals.PACKAGE__HEAD));
			if (transientValues.isValueTransient(semanticObject, LustrePackage.Literals.PACKAGE__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LustrePackage.Literals.PACKAGE__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPackageAccess().getHeadPackage_HeaderParserRuleCall_0_0(), semanticObject.getHead());
		feeder.accept(grammarAccess.getPackageAccess().getBodyPackage_Body_ContentParserRuleCall_1_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Package_Provide returns Package_Provide
	 *
	 * Constraint:
	 *     (name=[Node_Header|IDENT] param=Var_Decl_List ret=Var_Decl_List)
	 */
	protected void sequence_Package_Provide(ISerializationContext context, Package_Provide semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LustrePackage.Literals.PACKAGE_PROVIDE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LustrePackage.Literals.PACKAGE_PROVIDE__NAME));
			if (transientValues.isValueTransient(semanticObject, LustrePackage.Literals.PACKAGE_PROVIDE__PARAM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LustrePackage.Literals.PACKAGE_PROVIDE__PARAM));
			if (transientValues.isValueTransient(semanticObject, LustrePackage.Literals.PACKAGE_PROVIDE__RET) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LustrePackage.Literals.PACKAGE_PROVIDE__RET));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPackage_ProvideAccess().getNameNode_HeaderIDENTTerminalRuleCall_1_0_1(), semanticObject.getName());
		feeder.accept(grammarAccess.getPackage_ProvideAccess().getParamVar_Decl_ListParserRuleCall_3_0(), semanticObject.getParam());
		feeder.accept(grammarAccess.getPackage_ProvideAccess().getRetVar_Decl_ListParserRuleCall_7_0(), semanticObject.getRet());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Eq_or_Ast returns Minus
	 *     SelTrancheEnd returns Minus
	 *     Right_Part returns Minus
	 *     Assertion returns Minus
	 *     Expression returns Minus
	 *     Fby returns Minus
	 *     Fby.Fby_1_0 returns Minus
	 *     Arrow returns Minus
	 *     Arrow.Arrow_1_0 returns Minus
	 *     Or returns Minus
	 *     Or.Or_1_0 returns Minus
	 *     And returns Minus
	 *     And.And_1_0 returns Minus
	 *     Equality returns Minus
	 *     Equality.Equality_1_0 returns Minus
	 *     Comparison returns Minus
	 *     Comparison.Comparison_1_0 returns Minus
	 *     PlusOrMinus returns Minus
	 *     PlusOrMinus.Plus_1_0_0_0 returns Minus
	 *     PlusOrMinus.Minus_1_0_1_0 returns Minus
	 *     MulOrDiv returns Minus
	 *     MulOrDiv.Mul_1_0_0_0 returns Minus
	 *     MulOrDiv.Div_1_0_1_0 returns Minus
	 *     Primary returns Minus
	 *
	 * Constraint:
	 *     (left=PlusOrMinus_Minus_1_0_1_0 right=MulOrDiv)
	 */
	protected void sequence_PlusOrMinus(ISerializationContext context, Minus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LustrePackage.Literals.MINUS__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LustrePackage.Literals.MINUS__LEFT));
			if (transientValues.isValueTransient(semanticObject, LustrePackage.Literals.MINUS__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LustrePackage.Literals.MINUS__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPlusOrMinusAccess().getMinusLeftAction_1_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getPlusOrMinusAccess().getRightMulOrDivParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Eq_or_Ast returns Plus
	 *     SelTrancheEnd returns Plus
	 *     Right_Part returns Plus
	 *     Assertion returns Plus
	 *     Expression returns Plus
	 *     Fby returns Plus
	 *     Fby.Fby_1_0 returns Plus
	 *     Arrow returns Plus
	 *     Arrow.Arrow_1_0 returns Plus
	 *     Or returns Plus
	 *     Or.Or_1_0 returns Plus
	 *     And returns Plus
	 *     And.And_1_0 returns Plus
	 *     Equality returns Plus
	 *     Equality.Equality_1_0 returns Plus
	 *     Comparison returns Plus
	 *     Comparison.Comparison_1_0 returns Plus
	 *     PlusOrMinus returns Plus
	 *     PlusOrMinus.Plus_1_0_0_0 returns Plus
	 *     PlusOrMinus.Minus_1_0_1_0 returns Plus
	 *     MulOrDiv returns Plus
	 *     MulOrDiv.Mul_1_0_0_0 returns Plus
	 *     MulOrDiv.Div_1_0_1_0 returns Plus
	 *     Primary returns Plus
	 *
	 * Constraint:
	 *     (left=PlusOrMinus_Plus_1_0_0_0 right=MulOrDiv)
	 */
	protected void sequence_PlusOrMinus(ISerializationContext context, Plus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LustrePackage.Literals.PLUS__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LustrePackage.Literals.PLUS__LEFT));
			if (transientValues.isValueTransient(semanticObject, LustrePackage.Literals.PLUS__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LustrePackage.Literals.PLUS__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPlusOrMinusAccess().getPlusLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getPlusOrMinusAccess().getRightMulOrDivParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Eq_or_Ast returns Current
	 *     SelTrancheEnd returns Current
	 *     Right_Part returns Current
	 *     Assertion returns Current
	 *     Expression returns Current
	 *     Fby returns Current
	 *     Fby.Fby_1_0 returns Current
	 *     Arrow returns Current
	 *     Arrow.Arrow_1_0 returns Current
	 *     Or returns Current
	 *     Or.Or_1_0 returns Current
	 *     And returns Current
	 *     And.And_1_0 returns Current
	 *     Equality returns Current
	 *     Equality.Equality_1_0 returns Current
	 *     Comparison returns Current
	 *     Comparison.Comparison_1_0 returns Current
	 *     PlusOrMinus returns Current
	 *     PlusOrMinus.Plus_1_0_0_0 returns Current
	 *     PlusOrMinus.Minus_1_0_1_0 returns Current
	 *     MulOrDiv returns Current
	 *     MulOrDiv.Mul_1_0_0_0 returns Current
	 *     MulOrDiv.Div_1_0_1_0 returns Current
	 *     Primary returns Current
	 *
	 * Constraint:
	 *     expression=Primary
	 */
	protected void sequence_Primary(ISerializationContext context, Current semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LustrePackage.Literals.CURRENT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LustrePackage.Literals.CURRENT__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimaryAccess().getExpressionPrimaryParserRuleCall_4_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Eq_or_Ast returns Not
	 *     SelTrancheEnd returns Not
	 *     Right_Part returns Not
	 *     Assertion returns Not
	 *     Expression returns Not
	 *     Fby returns Not
	 *     Fby.Fby_1_0 returns Not
	 *     Arrow returns Not
	 *     Arrow.Arrow_1_0 returns Not
	 *     Or returns Not
	 *     Or.Or_1_0 returns Not
	 *     And returns Not
	 *     And.And_1_0 returns Not
	 *     Equality returns Not
	 *     Equality.Equality_1_0 returns Not
	 *     Comparison returns Not
	 *     Comparison.Comparison_1_0 returns Not
	 *     PlusOrMinus returns Not
	 *     PlusOrMinus.Plus_1_0_0_0 returns Not
	 *     PlusOrMinus.Minus_1_0_1_0 returns Not
	 *     MulOrDiv returns Not
	 *     MulOrDiv.Mul_1_0_0_0 returns Not
	 *     MulOrDiv.Div_1_0_1_0 returns Not
	 *     Primary returns Not
	 *
	 * Constraint:
	 *     expression=Primary
	 */
	protected void sequence_Primary(ISerializationContext context, Not semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LustrePackage.Literals.NOT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LustrePackage.Literals.NOT__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimaryAccess().getExpressionPrimaryParserRuleCall_1_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Eq_or_Ast returns Pre
	 *     SelTrancheEnd returns Pre
	 *     Right_Part returns Pre
	 *     Assertion returns Pre
	 *     Expression returns Pre
	 *     Fby returns Pre
	 *     Fby.Fby_1_0 returns Pre
	 *     Arrow returns Pre
	 *     Arrow.Arrow_1_0 returns Pre
	 *     Or returns Pre
	 *     Or.Or_1_0 returns Pre
	 *     And returns Pre
	 *     And.And_1_0 returns Pre
	 *     Equality returns Pre
	 *     Equality.Equality_1_0 returns Pre
	 *     Comparison returns Pre
	 *     Comparison.Comparison_1_0 returns Pre
	 *     PlusOrMinus returns Pre
	 *     PlusOrMinus.Plus_1_0_0_0 returns Pre
	 *     PlusOrMinus.Minus_1_0_1_0 returns Pre
	 *     MulOrDiv returns Pre
	 *     MulOrDiv.Mul_1_0_0_0 returns Pre
	 *     MulOrDiv.Div_1_0_1_0 returns Pre
	 *     Primary returns Pre
	 *
	 * Constraint:
	 *     expression=Primary
	 */
	protected void sequence_Primary(ISerializationContext context, Pre semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LustrePackage.Literals.PRE__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LustrePackage.Literals.PRE__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimaryAccess().getExpressionPrimaryParserRuleCall_3_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Eq_or_Ast returns UMinus
	 *     SelTrancheEnd returns UMinus
	 *     Right_Part returns UMinus
	 *     Assertion returns UMinus
	 *     Expression returns UMinus
	 *     Fby returns UMinus
	 *     Fby.Fby_1_0 returns UMinus
	 *     Arrow returns UMinus
	 *     Arrow.Arrow_1_0 returns UMinus
	 *     Or returns UMinus
	 *     Or.Or_1_0 returns UMinus
	 *     And returns UMinus
	 *     And.And_1_0 returns UMinus
	 *     Equality returns UMinus
	 *     Equality.Equality_1_0 returns UMinus
	 *     Comparison returns UMinus
	 *     Comparison.Comparison_1_0 returns UMinus
	 *     PlusOrMinus returns UMinus
	 *     PlusOrMinus.Plus_1_0_0_0 returns UMinus
	 *     PlusOrMinus.Minus_1_0_1_0 returns UMinus
	 *     MulOrDiv returns UMinus
	 *     MulOrDiv.Mul_1_0_0_0 returns UMinus
	 *     MulOrDiv.Div_1_0_1_0 returns UMinus
	 *     Primary returns UMinus
	 *
	 * Constraint:
	 *     expression=Primary
	 */
	protected void sequence_Primary(ISerializationContext context, UMinus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LustrePackage.Literals.UMINUS__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LustrePackage.Literals.UMINUS__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimaryAccess().getExpressionPrimaryParserRuleCall_2_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Program returns Program
	 *
	 * Constraint:
	 *     pkg=Package
	 */
	protected void sequence_Program(ISerializationContext context, Program semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LustrePackage.Literals.PROGRAM__PKG) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LustrePackage.Literals.PROGRAM__PKG));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getProgramAccess().getPkgPackageParserRuleCall_0(), semanticObject.getPkg());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Record_Type returns Record_Type
	 *
	 * Constraint:
	 *     fields=Field_List
	 */
	protected void sequence_Record_Type(ISerializationContext context, Record_Type semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LustrePackage.Literals.RECORD_TYPE__FIELDS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LustrePackage.Literals.RECORD_TYPE__FIELDS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRecord_TypeAccess().getFieldsField_ListParserRuleCall_2_0(), semanticObject.getFields());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Selector returns Selector
	 *
	 * Constraint:
	 *     (name=IDENT | (begin=Expression end=SelTrancheEnd?))
	 */
	protected void sequence_Selector(ISerializationContext context, Selector semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Type_Decl returns Type_Decl
	 *
	 * Constraint:
	 *     (name=IDENT | (name=IDENT type=Type))
	 */
	protected void sequence_Type_Decl(ISerializationContext context, Type_Decl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Type returns Type
	 *
	 * Constraint:
	 *     name=IDENT
	 */
	protected void sequence_Type(ISerializationContext context, Type semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LustrePackage.Literals.TYPE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LustrePackage.Literals.TYPE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTypeAccess().getNameIDENTTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Var_Decl_List returns Var_Decl_List
	 *
	 * Constraint:
	 *     (varList+=Var_Decl varList+=Var_Decl*)
	 */
	protected void sequence_Var_Decl_List(ISerializationContext context, Var_Decl_List semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Var_Decl returns Var_Decl
	 *     Local_Var_Decl returns Var_Decl
	 *
	 * Constraint:
	 *     (name=IDENT type=Type clk=Declared_Clock?)
	 */
	protected void sequence_Var_Decl(ISerializationContext context, Var_Decl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
