/*
 * generated by Xtext 2.10.0
 */
package de.cau.cs.kieler.lustre.serializer;

import com.google.inject.Inject;
import de.cau.cs.kieler.lustre.lustre.AState;
import de.cau.cs.kieler.lustre.lustre.ATransition;
import de.cau.cs.kieler.lustre.lustre.And;
import de.cau.cs.kieler.lustre.lustre.Array_Type;
import de.cau.cs.kieler.lustre.lustre.Arrow;
import de.cau.cs.kieler.lustre.lustre.Automaton;
import de.cau.cs.kieler.lustre.lustre.BoolConstant;
import de.cau.cs.kieler.lustre.lustre.Comparison;
import de.cau.cs.kieler.lustre.lustre.Constant_Declaration;
import de.cau.cs.kieler.lustre.lustre.Current;
import de.cau.cs.kieler.lustre.lustre.Div;
import de.cau.cs.kieler.lustre.lustre.Equality;
import de.cau.cs.kieler.lustre.lustre.Equation;
import de.cau.cs.kieler.lustre.lustre.Fby;
import de.cau.cs.kieler.lustre.lustre.Field;
import de.cau.cs.kieler.lustre.lustre.FloatConstant;
import de.cau.cs.kieler.lustre.lustre.IfThenElse;
import de.cau.cs.kieler.lustre.lustre.IntConstant;
import de.cau.cs.kieler.lustre.lustre.Left;
import de.cau.cs.kieler.lustre.lustre.Left_List;
import de.cau.cs.kieler.lustre.lustre.LustrePackage;
import de.cau.cs.kieler.lustre.lustre.Minus;
import de.cau.cs.kieler.lustre.lustre.Mod;
import de.cau.cs.kieler.lustre.lustre.Mul;
import de.cau.cs.kieler.lustre.lustre.Node_Declaration;
import de.cau.cs.kieler.lustre.lustre.Not;
import de.cau.cs.kieler.lustre.lustre.Or;
import de.cau.cs.kieler.lustre.lustre.Package_Declaration;
import de.cau.cs.kieler.lustre.lustre.Package_Provided;
import de.cau.cs.kieler.lustre.lustre.Package_Provided_IO;
import de.cau.cs.kieler.lustre.lustre.Plus;
import de.cau.cs.kieler.lustre.lustre.Pre;
import de.cau.cs.kieler.lustre.lustre.Program;
import de.cau.cs.kieler.lustre.lustre.Record_Type;
import de.cau.cs.kieler.lustre.lustre.Selector;
import de.cau.cs.kieler.lustre.lustre.Type;
import de.cau.cs.kieler.lustre.lustre.Type_Declaration;
import de.cau.cs.kieler.lustre.lustre.UMinus;
import de.cau.cs.kieler.lustre.lustre.VariableReference;
import de.cau.cs.kieler.lustre.lustre.Variable_Declaration;
import de.cau.cs.kieler.lustre.services.LustreGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class LustreSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private LustreGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == LustrePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case LustrePackage.ASTATE:
				sequence_AState(context, (AState) semanticObject); 
				return; 
			case LustrePackage.ATRANSITION:
				sequence_ATransition(context, (ATransition) semanticObject); 
				return; 
			case LustrePackage.AND:
				sequence_And(context, (And) semanticObject); 
				return; 
			case LustrePackage.ARRAY_TYPE:
				sequence_Array_Type(context, (Array_Type) semanticObject); 
				return; 
			case LustrePackage.ARROW:
				sequence_Arrow(context, (Arrow) semanticObject); 
				return; 
			case LustrePackage.AUTOMATON:
				sequence_Automaton(context, (Automaton) semanticObject); 
				return; 
			case LustrePackage.BOOL_CONSTANT:
				sequence_ConstantExpression(context, (BoolConstant) semanticObject); 
				return; 
			case LustrePackage.COMPARISON:
				sequence_Comparison(context, (Comparison) semanticObject); 
				return; 
			case LustrePackage.CONSTANT_DECLARATION:
				if (rule == grammarAccess.getEntity_DeclarationRule()
						|| rule == grammarAccess.getConstant_DeclarationRule()) {
					sequence_Constant_Declaration(context, (Constant_Declaration) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getLocal_Constant_DeclarationRule()) {
					sequence_Local_Constant_Declaration(context, (Constant_Declaration) semanticObject); 
					return; 
				}
				else break;
			case LustrePackage.CURRENT:
				sequence_Primary(context, (Current) semanticObject); 
				return; 
			case LustrePackage.DIV:
				sequence_MulOrDiv(context, (Div) semanticObject); 
				return; 
			case LustrePackage.EQUALITY:
				sequence_Equality(context, (Equality) semanticObject); 
				return; 
			case LustrePackage.EQUATION:
				sequence_Equation(context, (Equation) semanticObject); 
				return; 
			case LustrePackage.FBY:
				sequence_Fby(context, (Fby) semanticObject); 
				return; 
			case LustrePackage.FIELD:
				sequence_Field(context, (Field) semanticObject); 
				return; 
			case LustrePackage.FLOAT_CONSTANT:
				sequence_ConstantExpression(context, (FloatConstant) semanticObject); 
				return; 
			case LustrePackage.IF_THEN_ELSE:
				sequence_Expression(context, (IfThenElse) semanticObject); 
				return; 
			case LustrePackage.INT_CONSTANT:
				sequence_ConstantExpression(context, (IntConstant) semanticObject); 
				return; 
			case LustrePackage.LEFT:
				sequence_Left(context, (Left) semanticObject); 
				return; 
			case LustrePackage.LEFT_LIST:
				sequence_Left_List(context, (Left_List) semanticObject); 
				return; 
			case LustrePackage.MINUS:
				sequence_PlusOrMinus(context, (Minus) semanticObject); 
				return; 
			case LustrePackage.MOD:
				sequence_Mod(context, (Mod) semanticObject); 
				return; 
			case LustrePackage.MUL:
				sequence_MulOrDiv(context, (Mul) semanticObject); 
				return; 
			case LustrePackage.NODE_DECLARATION:
				sequence_Node_Declaration(context, (Node_Declaration) semanticObject); 
				return; 
			case LustrePackage.NOT:
				sequence_Primary(context, (Not) semanticObject); 
				return; 
			case LustrePackage.OR:
				sequence_Or(context, (Or) semanticObject); 
				return; 
			case LustrePackage.PACKAGE_DECLARATION:
				sequence_Package_Declaration(context, (Package_Declaration) semanticObject); 
				return; 
			case LustrePackage.PACKAGE_PROVIDED:
				sequence_Package_Provided(context, (Package_Provided) semanticObject); 
				return; 
			case LustrePackage.PACKAGE_PROVIDED_IO:
				sequence_Package_Provided_IO(context, (Package_Provided_IO) semanticObject); 
				return; 
			case LustrePackage.PLUS:
				sequence_PlusOrMinus(context, (Plus) semanticObject); 
				return; 
			case LustrePackage.PRE:
				sequence_Primary(context, (Pre) semanticObject); 
				return; 
			case LustrePackage.PROGRAM:
				sequence_Program(context, (Program) semanticObject); 
				return; 
			case LustrePackage.RECORD_TYPE:
				sequence_Record_Type(context, (Record_Type) semanticObject); 
				return; 
			case LustrePackage.SELECTOR:
				sequence_Selector(context, (Selector) semanticObject); 
				return; 
			case LustrePackage.TYPE:
				sequence_Type(context, (Type) semanticObject); 
				return; 
			case LustrePackage.TYPE_DECLARATION:
				sequence_Type_Declaration(context, (Type_Declaration) semanticObject); 
				return; 
			case LustrePackage.UMINUS:
				sequence_Primary(context, (UMinus) semanticObject); 
				return; 
			case LustrePackage.VARIABLE_REFERENCE:
				sequence_VariableReference(context, (VariableReference) semanticObject); 
				return; 
			case LustrePackage.VARIABLE_DECLARATION:
				sequence_Variable_Declaration(context, (Variable_Declaration) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     AState returns AState
	 *
	 * Constraint:
	 *     (name=IDENT (equations+=Equation | assertions+=Assertion | automatons+=Automaton)* transitions+=ATransition+)
	 */
	protected void sequence_AState(ISerializationContext context, AState semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ATransition returns ATransition
	 *
	 * Constraint:
	 *     (strong?='unless'? condition=Expression history?='continue'? nextState=[AState|IDENT])
	 */
	protected void sequence_ATransition(ISerializationContext context, ATransition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Assertion returns And
	 *     SelTrancheEnd returns And
	 *     Right_Part returns And
	 *     Expression returns And
	 *     Fby returns And
	 *     Fby.Fby_1_0 returns And
	 *     Arrow returns And
	 *     Arrow.Arrow_1_0 returns And
	 *     Or returns And
	 *     Or.Or_1_0 returns And
	 *     And returns And
	 *     And.And_1_0 returns And
	 *     Equality returns And
	 *     Equality.Equality_1_0 returns And
	 *     Comparison returns And
	 *     Comparison.Comparison_1_0 returns And
	 *     Mod returns And
	 *     Mod.Mod_1_0 returns And
	 *     PlusOrMinus returns And
	 *     PlusOrMinus.Plus_1_0_0_0 returns And
	 *     PlusOrMinus.Minus_1_0_1_0 returns And
	 *     MulOrDiv returns And
	 *     MulOrDiv.Mul_1_0_0_0 returns And
	 *     MulOrDiv.Div_1_0_1_0 returns And
	 *     Primary returns And
	 *
	 * Constraint:
	 *     (subExpressions+=And_And_1_0 subExpressions+=Equality+)
	 */
	protected void sequence_And(ISerializationContext context, And semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Array_Type returns Array_Type
	 *
	 * Constraint:
	 *     (type=[Type_Declaration|IDENT] length=INT)
	 */
	protected void sequence_Array_Type(ISerializationContext context, Array_Type semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LustrePackage.Literals.ARRAY_TYPE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LustrePackage.Literals.ARRAY_TYPE__TYPE));
			if (transientValues.isValueTransient(semanticObject, LustrePackage.Literals.ARRAY_TYPE__LENGTH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LustrePackage.Literals.ARRAY_TYPE__LENGTH));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getArray_TypeAccess().getTypeType_DeclarationIDENTTerminalRuleCall_0_0_1(), semanticObject.getType());
		feeder.accept(grammarAccess.getArray_TypeAccess().getLengthINTTerminalRuleCall_2_0(), semanticObject.getLength());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Assertion returns Arrow
	 *     SelTrancheEnd returns Arrow
	 *     Right_Part returns Arrow
	 *     Expression returns Arrow
	 *     Fby returns Arrow
	 *     Fby.Fby_1_0 returns Arrow
	 *     Arrow returns Arrow
	 *     Arrow.Arrow_1_0 returns Arrow
	 *     Or returns Arrow
	 *     Or.Or_1_0 returns Arrow
	 *     And returns Arrow
	 *     And.And_1_0 returns Arrow
	 *     Equality returns Arrow
	 *     Equality.Equality_1_0 returns Arrow
	 *     Comparison returns Arrow
	 *     Comparison.Comparison_1_0 returns Arrow
	 *     Mod returns Arrow
	 *     Mod.Mod_1_0 returns Arrow
	 *     PlusOrMinus returns Arrow
	 *     PlusOrMinus.Plus_1_0_0_0 returns Arrow
	 *     PlusOrMinus.Minus_1_0_1_0 returns Arrow
	 *     MulOrDiv returns Arrow
	 *     MulOrDiv.Mul_1_0_0_0 returns Arrow
	 *     MulOrDiv.Div_1_0_1_0 returns Arrow
	 *     Primary returns Arrow
	 *
	 * Constraint:
	 *     (subExpressions+=Arrow_Arrow_1_0 subExpressions+=Or+)
	 */
	protected void sequence_Arrow(ISerializationContext context, Arrow semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Automaton returns Automaton
	 *
	 * Constraint:
	 *     (states+=AState states+=AState*)
	 */
	protected void sequence_Automaton(ISerializationContext context, Automaton semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Assertion returns Comparison
	 *     SelTrancheEnd returns Comparison
	 *     Right_Part returns Comparison
	 *     Expression returns Comparison
	 *     Fby returns Comparison
	 *     Fby.Fby_1_0 returns Comparison
	 *     Arrow returns Comparison
	 *     Arrow.Arrow_1_0 returns Comparison
	 *     Or returns Comparison
	 *     Or.Or_1_0 returns Comparison
	 *     And returns Comparison
	 *     And.And_1_0 returns Comparison
	 *     Equality returns Comparison
	 *     Equality.Equality_1_0 returns Comparison
	 *     Comparison returns Comparison
	 *     Comparison.Comparison_1_0 returns Comparison
	 *     Mod returns Comparison
	 *     Mod.Mod_1_0 returns Comparison
	 *     PlusOrMinus returns Comparison
	 *     PlusOrMinus.Plus_1_0_0_0 returns Comparison
	 *     PlusOrMinus.Minus_1_0_1_0 returns Comparison
	 *     MulOrDiv returns Comparison
	 *     MulOrDiv.Mul_1_0_0_0 returns Comparison
	 *     MulOrDiv.Div_1_0_1_0 returns Comparison
	 *     Primary returns Comparison
	 *
	 * Constraint:
	 *     (left=Comparison_Comparison_1_0 (op='>=' | op='<=' | op='>' | op='<') right=Mod)
	 */
	protected void sequence_Comparison(ISerializationContext context, Comparison semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Assertion returns BoolConstant
	 *     SelTrancheEnd returns BoolConstant
	 *     Right_Part returns BoolConstant
	 *     Expression returns BoolConstant
	 *     Fby returns BoolConstant
	 *     Fby.Fby_1_0 returns BoolConstant
	 *     Arrow returns BoolConstant
	 *     Arrow.Arrow_1_0 returns BoolConstant
	 *     Or returns BoolConstant
	 *     Or.Or_1_0 returns BoolConstant
	 *     And returns BoolConstant
	 *     And.And_1_0 returns BoolConstant
	 *     Equality returns BoolConstant
	 *     Equality.Equality_1_0 returns BoolConstant
	 *     Comparison returns BoolConstant
	 *     Comparison.Comparison_1_0 returns BoolConstant
	 *     Mod returns BoolConstant
	 *     Mod.Mod_1_0 returns BoolConstant
	 *     PlusOrMinus returns BoolConstant
	 *     PlusOrMinus.Plus_1_0_0_0 returns BoolConstant
	 *     PlusOrMinus.Minus_1_0_1_0 returns BoolConstant
	 *     MulOrDiv returns BoolConstant
	 *     MulOrDiv.Mul_1_0_0_0 returns BoolConstant
	 *     MulOrDiv.Div_1_0_1_0 returns BoolConstant
	 *     Primary returns BoolConstant
	 *     AtomicExpression returns BoolConstant
	 *     ConstantExpression returns BoolConstant
	 *
	 * Constraint:
	 *     value=BOOL
	 */
	protected void sequence_ConstantExpression(ISerializationContext context, BoolConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LustrePackage.Literals.BOOL_CONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LustrePackage.Literals.BOOL_CONSTANT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConstantExpressionAccess().getValueBOOLTerminalRuleCall_0_1_0(), semanticObject.isValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Assertion returns FloatConstant
	 *     SelTrancheEnd returns FloatConstant
	 *     Right_Part returns FloatConstant
	 *     Expression returns FloatConstant
	 *     Fby returns FloatConstant
	 *     Fby.Fby_1_0 returns FloatConstant
	 *     Arrow returns FloatConstant
	 *     Arrow.Arrow_1_0 returns FloatConstant
	 *     Or returns FloatConstant
	 *     Or.Or_1_0 returns FloatConstant
	 *     And returns FloatConstant
	 *     And.And_1_0 returns FloatConstant
	 *     Equality returns FloatConstant
	 *     Equality.Equality_1_0 returns FloatConstant
	 *     Comparison returns FloatConstant
	 *     Comparison.Comparison_1_0 returns FloatConstant
	 *     Mod returns FloatConstant
	 *     Mod.Mod_1_0 returns FloatConstant
	 *     PlusOrMinus returns FloatConstant
	 *     PlusOrMinus.Plus_1_0_0_0 returns FloatConstant
	 *     PlusOrMinus.Minus_1_0_1_0 returns FloatConstant
	 *     MulOrDiv returns FloatConstant
	 *     MulOrDiv.Mul_1_0_0_0 returns FloatConstant
	 *     MulOrDiv.Div_1_0_1_0 returns FloatConstant
	 *     Primary returns FloatConstant
	 *     AtomicExpression returns FloatConstant
	 *     ConstantExpression returns FloatConstant
	 *
	 * Constraint:
	 *     value=FLOAT
	 */
	protected void sequence_ConstantExpression(ISerializationContext context, FloatConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LustrePackage.Literals.FLOAT_CONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LustrePackage.Literals.FLOAT_CONSTANT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConstantExpressionAccess().getValueFLOATTerminalRuleCall_1_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Assertion returns IntConstant
	 *     SelTrancheEnd returns IntConstant
	 *     Right_Part returns IntConstant
	 *     Expression returns IntConstant
	 *     Fby returns IntConstant
	 *     Fby.Fby_1_0 returns IntConstant
	 *     Arrow returns IntConstant
	 *     Arrow.Arrow_1_0 returns IntConstant
	 *     Or returns IntConstant
	 *     Or.Or_1_0 returns IntConstant
	 *     And returns IntConstant
	 *     And.And_1_0 returns IntConstant
	 *     Equality returns IntConstant
	 *     Equality.Equality_1_0 returns IntConstant
	 *     Comparison returns IntConstant
	 *     Comparison.Comparison_1_0 returns IntConstant
	 *     Mod returns IntConstant
	 *     Mod.Mod_1_0 returns IntConstant
	 *     PlusOrMinus returns IntConstant
	 *     PlusOrMinus.Plus_1_0_0_0 returns IntConstant
	 *     PlusOrMinus.Minus_1_0_1_0 returns IntConstant
	 *     MulOrDiv returns IntConstant
	 *     MulOrDiv.Mul_1_0_0_0 returns IntConstant
	 *     MulOrDiv.Div_1_0_1_0 returns IntConstant
	 *     Primary returns IntConstant
	 *     AtomicExpression returns IntConstant
	 *     ConstantExpression returns IntConstant
	 *
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_ConstantExpression(ISerializationContext context, IntConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LustrePackage.Literals.INT_CONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LustrePackage.Literals.INT_CONSTANT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConstantExpressionAccess().getValueINTTerminalRuleCall_2_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Entity_Declaration returns Constant_Declaration
	 *     Constant_Declaration returns Constant_Declaration
	 *
	 * Constraint:
	 *     ((name=IDENT type=Type) | (name=IDENT expr=ConstantExpression) | (name=IDENT type=Type expr=ConstantExpression))
	 */
	protected void sequence_Constant_Declaration(ISerializationContext context, Constant_Declaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Assertion returns Equality
	 *     SelTrancheEnd returns Equality
	 *     Right_Part returns Equality
	 *     Expression returns Equality
	 *     Fby returns Equality
	 *     Fby.Fby_1_0 returns Equality
	 *     Arrow returns Equality
	 *     Arrow.Arrow_1_0 returns Equality
	 *     Or returns Equality
	 *     Or.Or_1_0 returns Equality
	 *     And returns Equality
	 *     And.And_1_0 returns Equality
	 *     Equality returns Equality
	 *     Equality.Equality_1_0 returns Equality
	 *     Comparison returns Equality
	 *     Comparison.Comparison_1_0 returns Equality
	 *     Mod returns Equality
	 *     Mod.Mod_1_0 returns Equality
	 *     PlusOrMinus returns Equality
	 *     PlusOrMinus.Plus_1_0_0_0 returns Equality
	 *     PlusOrMinus.Minus_1_0_1_0 returns Equality
	 *     MulOrDiv returns Equality
	 *     MulOrDiv.Mul_1_0_0_0 returns Equality
	 *     MulOrDiv.Div_1_0_1_0 returns Equality
	 *     Primary returns Equality
	 *
	 * Constraint:
	 *     (left=Equality_Equality_1_0 (op='=' | op='<>') right=Comparison)
	 */
	protected void sequence_Equality(ISerializationContext context, Equality semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Equation returns Equation
	 *
	 * Constraint:
	 *     (left=[Variable_Declaration|IDENT] right=Right_Part)
	 */
	protected void sequence_Equation(ISerializationContext context, Equation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LustrePackage.Literals.EQUATION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LustrePackage.Literals.EQUATION__LEFT));
			if (transientValues.isValueTransient(semanticObject, LustrePackage.Literals.EQUATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LustrePackage.Literals.EQUATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEquationAccess().getLeftVariable_DeclarationIDENTTerminalRuleCall_0_0_1(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getEquationAccess().getRightRight_PartParserRuleCall_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Assertion returns IfThenElse
	 *     SelTrancheEnd returns IfThenElse
	 *     Right_Part returns IfThenElse
	 *     Expression returns IfThenElse
	 *     Fby returns IfThenElse
	 *     Fby.Fby_1_0 returns IfThenElse
	 *     Arrow returns IfThenElse
	 *     Arrow.Arrow_1_0 returns IfThenElse
	 *     Or returns IfThenElse
	 *     Or.Or_1_0 returns IfThenElse
	 *     And returns IfThenElse
	 *     And.And_1_0 returns IfThenElse
	 *     Equality returns IfThenElse
	 *     Equality.Equality_1_0 returns IfThenElse
	 *     Comparison returns IfThenElse
	 *     Comparison.Comparison_1_0 returns IfThenElse
	 *     Mod returns IfThenElse
	 *     Mod.Mod_1_0 returns IfThenElse
	 *     PlusOrMinus returns IfThenElse
	 *     PlusOrMinus.Plus_1_0_0_0 returns IfThenElse
	 *     PlusOrMinus.Minus_1_0_1_0 returns IfThenElse
	 *     MulOrDiv returns IfThenElse
	 *     MulOrDiv.Mul_1_0_0_0 returns IfThenElse
	 *     MulOrDiv.Div_1_0_1_0 returns IfThenElse
	 *     Primary returns IfThenElse
	 *
	 * Constraint:
	 *     (ifexpr=Expression thenexpr=Expression elseexpr=Expression)
	 */
	protected void sequence_Expression(ISerializationContext context, IfThenElse semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LustrePackage.Literals.IF_THEN_ELSE__IFEXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LustrePackage.Literals.IF_THEN_ELSE__IFEXPR));
			if (transientValues.isValueTransient(semanticObject, LustrePackage.Literals.IF_THEN_ELSE__THENEXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LustrePackage.Literals.IF_THEN_ELSE__THENEXPR));
			if (transientValues.isValueTransient(semanticObject, LustrePackage.Literals.IF_THEN_ELSE__ELSEEXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LustrePackage.Literals.IF_THEN_ELSE__ELSEEXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionAccess().getIfexprExpressionParserRuleCall_0_2_0(), semanticObject.getIfexpr());
		feeder.accept(grammarAccess.getExpressionAccess().getThenexprExpressionParserRuleCall_0_4_0(), semanticObject.getThenexpr());
		feeder.accept(grammarAccess.getExpressionAccess().getElseexprExpressionParserRuleCall_0_6_0(), semanticObject.getElseexpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Assertion returns Fby
	 *     SelTrancheEnd returns Fby
	 *     Right_Part returns Fby
	 *     Expression returns Fby
	 *     Fby returns Fby
	 *     Fby.Fby_1_0 returns Fby
	 *     Arrow returns Fby
	 *     Arrow.Arrow_1_0 returns Fby
	 *     Or returns Fby
	 *     Or.Or_1_0 returns Fby
	 *     And returns Fby
	 *     And.And_1_0 returns Fby
	 *     Equality returns Fby
	 *     Equality.Equality_1_0 returns Fby
	 *     Comparison returns Fby
	 *     Comparison.Comparison_1_0 returns Fby
	 *     Mod returns Fby
	 *     Mod.Mod_1_0 returns Fby
	 *     PlusOrMinus returns Fby
	 *     PlusOrMinus.Plus_1_0_0_0 returns Fby
	 *     PlusOrMinus.Minus_1_0_1_0 returns Fby
	 *     MulOrDiv returns Fby
	 *     MulOrDiv.Mul_1_0_0_0 returns Fby
	 *     MulOrDiv.Div_1_0_1_0 returns Fby
	 *     Primary returns Fby
	 *
	 * Constraint:
	 *     (subExpressions+=Fby_Fby_1_0 subExpressions+=Arrow+)
	 */
	protected void sequence_Fby(ISerializationContext context, Fby semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Field returns Field
	 *
	 * Constraint:
	 *     (name=IDENT type=[Type|IDENT])
	 */
	protected void sequence_Field(ISerializationContext context, Field semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LustrePackage.Literals.FIELD__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LustrePackage.Literals.FIELD__NAME));
			if (transientValues.isValueTransient(semanticObject, LustrePackage.Literals.FIELD__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LustrePackage.Literals.FIELD__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFieldAccess().getNameIDENTTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getFieldAccess().getTypeTypeIDENTTerminalRuleCall_2_0_1(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Left returns Left
	 *
	 * Constraint:
	 *     (name=IDENT selector=Selector?)
	 */
	protected void sequence_Left(ISerializationContext context, Left semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Left_Part returns Left_List
	 *     Left_List returns Left_List
	 *
	 * Constraint:
	 *     (id+=Left id+=Left*)
	 */
	protected void sequence_Left_List(ISerializationContext context, Left_List semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Local_Constant_Declaration returns Constant_Declaration
	 *
	 * Constraint:
	 *     ((name=IDENT expr=ConstantExpression) | (name=IDENT type=Type expr=ConstantExpression))
	 */
	protected void sequence_Local_Constant_Declaration(ISerializationContext context, Constant_Declaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Assertion returns Mod
	 *     SelTrancheEnd returns Mod
	 *     Right_Part returns Mod
	 *     Expression returns Mod
	 *     Fby returns Mod
	 *     Fby.Fby_1_0 returns Mod
	 *     Arrow returns Mod
	 *     Arrow.Arrow_1_0 returns Mod
	 *     Or returns Mod
	 *     Or.Or_1_0 returns Mod
	 *     And returns Mod
	 *     And.And_1_0 returns Mod
	 *     Equality returns Mod
	 *     Equality.Equality_1_0 returns Mod
	 *     Comparison returns Mod
	 *     Comparison.Comparison_1_0 returns Mod
	 *     Mod returns Mod
	 *     Mod.Mod_1_0 returns Mod
	 *     PlusOrMinus returns Mod
	 *     PlusOrMinus.Plus_1_0_0_0 returns Mod
	 *     PlusOrMinus.Minus_1_0_1_0 returns Mod
	 *     MulOrDiv returns Mod
	 *     MulOrDiv.Mul_1_0_0_0 returns Mod
	 *     MulOrDiv.Div_1_0_1_0 returns Mod
	 *     Primary returns Mod
	 *
	 * Constraint:
	 *     (subExpressions+=Mod_Mod_1_0 subExpressions+=PlusOrMinus)
	 */
	protected void sequence_Mod(ISerializationContext context, Mod semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Assertion returns Div
	 *     SelTrancheEnd returns Div
	 *     Right_Part returns Div
	 *     Expression returns Div
	 *     Fby returns Div
	 *     Fby.Fby_1_0 returns Div
	 *     Arrow returns Div
	 *     Arrow.Arrow_1_0 returns Div
	 *     Or returns Div
	 *     Or.Or_1_0 returns Div
	 *     And returns Div
	 *     And.And_1_0 returns Div
	 *     Equality returns Div
	 *     Equality.Equality_1_0 returns Div
	 *     Comparison returns Div
	 *     Comparison.Comparison_1_0 returns Div
	 *     Mod returns Div
	 *     Mod.Mod_1_0 returns Div
	 *     PlusOrMinus returns Div
	 *     PlusOrMinus.Plus_1_0_0_0 returns Div
	 *     PlusOrMinus.Minus_1_0_1_0 returns Div
	 *     MulOrDiv returns Div
	 *     MulOrDiv.Mul_1_0_0_0 returns Div
	 *     MulOrDiv.Div_1_0_1_0 returns Div
	 *     Primary returns Div
	 *
	 * Constraint:
	 *     (subExpressions+=MulOrDiv_Div_1_0_1_0 subExpressions+=Primary)
	 */
	protected void sequence_MulOrDiv(ISerializationContext context, Div semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Assertion returns Mul
	 *     SelTrancheEnd returns Mul
	 *     Right_Part returns Mul
	 *     Expression returns Mul
	 *     Fby returns Mul
	 *     Fby.Fby_1_0 returns Mul
	 *     Arrow returns Mul
	 *     Arrow.Arrow_1_0 returns Mul
	 *     Or returns Mul
	 *     Or.Or_1_0 returns Mul
	 *     And returns Mul
	 *     And.And_1_0 returns Mul
	 *     Equality returns Mul
	 *     Equality.Equality_1_0 returns Mul
	 *     Comparison returns Mul
	 *     Comparison.Comparison_1_0 returns Mul
	 *     Mod returns Mul
	 *     Mod.Mod_1_0 returns Mul
	 *     PlusOrMinus returns Mul
	 *     PlusOrMinus.Plus_1_0_0_0 returns Mul
	 *     PlusOrMinus.Minus_1_0_1_0 returns Mul
	 *     MulOrDiv returns Mul
	 *     MulOrDiv.Mul_1_0_0_0 returns Mul
	 *     MulOrDiv.Div_1_0_1_0 returns Mul
	 *     Primary returns Mul
	 *
	 * Constraint:
	 *     (subExpressions+=MulOrDiv_Mul_1_0_0_0 subExpressions+=Primary)
	 */
	protected void sequence_MulOrDiv(ISerializationContext context, Mul semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Entity_Declaration returns Node_Declaration
	 *     Node_Declaration returns Node_Declaration
	 *
	 * Constraint:
	 *     (
	 *         name=IDENT 
	 *         (parameters+=Variable_Declaration parameters+=Variable_Declaration*)? 
	 *         returned+=Variable_Declaration 
	 *         returned+=Variable_Declaration* 
	 *         constants+=Local_Constant_Declaration? 
	 *         (variables+=Local_Variable_Declaration? constants+=Local_Constant_Declaration?)* 
	 *         (equations+=Equation | assertions+=Assertion | automatons+=Automaton)*
	 *     )
	 */
	protected void sequence_Node_Declaration(ISerializationContext context, Node_Declaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Assertion returns Or
	 *     SelTrancheEnd returns Or
	 *     Right_Part returns Or
	 *     Expression returns Or
	 *     Fby returns Or
	 *     Fby.Fby_1_0 returns Or
	 *     Arrow returns Or
	 *     Arrow.Arrow_1_0 returns Or
	 *     Or returns Or
	 *     Or.Or_1_0 returns Or
	 *     And returns Or
	 *     And.And_1_0 returns Or
	 *     Equality returns Or
	 *     Equality.Equality_1_0 returns Or
	 *     Comparison returns Or
	 *     Comparison.Comparison_1_0 returns Or
	 *     Mod returns Or
	 *     Mod.Mod_1_0 returns Or
	 *     PlusOrMinus returns Or
	 *     PlusOrMinus.Plus_1_0_0_0 returns Or
	 *     PlusOrMinus.Minus_1_0_1_0 returns Or
	 *     MulOrDiv returns Or
	 *     MulOrDiv.Mul_1_0_0_0 returns Or
	 *     MulOrDiv.Div_1_0_1_0 returns Or
	 *     Primary returns Or
	 *
	 * Constraint:
	 *     (subExpressions+=Or_Or_1_0 subExpressions+=And+)
	 */
	protected void sequence_Or(ISerializationContext context, Or semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Package_Declaration returns Package_Declaration
	 *
	 * Constraint:
	 *     (
	 *         name=IDENT 
	 *         (uses+=IDENT uses+=IDENT*)? 
	 *         provides+=Package_Provided+ 
	 *         (nodes+=Node_Declaration | types+=Type_Declaration | constants+=Constant_Declaration)*
	 *     )
	 */
	protected void sequence_Package_Declaration(ISerializationContext context, Package_Declaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Package_Provided_IO returns Package_Provided_IO
	 *
	 * Constraint:
	 *     (name=[Variable_Declaration|IDENT] type=IDENT)
	 */
	protected void sequence_Package_Provided_IO(ISerializationContext context, Package_Provided_IO semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LustrePackage.Literals.PACKAGE_PROVIDED_IO__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LustrePackage.Literals.PACKAGE_PROVIDED_IO__NAME));
			if (transientValues.isValueTransient(semanticObject, LustrePackage.Literals.PACKAGE_PROVIDED_IO__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LustrePackage.Literals.PACKAGE_PROVIDED_IO__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPackage_Provided_IOAccess().getNameVariable_DeclarationIDENTTerminalRuleCall_0_0_1(), semanticObject.getName());
		feeder.accept(grammarAccess.getPackage_Provided_IOAccess().getTypeIDENTTerminalRuleCall_2_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Package_Provided returns Package_Provided
	 *
	 * Constraint:
	 *     (
	 *         name=[Node_Declaration|IDENT] 
	 *         (parameters+=Package_Provided_IO parameters+=Package_Provided_IO*)? 
	 *         returned+=Package_Provided_IO 
	 *         returned+=Package_Provided_IO*
	 *     )
	 */
	protected void sequence_Package_Provided(ISerializationContext context, Package_Provided semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Assertion returns Minus
	 *     SelTrancheEnd returns Minus
	 *     Right_Part returns Minus
	 *     Expression returns Minus
	 *     Fby returns Minus
	 *     Fby.Fby_1_0 returns Minus
	 *     Arrow returns Minus
	 *     Arrow.Arrow_1_0 returns Minus
	 *     Or returns Minus
	 *     Or.Or_1_0 returns Minus
	 *     And returns Minus
	 *     And.And_1_0 returns Minus
	 *     Equality returns Minus
	 *     Equality.Equality_1_0 returns Minus
	 *     Comparison returns Minus
	 *     Comparison.Comparison_1_0 returns Minus
	 *     Mod returns Minus
	 *     Mod.Mod_1_0 returns Minus
	 *     PlusOrMinus returns Minus
	 *     PlusOrMinus.Plus_1_0_0_0 returns Minus
	 *     PlusOrMinus.Minus_1_0_1_0 returns Minus
	 *     MulOrDiv returns Minus
	 *     MulOrDiv.Mul_1_0_0_0 returns Minus
	 *     MulOrDiv.Div_1_0_1_0 returns Minus
	 *     Primary returns Minus
	 *
	 * Constraint:
	 *     (subExpressions+=PlusOrMinus_Minus_1_0_1_0 subExpressions+=MulOrDiv)
	 */
	protected void sequence_PlusOrMinus(ISerializationContext context, Minus semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Assertion returns Plus
	 *     SelTrancheEnd returns Plus
	 *     Right_Part returns Plus
	 *     Expression returns Plus
	 *     Fby returns Plus
	 *     Fby.Fby_1_0 returns Plus
	 *     Arrow returns Plus
	 *     Arrow.Arrow_1_0 returns Plus
	 *     Or returns Plus
	 *     Or.Or_1_0 returns Plus
	 *     And returns Plus
	 *     And.And_1_0 returns Plus
	 *     Equality returns Plus
	 *     Equality.Equality_1_0 returns Plus
	 *     Comparison returns Plus
	 *     Comparison.Comparison_1_0 returns Plus
	 *     Mod returns Plus
	 *     Mod.Mod_1_0 returns Plus
	 *     PlusOrMinus returns Plus
	 *     PlusOrMinus.Plus_1_0_0_0 returns Plus
	 *     PlusOrMinus.Minus_1_0_1_0 returns Plus
	 *     MulOrDiv returns Plus
	 *     MulOrDiv.Mul_1_0_0_0 returns Plus
	 *     MulOrDiv.Div_1_0_1_0 returns Plus
	 *     Primary returns Plus
	 *
	 * Constraint:
	 *     (subExpressions+=PlusOrMinus_Plus_1_0_0_0 subExpressions+=MulOrDiv)
	 */
	protected void sequence_PlusOrMinus(ISerializationContext context, Plus semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Assertion returns Current
	 *     SelTrancheEnd returns Current
	 *     Right_Part returns Current
	 *     Expression returns Current
	 *     Fby returns Current
	 *     Fby.Fby_1_0 returns Current
	 *     Arrow returns Current
	 *     Arrow.Arrow_1_0 returns Current
	 *     Or returns Current
	 *     Or.Or_1_0 returns Current
	 *     And returns Current
	 *     And.And_1_0 returns Current
	 *     Equality returns Current
	 *     Equality.Equality_1_0 returns Current
	 *     Comparison returns Current
	 *     Comparison.Comparison_1_0 returns Current
	 *     Mod returns Current
	 *     Mod.Mod_1_0 returns Current
	 *     PlusOrMinus returns Current
	 *     PlusOrMinus.Plus_1_0_0_0 returns Current
	 *     PlusOrMinus.Minus_1_0_1_0 returns Current
	 *     MulOrDiv returns Current
	 *     MulOrDiv.Mul_1_0_0_0 returns Current
	 *     MulOrDiv.Div_1_0_1_0 returns Current
	 *     Primary returns Current
	 *
	 * Constraint:
	 *     expression=Primary
	 */
	protected void sequence_Primary(ISerializationContext context, Current semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LustrePackage.Literals.CURRENT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LustrePackage.Literals.CURRENT__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimaryAccess().getExpressionPrimaryParserRuleCall_4_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Assertion returns Not
	 *     SelTrancheEnd returns Not
	 *     Right_Part returns Not
	 *     Expression returns Not
	 *     Fby returns Not
	 *     Fby.Fby_1_0 returns Not
	 *     Arrow returns Not
	 *     Arrow.Arrow_1_0 returns Not
	 *     Or returns Not
	 *     Or.Or_1_0 returns Not
	 *     And returns Not
	 *     And.And_1_0 returns Not
	 *     Equality returns Not
	 *     Equality.Equality_1_0 returns Not
	 *     Comparison returns Not
	 *     Comparison.Comparison_1_0 returns Not
	 *     Mod returns Not
	 *     Mod.Mod_1_0 returns Not
	 *     PlusOrMinus returns Not
	 *     PlusOrMinus.Plus_1_0_0_0 returns Not
	 *     PlusOrMinus.Minus_1_0_1_0 returns Not
	 *     MulOrDiv returns Not
	 *     MulOrDiv.Mul_1_0_0_0 returns Not
	 *     MulOrDiv.Div_1_0_1_0 returns Not
	 *     Primary returns Not
	 *
	 * Constraint:
	 *     expression=Primary
	 */
	protected void sequence_Primary(ISerializationContext context, Not semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LustrePackage.Literals.NOT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LustrePackage.Literals.NOT__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimaryAccess().getExpressionPrimaryParserRuleCall_1_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Assertion returns Pre
	 *     SelTrancheEnd returns Pre
	 *     Right_Part returns Pre
	 *     Expression returns Pre
	 *     Fby returns Pre
	 *     Fby.Fby_1_0 returns Pre
	 *     Arrow returns Pre
	 *     Arrow.Arrow_1_0 returns Pre
	 *     Or returns Pre
	 *     Or.Or_1_0 returns Pre
	 *     And returns Pre
	 *     And.And_1_0 returns Pre
	 *     Equality returns Pre
	 *     Equality.Equality_1_0 returns Pre
	 *     Comparison returns Pre
	 *     Comparison.Comparison_1_0 returns Pre
	 *     Mod returns Pre
	 *     Mod.Mod_1_0 returns Pre
	 *     PlusOrMinus returns Pre
	 *     PlusOrMinus.Plus_1_0_0_0 returns Pre
	 *     PlusOrMinus.Minus_1_0_1_0 returns Pre
	 *     MulOrDiv returns Pre
	 *     MulOrDiv.Mul_1_0_0_0 returns Pre
	 *     MulOrDiv.Div_1_0_1_0 returns Pre
	 *     Primary returns Pre
	 *
	 * Constraint:
	 *     expression=Primary
	 */
	protected void sequence_Primary(ISerializationContext context, Pre semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LustrePackage.Literals.PRE__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LustrePackage.Literals.PRE__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimaryAccess().getExpressionPrimaryParserRuleCall_3_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Assertion returns UMinus
	 *     SelTrancheEnd returns UMinus
	 *     Right_Part returns UMinus
	 *     Expression returns UMinus
	 *     Fby returns UMinus
	 *     Fby.Fby_1_0 returns UMinus
	 *     Arrow returns UMinus
	 *     Arrow.Arrow_1_0 returns UMinus
	 *     Or returns UMinus
	 *     Or.Or_1_0 returns UMinus
	 *     And returns UMinus
	 *     And.And_1_0 returns UMinus
	 *     Equality returns UMinus
	 *     Equality.Equality_1_0 returns UMinus
	 *     Comparison returns UMinus
	 *     Comparison.Comparison_1_0 returns UMinus
	 *     Mod returns UMinus
	 *     Mod.Mod_1_0 returns UMinus
	 *     PlusOrMinus returns UMinus
	 *     PlusOrMinus.Plus_1_0_0_0 returns UMinus
	 *     PlusOrMinus.Minus_1_0_1_0 returns UMinus
	 *     MulOrDiv returns UMinus
	 *     MulOrDiv.Mul_1_0_0_0 returns UMinus
	 *     MulOrDiv.Div_1_0_1_0 returns UMinus
	 *     Primary returns UMinus
	 *
	 * Constraint:
	 *     expression=Primary
	 */
	protected void sequence_Primary(ISerializationContext context, UMinus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LustrePackage.Literals.UMINUS__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LustrePackage.Literals.UMINUS__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimaryAccess().getExpressionPrimaryParserRuleCall_2_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Program returns Program
	 *
	 * Constraint:
	 *     nodes+=Node_Declaration+
	 */
	protected void sequence_Program(ISerializationContext context, Program semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Record_Type returns Record_Type
	 *
	 * Constraint:
	 *     (fields+=Field fields+=Field*)
	 */
	protected void sequence_Record_Type(ISerializationContext context, Record_Type semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Selector returns Selector
	 *
	 * Constraint:
	 *     (name=IDENT | (begin=Expression end=SelTrancheEnd?))
	 */
	protected void sequence_Selector(ISerializationContext context, Selector semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Entity_Declaration returns Type_Declaration
	 *     Type_Declaration returns Type_Declaration
	 *
	 * Constraint:
	 *     (name=IDENT | (name=IDENT type=Type))
	 */
	protected void sequence_Type_Declaration(ISerializationContext context, Type_Declaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Type returns Type
	 *
	 * Constraint:
	 *     name=IDENT
	 */
	protected void sequence_Type(ISerializationContext context, Type semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LustrePackage.Literals.TYPE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LustrePackage.Literals.TYPE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTypeAccess().getNameIDENTTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Assertion returns VariableReference
	 *     SelTrancheEnd returns VariableReference
	 *     Right_Part returns VariableReference
	 *     Expression returns VariableReference
	 *     Fby returns VariableReference
	 *     Fby.Fby_1_0 returns VariableReference
	 *     Arrow returns VariableReference
	 *     Arrow.Arrow_1_0 returns VariableReference
	 *     Or returns VariableReference
	 *     Or.Or_1_0 returns VariableReference
	 *     And returns VariableReference
	 *     And.And_1_0 returns VariableReference
	 *     Equality returns VariableReference
	 *     Equality.Equality_1_0 returns VariableReference
	 *     Comparison returns VariableReference
	 *     Comparison.Comparison_1_0 returns VariableReference
	 *     Mod returns VariableReference
	 *     Mod.Mod_1_0 returns VariableReference
	 *     PlusOrMinus returns VariableReference
	 *     PlusOrMinus.Plus_1_0_0_0 returns VariableReference
	 *     PlusOrMinus.Minus_1_0_1_0 returns VariableReference
	 *     MulOrDiv returns VariableReference
	 *     MulOrDiv.Mul_1_0_0_0 returns VariableReference
	 *     MulOrDiv.Div_1_0_1_0 returns VariableReference
	 *     Primary returns VariableReference
	 *     AtomicExpression returns VariableReference
	 *     VariableReference returns VariableReference
	 *
	 * Constraint:
	 *     value=[Variable_Declaration|IDENT]
	 */
	protected void sequence_VariableReference(ISerializationContext context, VariableReference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LustrePackage.Literals.VARIABLE_REFERENCE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LustrePackage.Literals.VARIABLE_REFERENCE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableReferenceAccess().getValueVariable_DeclarationIDENTTerminalRuleCall_1_0_1(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Variable_Declaration returns Variable_Declaration
	 *     Local_Variable_Declaration returns Variable_Declaration
	 *
	 * Constraint:
	 *     (name=IDENT type=Type clock=IDENT?)
	 */
	protected void sequence_Variable_Declaration(ISerializationContext context, Variable_Declaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
