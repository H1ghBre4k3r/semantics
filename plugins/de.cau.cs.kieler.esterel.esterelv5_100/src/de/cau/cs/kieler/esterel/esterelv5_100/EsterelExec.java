/*
 * KIELER - Kiel Integrated Environment for Layout Eclipse RichClient
 *
 * http://www.informatik.uni-kiel.de/rtsys/kieler/
 * 
 * Copyright 2015 by
 * + Kiel University
 *   + Department of Computer Science
 *     + Real-Time and Embedded Systems Group
 * 
 * This code is provided under the terms of the Eclipse Public License (EPL).
 * See the file epl-v10.html for the license text.
 */
package de.cau.cs.kieler.esterel.esterelv5_100;

import java.io.BufferedReader;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URL;

import javax.swing.plaf.SliderUI;

/**
 * The class controls the execution of the single compiler processors.
 * 
 * @author sna
 */
public final class EsterelExec {
    
    /** The file of the generated C code.
     * The file name depends on the code producing processor (sscc, scc or occ).
     */
    public static final String GENERATED_C_CODE_FILE = "sscc_out.c";

    /**
     * Hidden constructor to avoid instantiation.
     */
    private EsterelExec() {

    }

    /**
     * Run an external process, reads and returns the stream of the generated file. For C code
     * generation processors.
     * 
     * @param cmd
     *            command that is actually executed
     * @param input
     *            the input that is feed to the executed program (stdin)
     * @return the output that was generated by the program (stdout)
     * @throws IOException
     *             throw for communication errors or if the return value of the process is not 0. In
     *             this case, also the error stream is contained in the exception.
     */
    public static InputStream execComp(final String cmd, final InputStream input)
            throws IOException {
        Process p = Runtime.getRuntime().exec(cmd);

        OutputStream stdin = p.getOutputStream();

        while (input.available() > 0) {
            int r = input.read();
            stdin.write(r);
        }
        stdin.close();

        /* 
         * !!!!! BAD CODE !!!!!
         * Since the processor which produces the C code does not provide return value correctly
         * the generated C code must be read from the produced file.
         * The file with the generated C code is located in the working directory.
         */
        File c = new File(GENERATED_C_CODE_FILE);
        while (!c.exists()) {
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                // silently ignore
            }
        }
        FileInputStream code = new FileInputStream(GENERATED_C_CODE_FILE);
        c.delete();

        return code;
    }

    /**
     * Run an external process with a timeout. This method works for Linux/Mac and Windows. For all
     * processors except the C code generation processors.
     *
     * @param cmd
     *            command that is actually executed
     * @param input
     *            the input that is feed to the executed program (stdin)
     * @param inittime
     *            time initially, the process has this amount of time to produce the initial output.
     * @param timeout
     *            the process is terminated timeout milliseconds after the last output was generated
     * @param steptime
     *            time in milliseconds to wait between polling for output
     * @param outputStream
     *            the output stream can be null
     * @return the output that was generated by the program (stdout)
     * @throws IOException
     *             throw for communication errors or if the return value of the process is not 0. In
     *             this case, also the error stream is contained in the exception.
     * @throw KiemInitializationException if the compilation is not successful
     */
    public static InputStream exec(final String cmd, final InputStream input, final int inittime,
            final int timeout, final int steptime) throws IOException {
        Process p = Runtime.getRuntime().exec(cmd);

        ByteArrayOutputStream output = new ByteArrayOutputStream();

        InputStream stdout = p.getInputStream();
        InputStream stderr = p.getErrorStream();
        OutputStream stdin = p.getOutputStream();

        while (input.available() > 0) {
            int r = input.read();
            stdin.write(r);
        }
        stdin.close();

        // wait for initial output
        long time = System.currentTimeMillis();
        while (System.currentTimeMillis() - time < timeout) {
            if (stdout.available() > 0) {
                do {
                    int t = stdout.read();
                    // System.out.print(Character.toChars(t));
                    output.write(t);
                } while (stdout.available() > 0);
                time = System.currentTimeMillis();
            } else {
                try {
                    Thread.sleep(steptime);
                } catch (InterruptedException e) {
                    // silently ignore
                }
            }
        }
        try {
            StringBuffer err = new StringBuffer();
            while (stderr.available() > 0) {
                err.append(Character.toChars(stderr.read()));
            }
            stdout.close();
            stderr.close();

            try {
                // give process some time to terminate
                Thread.sleep(steptime);
            } catch (InterruptedException e) {
                // silently ignore
            }

            if (p.exitValue() != 0 && err.length() > 0) {
                throw new IOException("Parse Error: " + err.toString(), null);
            }
        } finally {
            p.destroy();
        }

        if (p.exitValue() != 0) {
            throw new IOException("error executing " + cmd, null);
        }
        return new ByteArrayInputStream(output.toByteArray());
    }

}
