/*
 * generated by Xtext
 */
package de.cau.cs.kieler.annotations.services;

import com.google.inject.Singleton;
import com.google.inject.Inject;

import java.util.List;

import org.eclipse.xtext.*;
import org.eclipse.xtext.service.GrammarProvider;
import org.eclipse.xtext.service.AbstractElementFinder.*;

import org.eclipse.xtext.common.services.TerminalsGrammarAccess;

@Singleton
public class AnnotationsGrammarAccess extends AbstractGrammarElementFinder {
	
	
	public class AnnotationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.annotations.Annotations.Annotation");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cCommentAnnotationParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cKeyStringValueAnnotationParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cTypedKeyStringValueAnnotationParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cTagAnnotationParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		/// **
		// * @author ssm
		// * @kieler.design 2015-08-21 proposed 
		// * @kieler.rating 2015-08-21 proposed yellow
		// * / // ------------------ //
		////  Annotation Rules  // 
		//// ------------------ //
		//// General rule for annotations
		//// The different annotation sub rules are tested in order. Hence, order matters! 
		//Annotation:
		//	CommentAnnotation | KeyStringValueAnnotation | TypedKeyStringValueAnnotation | TagAnnotation;
		@Override public ParserRule getRule() { return rule; }

		//CommentAnnotation | KeyStringValueAnnotation | TypedKeyStringValueAnnotation | TagAnnotation
		public Alternatives getAlternatives() { return cAlternatives; }

		//CommentAnnotation
		public RuleCall getCommentAnnotationParserRuleCall_0() { return cCommentAnnotationParserRuleCall_0; }

		//KeyStringValueAnnotation
		public RuleCall getKeyStringValueAnnotationParserRuleCall_1() { return cKeyStringValueAnnotationParserRuleCall_1; }

		//TypedKeyStringValueAnnotation
		public RuleCall getTypedKeyStringValueAnnotationParserRuleCall_2() { return cTypedKeyStringValueAnnotationParserRuleCall_2; }

		//TagAnnotation
		public RuleCall getTagAnnotationParserRuleCall_3() { return cTagAnnotationParserRuleCall_3; }
	}

	public class PragmaAnnotationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.annotations.Annotations.PragmaAnnotation");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cPramgaKeyStringValueAnnotationParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cPragmaTagAnnotationParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//// General rule for pragmas
		//// We only have string and tag pragmas.    
		//PragmaAnnotation Annotation:
		//	PramgaKeyStringValueAnnotation | PragmaTagAnnotation
		@Override public ParserRule getRule() { return rule; }

		//PramgaKeyStringValueAnnotation | PragmaTagAnnotation
		public Alternatives getAlternatives() { return cAlternatives; }

		//PramgaKeyStringValueAnnotation
		public RuleCall getPramgaKeyStringValueAnnotationParserRuleCall_0() { return cPramgaKeyStringValueAnnotationParserRuleCall_0; }

		//PragmaTagAnnotation
		public RuleCall getPragmaTagAnnotationParserRuleCall_1() { return cPragmaTagAnnotationParserRuleCall_1; }
	}

	public class ValuedAnnotationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.annotations.Annotations.ValuedAnnotation");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cCommentAnnotationParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cKeyStringValueAnnotationParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cTypedKeyStringValueAnnotationParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//// Valued Annotation Rule
		//// Valued annotations must have a value. For instance, tag annotations are not allowed.
		//// Derived grammars may use this rule if the general annotation rules compromises the grammar
		//// due to ambiguities.
		//ValuedAnnotation Annotation:
		//	CommentAnnotation | KeyStringValueAnnotation | TypedKeyStringValueAnnotation
		@Override public ParserRule getRule() { return rule; }

		//CommentAnnotation | KeyStringValueAnnotation | TypedKeyStringValueAnnotation
		public Alternatives getAlternatives() { return cAlternatives; }

		//CommentAnnotation
		public RuleCall getCommentAnnotationParserRuleCall_0() { return cCommentAnnotationParserRuleCall_0; }

		//KeyStringValueAnnotation
		public RuleCall getKeyStringValueAnnotationParserRuleCall_1() { return cKeyStringValueAnnotationParserRuleCall_1; }

		//TypedKeyStringValueAnnotation
		public RuleCall getTypedKeyStringValueAnnotationParserRuleCall_2() { return cTypedKeyStringValueAnnotationParserRuleCall_2; }
	}

	public class RestrictedTypeAnnotationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.annotations.Annotations.RestrictedTypeAnnotation");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cCommentAnnotationParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cRestrictedKeyStringValueAnnotationParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cRestrictedTypedKeyStringValueAnnotationParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cTagAnnotationParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//// Restricted Type Annotation Rule
		//// The restricted type annotation rule does not allow typed string annotations. 
		//// You can use this rule in derived grammars if you don't want to permit typed strings. 
		//RestrictedTypeAnnotation Annotation:
		//	CommentAnnotation | RestrictedKeyStringValueAnnotation | RestrictedTypedKeyStringValueAnnotation | TagAnnotation
		@Override public ParserRule getRule() { return rule; }

		//CommentAnnotation | RestrictedKeyStringValueAnnotation | RestrictedTypedKeyStringValueAnnotation | TagAnnotation
		public Alternatives getAlternatives() { return cAlternatives; }

		//CommentAnnotation
		public RuleCall getCommentAnnotationParserRuleCall_0() { return cCommentAnnotationParserRuleCall_0; }

		//RestrictedKeyStringValueAnnotation
		public RuleCall getRestrictedKeyStringValueAnnotationParserRuleCall_1() { return cRestrictedKeyStringValueAnnotationParserRuleCall_1; }

		//RestrictedTypedKeyStringValueAnnotation
		public RuleCall getRestrictedTypedKeyStringValueAnnotationParserRuleCall_2() { return cRestrictedTypedKeyStringValueAnnotationParserRuleCall_2; }

		//TagAnnotation
		public RuleCall getTagAnnotationParserRuleCall_3() { return cTagAnnotationParserRuleCall_3; }
	}

	public class QuotedStringAnnotationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.annotations.Annotations.QuotedStringAnnotation");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cCommentAnnotationParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cQuotedKeyStringValueAnnotationParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cQuotedTypedKeyStringValueAnnotationParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cTagAnnotationParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//// Quoted String Annotation Rule
		//// The quoted string annotation rules uses quoted key string annotations. You can use this rule in 
		//// derived grammars if you don't want to permit unquoted strings. 
		//// (If you are looking for an example, the keffects grammar uses this rule for their emission
		//// rule and to avoid grammar ambiguities.)  
		//QuotedStringAnnotation Annotation:
		//	CommentAnnotation | QuotedKeyStringValueAnnotation | QuotedTypedKeyStringValueAnnotation | TagAnnotation
		@Override public ParserRule getRule() { return rule; }

		//CommentAnnotation | QuotedKeyStringValueAnnotation | QuotedTypedKeyStringValueAnnotation | TagAnnotation
		public Alternatives getAlternatives() { return cAlternatives; }

		//CommentAnnotation
		public RuleCall getCommentAnnotationParserRuleCall_0() { return cCommentAnnotationParserRuleCall_0; }

		//QuotedKeyStringValueAnnotation
		public RuleCall getQuotedKeyStringValueAnnotationParserRuleCall_1() { return cQuotedKeyStringValueAnnotationParserRuleCall_1; }

		//QuotedTypedKeyStringValueAnnotation
		public RuleCall getQuotedTypedKeyStringValueAnnotationParserRuleCall_2() { return cQuotedTypedKeyStringValueAnnotationParserRuleCall_2; }

		//TagAnnotation
		public RuleCall getTagAnnotationParserRuleCall_3() { return cTagAnnotationParserRuleCall_3; }
	}

	public class CommentAnnotationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.annotations.Annotations.CommentAnnotation");
		private final Assignment cValuesAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValuesCOMMENT_ANNOTATIONTerminalRuleCall_0 = (RuleCall)cValuesAssignment.eContents().get(0);
		
		//// CommentAnnotation
		//// e.g.: / ** semantic comment * /
		//CommentAnnotation:
		//	values+=COMMENT_ANNOTATION;
		@Override public ParserRule getRule() { return rule; }

		//values+=COMMENT_ANNOTATION
		public Assignment getValuesAssignment() { return cValuesAssignment; }

		//COMMENT_ANNOTATION
		public RuleCall getValuesCOMMENT_ANNOTATIONTerminalRuleCall_0() { return cValuesCOMMENT_ANNOTATIONTerminalRuleCall_0; }
	}

	public class TagAnnotationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.annotations.Annotations.TagAnnotation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cCommercialAtKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameExtendedIDParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		
		//// TagAnnotation
		//// e.g.: @HVlayout
		//TagAnnotation Annotation:
		//	'@' name=ExtendedID
		@Override public ParserRule getRule() { return rule; }

		//'@' name=ExtendedID
		public Group getGroup() { return cGroup; }

		//'@'
		public Keyword getCommercialAtKeyword_0() { return cCommercialAtKeyword_0; }

		//name=ExtendedID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//ExtendedID
		public RuleCall getNameExtendedIDParserRuleCall_1_0() { return cNameExtendedIDParserRuleCall_1_0; }
	}

	public class PragmaTagAnnotationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.annotations.Annotations.PragmaTagAnnotation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cNumberSignKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameExtendedIDParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		
		//PragmaTagAnnotation PragmaAnnotation:
		//	'#' name=ExtendedID
		@Override public ParserRule getRule() { return rule; }

		//'#' name=ExtendedID
		public Group getGroup() { return cGroup; }

		//'#'
		public Keyword getNumberSignKeyword_0() { return cNumberSignKeyword_0; }

		//name=ExtendedID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//ExtendedID
		public RuleCall getNameExtendedIDParserRuleCall_1_0() { return cNameExtendedIDParserRuleCall_1_0; }
	}

	public class KeyStringValueAnnotationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.annotations.Annotations.KeyStringValueAnnotation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cCommercialAtKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameExtendedIDParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Assignment cValuesAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cValuesEStringAllTypesParserRuleCall_2_0 = (RuleCall)cValuesAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cCommaKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cValuesAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cValuesEStringAllTypesParserRuleCall_3_1_0 = (RuleCall)cValuesAssignment_3_1.eContents().get(0);
		
		//// KeyStringValueAnnotation
		//// e.g.: @layouter dot
		//// You may separate different values via comma.   
		//KeyStringValueAnnotation StringAnnotation:
		//	'@' name=ExtendedID values+=EStringAllTypes (',' values+=EStringAllTypes)*
		@Override public ParserRule getRule() { return rule; }

		//'@' name=ExtendedID values+=EStringAllTypes (',' values+=EStringAllTypes)*
		public Group getGroup() { return cGroup; }

		//'@'
		public Keyword getCommercialAtKeyword_0() { return cCommercialAtKeyword_0; }

		//name=ExtendedID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//ExtendedID
		public RuleCall getNameExtendedIDParserRuleCall_1_0() { return cNameExtendedIDParserRuleCall_1_0; }

		//values+=EStringAllTypes
		public Assignment getValuesAssignment_2() { return cValuesAssignment_2; }

		//EStringAllTypes
		public RuleCall getValuesEStringAllTypesParserRuleCall_2_0() { return cValuesEStringAllTypesParserRuleCall_2_0; }

		//(',' values+=EStringAllTypes)*
		public Group getGroup_3() { return cGroup_3; }

		//','
		public Keyword getCommaKeyword_3_0() { return cCommaKeyword_3_0; }

		//values+=EStringAllTypes
		public Assignment getValuesAssignment_3_1() { return cValuesAssignment_3_1; }

		//EStringAllTypes
		public RuleCall getValuesEStringAllTypesParserRuleCall_3_1_0() { return cValuesEStringAllTypesParserRuleCall_3_1_0; }
	}

	public class RestrictedKeyStringValueAnnotationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.annotations.Annotations.RestrictedKeyStringValueAnnotation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cCommercialAtKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameExtendedIDParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Assignment cValuesAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cValuesEStringBooleanParserRuleCall_2_0 = (RuleCall)cValuesAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cCommaKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cValuesAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cValuesEStringBooleanParserRuleCall_3_1_0 = (RuleCall)cValuesAssignment_3_1.eContents().get(0);
		
		//RestrictedKeyStringValueAnnotation StringAnnotation:
		//	'@' name=ExtendedID values+=EStringBoolean (',' values+=EStringBoolean)*
		@Override public ParserRule getRule() { return rule; }

		//'@' name=ExtendedID values+=EStringBoolean (',' values+=EStringBoolean)*
		public Group getGroup() { return cGroup; }

		//'@'
		public Keyword getCommercialAtKeyword_0() { return cCommercialAtKeyword_0; }

		//name=ExtendedID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//ExtendedID
		public RuleCall getNameExtendedIDParserRuleCall_1_0() { return cNameExtendedIDParserRuleCall_1_0; }

		//values+=EStringBoolean
		public Assignment getValuesAssignment_2() { return cValuesAssignment_2; }

		//EStringBoolean
		public RuleCall getValuesEStringBooleanParserRuleCall_2_0() { return cValuesEStringBooleanParserRuleCall_2_0; }

		//(',' values+=EStringBoolean)*
		public Group getGroup_3() { return cGroup_3; }

		//','
		public Keyword getCommaKeyword_3_0() { return cCommaKeyword_3_0; }

		//values+=EStringBoolean
		public Assignment getValuesAssignment_3_1() { return cValuesAssignment_3_1; }

		//EStringBoolean
		public RuleCall getValuesEStringBooleanParserRuleCall_3_1_0() { return cValuesEStringBooleanParserRuleCall_3_1_0; }
	}

	public class PramgaKeyStringValueAnnotationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.annotations.Annotations.PramgaKeyStringValueAnnotation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cNumberSignKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameExtendedIDParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Assignment cValuesAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cValuesEStringAllTypesParserRuleCall_2_0 = (RuleCall)cValuesAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cCommaKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cValuesAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cValuesEStringAllTypesParserRuleCall_3_1_0 = (RuleCall)cValuesAssignment_3_1.eContents().get(0);
		
		//PramgaKeyStringValueAnnotation PragmaStringAnnotation:
		//	'#' name=ExtendedID values+=EStringAllTypes (',' values+=EStringAllTypes)*
		@Override public ParserRule getRule() { return rule; }

		//'#' name=ExtendedID values+=EStringAllTypes (',' values+=EStringAllTypes)*
		public Group getGroup() { return cGroup; }

		//'#'
		public Keyword getNumberSignKeyword_0() { return cNumberSignKeyword_0; }

		//name=ExtendedID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//ExtendedID
		public RuleCall getNameExtendedIDParserRuleCall_1_0() { return cNameExtendedIDParserRuleCall_1_0; }

		//values+=EStringAllTypes
		public Assignment getValuesAssignment_2() { return cValuesAssignment_2; }

		//EStringAllTypes
		public RuleCall getValuesEStringAllTypesParserRuleCall_2_0() { return cValuesEStringAllTypesParserRuleCall_2_0; }

		//(',' values+=EStringAllTypes)*
		public Group getGroup_3() { return cGroup_3; }

		//','
		public Keyword getCommaKeyword_3_0() { return cCommaKeyword_3_0; }

		//values+=EStringAllTypes
		public Assignment getValuesAssignment_3_1() { return cValuesAssignment_3_1; }

		//EStringAllTypes
		public RuleCall getValuesEStringAllTypesParserRuleCall_3_1_0() { return cValuesEStringAllTypesParserRuleCall_3_1_0; }
	}

	public class TypedKeyStringValueAnnotationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.annotations.Annotations.TypedKeyStringValueAnnotation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cCommercialAtKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameExtendedIDParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cTypeAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cTypeExtendedIDParserRuleCall_3_0 = (RuleCall)cTypeAssignment_3.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cValuesAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cValuesEStringAllTypesParserRuleCall_5_0 = (RuleCall)cValuesAssignment_5.eContents().get(0);
		private final Group cGroup_6 = (Group)cGroup.eContents().get(6);
		private final Keyword cCommaKeyword_6_0 = (Keyword)cGroup_6.eContents().get(0);
		private final Assignment cValuesAssignment_6_1 = (Assignment)cGroup_6.eContents().get(1);
		private final RuleCall cValuesEStringAllTypesParserRuleCall_6_1_0 = (RuleCall)cValuesAssignment_6_1.eContents().get(0);
		
		//// TypedKeyStringValueAnnotation
		//// e.g.: @position[de.cau.cs.kieler.core.math.KVector] "(3,2)"
		//TypedKeyStringValueAnnotation TypedStringAnnotation:
		//	'@' name=ExtendedID '[' type=ExtendedID ']' values+=EStringAllTypes (',' values+=EStringAllTypes)*
		@Override public ParserRule getRule() { return rule; }

		//'@' name=ExtendedID '[' type=ExtendedID ']' values+=EStringAllTypes (',' values+=EStringAllTypes)*
		public Group getGroup() { return cGroup; }

		//'@'
		public Keyword getCommercialAtKeyword_0() { return cCommercialAtKeyword_0; }

		//name=ExtendedID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//ExtendedID
		public RuleCall getNameExtendedIDParserRuleCall_1_0() { return cNameExtendedIDParserRuleCall_1_0; }

		//'['
		public Keyword getLeftSquareBracketKeyword_2() { return cLeftSquareBracketKeyword_2; }

		//type=ExtendedID
		public Assignment getTypeAssignment_3() { return cTypeAssignment_3; }

		//ExtendedID
		public RuleCall getTypeExtendedIDParserRuleCall_3_0() { return cTypeExtendedIDParserRuleCall_3_0; }

		//']'
		public Keyword getRightSquareBracketKeyword_4() { return cRightSquareBracketKeyword_4; }

		//values+=EStringAllTypes
		public Assignment getValuesAssignment_5() { return cValuesAssignment_5; }

		//EStringAllTypes
		public RuleCall getValuesEStringAllTypesParserRuleCall_5_0() { return cValuesEStringAllTypesParserRuleCall_5_0; }

		//(',' values+=EStringAllTypes)*
		public Group getGroup_6() { return cGroup_6; }

		//','
		public Keyword getCommaKeyword_6_0() { return cCommaKeyword_6_0; }

		//values+=EStringAllTypes
		public Assignment getValuesAssignment_6_1() { return cValuesAssignment_6_1; }

		//EStringAllTypes
		public RuleCall getValuesEStringAllTypesParserRuleCall_6_1_0() { return cValuesEStringAllTypesParserRuleCall_6_1_0; }
	}

	public class RestrictedTypedKeyStringValueAnnotationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.annotations.Annotations.RestrictedTypedKeyStringValueAnnotation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cCommercialAtKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameExtendedIDParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cTypeAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cTypeExtendedIDParserRuleCall_3_0 = (RuleCall)cTypeAssignment_3.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cValuesAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cValuesEStringBooleanParserRuleCall_5_0 = (RuleCall)cValuesAssignment_5.eContents().get(0);
		private final Group cGroup_6 = (Group)cGroup.eContents().get(6);
		private final Keyword cCommaKeyword_6_0 = (Keyword)cGroup_6.eContents().get(0);
		private final Assignment cValuesAssignment_6_1 = (Assignment)cGroup_6.eContents().get(1);
		private final RuleCall cValuesEStringBooleanParserRuleCall_6_1_0 = (RuleCall)cValuesAssignment_6_1.eContents().get(0);
		
		//RestrictedTypedKeyStringValueAnnotation TypedStringAnnotation:
		//	'@' name=ExtendedID '[' type=ExtendedID ']' values+=EStringBoolean (',' values+=EStringBoolean)*
		@Override public ParserRule getRule() { return rule; }

		//'@' name=ExtendedID '[' type=ExtendedID ']' values+=EStringBoolean (',' values+=EStringBoolean)*
		public Group getGroup() { return cGroup; }

		//'@'
		public Keyword getCommercialAtKeyword_0() { return cCommercialAtKeyword_0; }

		//name=ExtendedID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//ExtendedID
		public RuleCall getNameExtendedIDParserRuleCall_1_0() { return cNameExtendedIDParserRuleCall_1_0; }

		//'['
		public Keyword getLeftSquareBracketKeyword_2() { return cLeftSquareBracketKeyword_2; }

		//type=ExtendedID
		public Assignment getTypeAssignment_3() { return cTypeAssignment_3; }

		//ExtendedID
		public RuleCall getTypeExtendedIDParserRuleCall_3_0() { return cTypeExtendedIDParserRuleCall_3_0; }

		//']'
		public Keyword getRightSquareBracketKeyword_4() { return cRightSquareBracketKeyword_4; }

		//values+=EStringBoolean
		public Assignment getValuesAssignment_5() { return cValuesAssignment_5; }

		//EStringBoolean
		public RuleCall getValuesEStringBooleanParserRuleCall_5_0() { return cValuesEStringBooleanParserRuleCall_5_0; }

		//(',' values+=EStringBoolean)*
		public Group getGroup_6() { return cGroup_6; }

		//','
		public Keyword getCommaKeyword_6_0() { return cCommaKeyword_6_0; }

		//values+=EStringBoolean
		public Assignment getValuesAssignment_6_1() { return cValuesAssignment_6_1; }

		//EStringBoolean
		public RuleCall getValuesEStringBooleanParserRuleCall_6_1_0() { return cValuesEStringBooleanParserRuleCall_6_1_0; }
	}

	public class QuotedKeyStringValueAnnotationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.annotations.Annotations.QuotedKeyStringValueAnnotation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cCommercialAtKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameExtendedIDParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Assignment cValuesAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cValuesSTRINGTerminalRuleCall_2_0 = (RuleCall)cValuesAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cCommaKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cValuesAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cValuesSTRINGTerminalRuleCall_3_1_0 = (RuleCall)cValuesAssignment_3_1.eContents().get(0);
		
		//// QuotedKeyStringValueAnnotation
		//// The quoted key string value annotation is a replacement derived grammars may use
		//// if they want to disallow quote-less strings in a key string annotation. 
		//QuotedKeyStringValueAnnotation StringAnnotation:
		//	'@' name=ExtendedID values+=STRING (',' values+=STRING)*
		@Override public ParserRule getRule() { return rule; }

		//'@' name=ExtendedID values+=STRING (',' values+=STRING)*
		public Group getGroup() { return cGroup; }

		//'@'
		public Keyword getCommercialAtKeyword_0() { return cCommercialAtKeyword_0; }

		//name=ExtendedID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//ExtendedID
		public RuleCall getNameExtendedIDParserRuleCall_1_0() { return cNameExtendedIDParserRuleCall_1_0; }

		//values+=STRING
		public Assignment getValuesAssignment_2() { return cValuesAssignment_2; }

		//STRING
		public RuleCall getValuesSTRINGTerminalRuleCall_2_0() { return cValuesSTRINGTerminalRuleCall_2_0; }

		//(',' values+=STRING)*
		public Group getGroup_3() { return cGroup_3; }

		//','
		public Keyword getCommaKeyword_3_0() { return cCommaKeyword_3_0; }

		//values+=STRING
		public Assignment getValuesAssignment_3_1() { return cValuesAssignment_3_1; }

		//STRING
		public RuleCall getValuesSTRINGTerminalRuleCall_3_1_0() { return cValuesSTRINGTerminalRuleCall_3_1_0; }
	}

	public class QuotedTypedKeyStringValueAnnotationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.annotations.Annotations.QuotedTypedKeyStringValueAnnotation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cCommercialAtKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameExtendedIDParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cTypeAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cTypeExtendedIDParserRuleCall_3_0 = (RuleCall)cTypeAssignment_3.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cValuesAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cValuesSTRINGTerminalRuleCall_5_0 = (RuleCall)cValuesAssignment_5.eContents().get(0);
		private final Group cGroup_6 = (Group)cGroup.eContents().get(6);
		private final Keyword cCommaKeyword_6_0 = (Keyword)cGroup_6.eContents().get(0);
		private final Assignment cValuesAssignment_6_1 = (Assignment)cGroup_6.eContents().get(1);
		private final RuleCall cValuesSTRINGTerminalRuleCall_6_1_0 = (RuleCall)cValuesAssignment_6_1.eContents().get(0);
		
		//// QuotedTypedKeyStringValueAnnotation
		//// The quoted typed key string value annotation is a replacement derived grammars may use
		//// if they want to disallow quote-less strings in a key string annotation. 
		//QuotedTypedKeyStringValueAnnotation TypedStringAnnotation:
		//	'@' name=ExtendedID '[' type=ExtendedID ']' values+=STRING (',' values+=STRING)*
		@Override public ParserRule getRule() { return rule; }

		//'@' name=ExtendedID '[' type=ExtendedID ']' values+=STRING (',' values+=STRING)*
		public Group getGroup() { return cGroup; }

		//'@'
		public Keyword getCommercialAtKeyword_0() { return cCommercialAtKeyword_0; }

		//name=ExtendedID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//ExtendedID
		public RuleCall getNameExtendedIDParserRuleCall_1_0() { return cNameExtendedIDParserRuleCall_1_0; }

		//'['
		public Keyword getLeftSquareBracketKeyword_2() { return cLeftSquareBracketKeyword_2; }

		//type=ExtendedID
		public Assignment getTypeAssignment_3() { return cTypeAssignment_3; }

		//ExtendedID
		public RuleCall getTypeExtendedIDParserRuleCall_3_0() { return cTypeExtendedIDParserRuleCall_3_0; }

		//']'
		public Keyword getRightSquareBracketKeyword_4() { return cRightSquareBracketKeyword_4; }

		//values+=STRING
		public Assignment getValuesAssignment_5() { return cValuesAssignment_5; }

		//STRING
		public RuleCall getValuesSTRINGTerminalRuleCall_5_0() { return cValuesSTRINGTerminalRuleCall_5_0; }

		//(',' values+=STRING)*
		public Group getGroup_6() { return cGroup_6; }

		//','
		public Keyword getCommaKeyword_6_0() { return cCommaKeyword_6_0; }

		//values+=STRING
		public Assignment getValuesAssignment_6_1() { return cValuesAssignment_6_1; }

		//STRING
		public RuleCall getValuesSTRINGTerminalRuleCall_6_1_0() { return cValuesSTRINGTerminalRuleCall_6_1_0; }
	}

	public class EStringElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.annotations.Annotations.EString");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cSTRINGTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cExtendedIDParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//// EString
		//// Allow strings without quotes if they don't contain spaces.
		//// For quoteless strings the ExtendedID rule is used.
		//EString:
		//	STRING | ExtendedID;
		@Override public ParserRule getRule() { return rule; }

		//STRING | ExtendedID
		public Alternatives getAlternatives() { return cAlternatives; }

		//STRING
		public RuleCall getSTRINGTerminalRuleCall_0() { return cSTRINGTerminalRuleCall_0; }

		//ExtendedID
		public RuleCall getExtendedIDParserRuleCall_1() { return cExtendedIDParserRuleCall_1; }
	}

	public class EStringBooleanElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.annotations.Annotations.EStringBoolean");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cSTRINGTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cExtendedIDParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cBOOLEANTerminalRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//EStringBoolean:
		//	STRING | ExtendedID | BOOLEAN;
		@Override public ParserRule getRule() { return rule; }

		//STRING | ExtendedID | BOOLEAN
		public Alternatives getAlternatives() { return cAlternatives; }

		//STRING
		public RuleCall getSTRINGTerminalRuleCall_0() { return cSTRINGTerminalRuleCall_0; }

		//ExtendedID
		public RuleCall getExtendedIDParserRuleCall_1() { return cExtendedIDParserRuleCall_1; }

		//BOOLEAN
		public RuleCall getBOOLEANTerminalRuleCall_2() { return cBOOLEANTerminalRuleCall_2; }
	}

	public class EStringAllTypesElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.annotations.Annotations.EStringAllTypes");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cSTRINGTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cExtendedIDParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cBOOLEANTerminalRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cIntegerParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cFloategerParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		
		//EStringAllTypes:
		//	STRING | ExtendedID | BOOLEAN | Integer | Floateger;
		@Override public ParserRule getRule() { return rule; }

		//STRING | ExtendedID | BOOLEAN | Integer | Floateger
		public Alternatives getAlternatives() { return cAlternatives; }

		//STRING
		public RuleCall getSTRINGTerminalRuleCall_0() { return cSTRINGTerminalRuleCall_0; }

		//ExtendedID
		public RuleCall getExtendedIDParserRuleCall_1() { return cExtendedIDParserRuleCall_1; }

		//BOOLEAN
		public RuleCall getBOOLEANTerminalRuleCall_2() { return cBOOLEANTerminalRuleCall_2; }

		//Integer
		public RuleCall getIntegerParserRuleCall_3() { return cIntegerParserRuleCall_3; }

		//Floateger
		public RuleCall getFloategerParserRuleCall_4() { return cFloategerParserRuleCall_4; }
	}

	public class ExtendedIDElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.annotations.Annotations.ExtendedID");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cIDTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cFullStopKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cIDTerminalRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cNumberSignKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final RuleCall cINTTerminalRuleCall_2_1 = (RuleCall)cGroup_2.eContents().get(1);
		
		//// ExtendedID
		//// ExtendedID extends the ID rule provided by the terminals grammar.
		//// An ID may have dot separated parts and may close with a number separated by a hash mark.
		//ExtendedID:
		//	ID ("." ID)* ("#" INT)?;
		@Override public ParserRule getRule() { return rule; }

		//ID ("." ID)* ("#" INT)?
		public Group getGroup() { return cGroup; }

		//ID
		public RuleCall getIDTerminalRuleCall_0() { return cIDTerminalRuleCall_0; }

		//("." ID)*
		public Group getGroup_1() { return cGroup_1; }

		//"."
		public Keyword getFullStopKeyword_1_0() { return cFullStopKeyword_1_0; }

		//ID
		public RuleCall getIDTerminalRuleCall_1_1() { return cIDTerminalRuleCall_1_1; }

		//("#" INT)?
		public Group getGroup_2() { return cGroup_2; }

		//"#"
		public Keyword getNumberSignKeyword_2_0() { return cNumberSignKeyword_2_0; }

		//INT
		public RuleCall getINTTerminalRuleCall_2_1() { return cINTTerminalRuleCall_2_1; }
	}

	public class QualifiedIDElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.annotations.Annotations.QualifiedID");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cIDTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cFullStopKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cIDTerminalRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		
		//QualifiedID:
		//	ID ("." ID)*;
		@Override public ParserRule getRule() { return rule; }

		//ID ("." ID)*
		public Group getGroup() { return cGroup; }

		//ID
		public RuleCall getIDTerminalRuleCall_0() { return cIDTerminalRuleCall_0; }

		//("." ID)*
		public Group getGroup_1() { return cGroup_1; }

		//"."
		public Keyword getFullStopKeyword_1_0() { return cFullStopKeyword_1_0; }

		//ID
		public RuleCall getIDTerminalRuleCall_1_1() { return cIDTerminalRuleCall_1_1; }
	}

	public class IntegerElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.annotations.Annotations.Integer");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cHyphenMinusKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cINTTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		//// Integer
		//// The integer rule extends the EInt terminal by an optional sign for negative numbers.
		//Integer ecore::EInt:
		//	'-'? INT
		@Override public ParserRule getRule() { return rule; }

		//'-'? INT
		public Group getGroup() { return cGroup; }

		//'-'?
		public Keyword getHyphenMinusKeyword_0() { return cHyphenMinusKeyword_0; }

		//INT
		public RuleCall getINTTerminalRuleCall_1() { return cINTTerminalRuleCall_1; }
	}

	public class FloategerElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.annotations.Annotations.Floateger");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cHyphenMinusKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cFLOATTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		//// Floateger
		//// The floateger rule extends the EFloat terminal by an optional sign for negative numbers.
		//Floateger ecore::EFloat:
		//	'-'? FLOAT
		@Override public ParserRule getRule() { return rule; }

		//'-'? FLOAT
		public Group getGroup() { return cGroup; }

		//'-'?
		public Keyword getHyphenMinusKeyword_0() { return cHyphenMinusKeyword_0; }

		//FLOAT
		public RuleCall getFLOATTerminalRuleCall_1() { return cFLOATTerminalRuleCall_1; }
	}
	
	
	private final AnnotationElements pAnnotation;
	private final PragmaAnnotationElements pPragmaAnnotation;
	private final ValuedAnnotationElements pValuedAnnotation;
	private final RestrictedTypeAnnotationElements pRestrictedTypeAnnotation;
	private final QuotedStringAnnotationElements pQuotedStringAnnotation;
	private final CommentAnnotationElements pCommentAnnotation;
	private final TagAnnotationElements pTagAnnotation;
	private final PragmaTagAnnotationElements pPragmaTagAnnotation;
	private final KeyStringValueAnnotationElements pKeyStringValueAnnotation;
	private final RestrictedKeyStringValueAnnotationElements pRestrictedKeyStringValueAnnotation;
	private final PramgaKeyStringValueAnnotationElements pPramgaKeyStringValueAnnotation;
	private final TypedKeyStringValueAnnotationElements pTypedKeyStringValueAnnotation;
	private final RestrictedTypedKeyStringValueAnnotationElements pRestrictedTypedKeyStringValueAnnotation;
	private final QuotedKeyStringValueAnnotationElements pQuotedKeyStringValueAnnotation;
	private final QuotedTypedKeyStringValueAnnotationElements pQuotedTypedKeyStringValueAnnotation;
	private final EStringElements pEString;
	private final EStringBooleanElements pEStringBoolean;
	private final EStringAllTypesElements pEStringAllTypes;
	private final ExtendedIDElements pExtendedID;
	private final QualifiedIDElements pQualifiedID;
	private final IntegerElements pInteger;
	private final FloategerElements pFloateger;
	private final TerminalRule tCOMMENT_ANNOTATION;
	private final TerminalRule tML_COMMENT;
	private final TerminalRule tNUMBER;
	private final TerminalRule tINT;
	private final TerminalRule tFLOAT;
	private final TerminalRule tBOOLEAN;
	private final TerminalRule tSTRING;
	
	private final Grammar grammar;

	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public AnnotationsGrammarAccess(GrammarProvider grammarProvider,
		TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pAnnotation = new AnnotationElements();
		this.pPragmaAnnotation = new PragmaAnnotationElements();
		this.pValuedAnnotation = new ValuedAnnotationElements();
		this.pRestrictedTypeAnnotation = new RestrictedTypeAnnotationElements();
		this.pQuotedStringAnnotation = new QuotedStringAnnotationElements();
		this.pCommentAnnotation = new CommentAnnotationElements();
		this.pTagAnnotation = new TagAnnotationElements();
		this.pPragmaTagAnnotation = new PragmaTagAnnotationElements();
		this.pKeyStringValueAnnotation = new KeyStringValueAnnotationElements();
		this.pRestrictedKeyStringValueAnnotation = new RestrictedKeyStringValueAnnotationElements();
		this.pPramgaKeyStringValueAnnotation = new PramgaKeyStringValueAnnotationElements();
		this.pTypedKeyStringValueAnnotation = new TypedKeyStringValueAnnotationElements();
		this.pRestrictedTypedKeyStringValueAnnotation = new RestrictedTypedKeyStringValueAnnotationElements();
		this.pQuotedKeyStringValueAnnotation = new QuotedKeyStringValueAnnotationElements();
		this.pQuotedTypedKeyStringValueAnnotation = new QuotedTypedKeyStringValueAnnotationElements();
		this.pEString = new EStringElements();
		this.pEStringBoolean = new EStringBooleanElements();
		this.pEStringAllTypes = new EStringAllTypesElements();
		this.pExtendedID = new ExtendedIDElements();
		this.pQualifiedID = new QualifiedIDElements();
		this.pInteger = new IntegerElements();
		this.pFloateger = new FloategerElements();
		this.tCOMMENT_ANNOTATION = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.annotations.Annotations.COMMENT_ANNOTATION");
		this.tML_COMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.annotations.Annotations.ML_COMMENT");
		this.tNUMBER = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.annotations.Annotations.NUMBER");
		this.tINT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.annotations.Annotations.INT");
		this.tFLOAT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.annotations.Annotations.FLOAT");
		this.tBOOLEAN = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.annotations.Annotations.BOOLEAN");
		this.tSTRING = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.annotations.Annotations.STRING");
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("de.cau.cs.kieler.annotations.Annotations".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	

	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	/// **
	// * @author ssm
	// * @kieler.design 2015-08-21 proposed 
	// * @kieler.rating 2015-08-21 proposed yellow
	// * / // ------------------ //
	////  Annotation Rules  // 
	//// ------------------ //
	//// General rule for annotations
	//// The different annotation sub rules are tested in order. Hence, order matters! 
	//Annotation:
	//	CommentAnnotation | KeyStringValueAnnotation | TypedKeyStringValueAnnotation | TagAnnotation;
	public AnnotationElements getAnnotationAccess() {
		return pAnnotation;
	}
	
	public ParserRule getAnnotationRule() {
		return getAnnotationAccess().getRule();
	}

	//// General rule for pragmas
	//// We only have string and tag pragmas.    
	//PragmaAnnotation Annotation:
	//	PramgaKeyStringValueAnnotation | PragmaTagAnnotation
	public PragmaAnnotationElements getPragmaAnnotationAccess() {
		return pPragmaAnnotation;
	}
	
	public ParserRule getPragmaAnnotationRule() {
		return getPragmaAnnotationAccess().getRule();
	}

	//// Valued Annotation Rule
	//// Valued annotations must have a value. For instance, tag annotations are not allowed.
	//// Derived grammars may use this rule if the general annotation rules compromises the grammar
	//// due to ambiguities.
	//ValuedAnnotation Annotation:
	//	CommentAnnotation | KeyStringValueAnnotation | TypedKeyStringValueAnnotation
	public ValuedAnnotationElements getValuedAnnotationAccess() {
		return pValuedAnnotation;
	}
	
	public ParserRule getValuedAnnotationRule() {
		return getValuedAnnotationAccess().getRule();
	}

	//// Restricted Type Annotation Rule
	//// The restricted type annotation rule does not allow typed string annotations. 
	//// You can use this rule in derived grammars if you don't want to permit typed strings. 
	//RestrictedTypeAnnotation Annotation:
	//	CommentAnnotation | RestrictedKeyStringValueAnnotation | RestrictedTypedKeyStringValueAnnotation | TagAnnotation
	public RestrictedTypeAnnotationElements getRestrictedTypeAnnotationAccess() {
		return pRestrictedTypeAnnotation;
	}
	
	public ParserRule getRestrictedTypeAnnotationRule() {
		return getRestrictedTypeAnnotationAccess().getRule();
	}

	//// Quoted String Annotation Rule
	//// The quoted string annotation rules uses quoted key string annotations. You can use this rule in 
	//// derived grammars if you don't want to permit unquoted strings. 
	//// (If you are looking for an example, the keffects grammar uses this rule for their emission
	//// rule and to avoid grammar ambiguities.)  
	//QuotedStringAnnotation Annotation:
	//	CommentAnnotation | QuotedKeyStringValueAnnotation | QuotedTypedKeyStringValueAnnotation | TagAnnotation
	public QuotedStringAnnotationElements getQuotedStringAnnotationAccess() {
		return pQuotedStringAnnotation;
	}
	
	public ParserRule getQuotedStringAnnotationRule() {
		return getQuotedStringAnnotationAccess().getRule();
	}

	//// CommentAnnotation
	//// e.g.: / ** semantic comment * /
	//CommentAnnotation:
	//	values+=COMMENT_ANNOTATION;
	public CommentAnnotationElements getCommentAnnotationAccess() {
		return pCommentAnnotation;
	}
	
	public ParserRule getCommentAnnotationRule() {
		return getCommentAnnotationAccess().getRule();
	}

	//// TagAnnotation
	//// e.g.: @HVlayout
	//TagAnnotation Annotation:
	//	'@' name=ExtendedID
	public TagAnnotationElements getTagAnnotationAccess() {
		return pTagAnnotation;
	}
	
	public ParserRule getTagAnnotationRule() {
		return getTagAnnotationAccess().getRule();
	}

	//PragmaTagAnnotation PragmaAnnotation:
	//	'#' name=ExtendedID
	public PragmaTagAnnotationElements getPragmaTagAnnotationAccess() {
		return pPragmaTagAnnotation;
	}
	
	public ParserRule getPragmaTagAnnotationRule() {
		return getPragmaTagAnnotationAccess().getRule();
	}

	//// KeyStringValueAnnotation
	//// e.g.: @layouter dot
	//// You may separate different values via comma.   
	//KeyStringValueAnnotation StringAnnotation:
	//	'@' name=ExtendedID values+=EStringAllTypes (',' values+=EStringAllTypes)*
	public KeyStringValueAnnotationElements getKeyStringValueAnnotationAccess() {
		return pKeyStringValueAnnotation;
	}
	
	public ParserRule getKeyStringValueAnnotationRule() {
		return getKeyStringValueAnnotationAccess().getRule();
	}

	//RestrictedKeyStringValueAnnotation StringAnnotation:
	//	'@' name=ExtendedID values+=EStringBoolean (',' values+=EStringBoolean)*
	public RestrictedKeyStringValueAnnotationElements getRestrictedKeyStringValueAnnotationAccess() {
		return pRestrictedKeyStringValueAnnotation;
	}
	
	public ParserRule getRestrictedKeyStringValueAnnotationRule() {
		return getRestrictedKeyStringValueAnnotationAccess().getRule();
	}

	//PramgaKeyStringValueAnnotation PragmaStringAnnotation:
	//	'#' name=ExtendedID values+=EStringAllTypes (',' values+=EStringAllTypes)*
	public PramgaKeyStringValueAnnotationElements getPramgaKeyStringValueAnnotationAccess() {
		return pPramgaKeyStringValueAnnotation;
	}
	
	public ParserRule getPramgaKeyStringValueAnnotationRule() {
		return getPramgaKeyStringValueAnnotationAccess().getRule();
	}

	//// TypedKeyStringValueAnnotation
	//// e.g.: @position[de.cau.cs.kieler.core.math.KVector] "(3,2)"
	//TypedKeyStringValueAnnotation TypedStringAnnotation:
	//	'@' name=ExtendedID '[' type=ExtendedID ']' values+=EStringAllTypes (',' values+=EStringAllTypes)*
	public TypedKeyStringValueAnnotationElements getTypedKeyStringValueAnnotationAccess() {
		return pTypedKeyStringValueAnnotation;
	}
	
	public ParserRule getTypedKeyStringValueAnnotationRule() {
		return getTypedKeyStringValueAnnotationAccess().getRule();
	}

	//RestrictedTypedKeyStringValueAnnotation TypedStringAnnotation:
	//	'@' name=ExtendedID '[' type=ExtendedID ']' values+=EStringBoolean (',' values+=EStringBoolean)*
	public RestrictedTypedKeyStringValueAnnotationElements getRestrictedTypedKeyStringValueAnnotationAccess() {
		return pRestrictedTypedKeyStringValueAnnotation;
	}
	
	public ParserRule getRestrictedTypedKeyStringValueAnnotationRule() {
		return getRestrictedTypedKeyStringValueAnnotationAccess().getRule();
	}

	//// QuotedKeyStringValueAnnotation
	//// The quoted key string value annotation is a replacement derived grammars may use
	//// if they want to disallow quote-less strings in a key string annotation. 
	//QuotedKeyStringValueAnnotation StringAnnotation:
	//	'@' name=ExtendedID values+=STRING (',' values+=STRING)*
	public QuotedKeyStringValueAnnotationElements getQuotedKeyStringValueAnnotationAccess() {
		return pQuotedKeyStringValueAnnotation;
	}
	
	public ParserRule getQuotedKeyStringValueAnnotationRule() {
		return getQuotedKeyStringValueAnnotationAccess().getRule();
	}

	//// QuotedTypedKeyStringValueAnnotation
	//// The quoted typed key string value annotation is a replacement derived grammars may use
	//// if they want to disallow quote-less strings in a key string annotation. 
	//QuotedTypedKeyStringValueAnnotation TypedStringAnnotation:
	//	'@' name=ExtendedID '[' type=ExtendedID ']' values+=STRING (',' values+=STRING)*
	public QuotedTypedKeyStringValueAnnotationElements getQuotedTypedKeyStringValueAnnotationAccess() {
		return pQuotedTypedKeyStringValueAnnotation;
	}
	
	public ParserRule getQuotedTypedKeyStringValueAnnotationRule() {
		return getQuotedTypedKeyStringValueAnnotationAccess().getRule();
	}

	//// EString
	//// Allow strings without quotes if they don't contain spaces.
	//// For quoteless strings the ExtendedID rule is used.
	//EString:
	//	STRING | ExtendedID;
	public EStringElements getEStringAccess() {
		return pEString;
	}
	
	public ParserRule getEStringRule() {
		return getEStringAccess().getRule();
	}

	//EStringBoolean:
	//	STRING | ExtendedID | BOOLEAN;
	public EStringBooleanElements getEStringBooleanAccess() {
		return pEStringBoolean;
	}
	
	public ParserRule getEStringBooleanRule() {
		return getEStringBooleanAccess().getRule();
	}

	//EStringAllTypes:
	//	STRING | ExtendedID | BOOLEAN | Integer | Floateger;
	public EStringAllTypesElements getEStringAllTypesAccess() {
		return pEStringAllTypes;
	}
	
	public ParserRule getEStringAllTypesRule() {
		return getEStringAllTypesAccess().getRule();
	}

	//// ExtendedID
	//// ExtendedID extends the ID rule provided by the terminals grammar.
	//// An ID may have dot separated parts and may close with a number separated by a hash mark.
	//ExtendedID:
	//	ID ("." ID)* ("#" INT)?;
	public ExtendedIDElements getExtendedIDAccess() {
		return pExtendedID;
	}
	
	public ParserRule getExtendedIDRule() {
		return getExtendedIDAccess().getRule();
	}

	//QualifiedID:
	//	ID ("." ID)*;
	public QualifiedIDElements getQualifiedIDAccess() {
		return pQualifiedID;
	}
	
	public ParserRule getQualifiedIDRule() {
		return getQualifiedIDAccess().getRule();
	}

	//// Integer
	//// The integer rule extends the EInt terminal by an optional sign for negative numbers.
	//Integer ecore::EInt:
	//	'-'? INT
	public IntegerElements getIntegerAccess() {
		return pInteger;
	}
	
	public ParserRule getIntegerRule() {
		return getIntegerAccess().getRule();
	}

	//// Floateger
	//// The floateger rule extends the EFloat terminal by an optional sign for negative numbers.
	//Floateger ecore::EFloat:
	//	'-'? FLOAT
	public FloategerElements getFloategerAccess() {
		return pFloateger;
	}
	
	public ParserRule getFloategerRule() {
		return getFloategerAccess().getRule();
	}

	//terminal COMMENT_ANNOTATION:
	//	'/ **'->'* /';
	public TerminalRule getCOMMENT_ANNOTATIONRule() {
		return tCOMMENT_ANNOTATION;
	} 

	//terminal ML_COMMENT:
	//	'/ *' !'*'->'* /';
	public TerminalRule getML_COMMENTRule() {
		return tML_COMMENT;
	} 

	//terminal fragment NUMBER:
	//	'0'..'9';
	public TerminalRule getNUMBERRule() {
		return tNUMBER;
	} 

	//terminal INT returns ecore::EInt:
	//	NUMBER+;
	public TerminalRule getINTRule() {
		return tINT;
	} 

	//terminal FLOAT returns ecore::EFloatObject:
	//	NUMBER+ ('.' NUMBER*) (("e" | "E") ("+" | "-")? NUMBER+)? 'f'? | NUMBER+ 'f';
	public TerminalRule getFLOATRule() {
		return tFLOAT;
	} 

	//terminal BOOLEAN returns ecore::EBooleanObject:
	//	'true' | 'false';
	public TerminalRule getBOOLEANRule() {
		return tBOOLEAN;
	} 

	//terminal STRING:
	//	'"' ('\\' ('b' | 't' | 'n' | 'f' | 'r' | '"' | "'" | '\\') | !('\\' | '"'))* '"';
	public TerminalRule getSTRINGRule() {
		return tSTRING;
	} 

	//terminal ID:
	//	'^'? ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	} 

	//terminal SL_COMMENT:
	//	'//' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	} 

	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	} 

	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	} 
}
