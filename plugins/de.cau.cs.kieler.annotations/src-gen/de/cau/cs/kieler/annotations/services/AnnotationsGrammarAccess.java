/*
 * generated by Xtext
 */
package de.cau.cs.kieler.annotations.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.common.services.TerminalsGrammarAccess;
import org.eclipse.xtext.service.AbstractElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class AnnotationsGrammarAccess extends AbstractElementFinder.AbstractGrammarElementFinder {
	
	public class AnnotationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.annotations.Annotations.Annotation");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cCommentAnnotationParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cKeyStringValueAnnotationParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cTypedKeyStringValueAnnotationParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cTagAnnotationParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		///**
		// * @author ssm
		// * @kieler.design 2015-08-21 proposed
		// * @kieler.rating 2015-08-21 proposed yellow
		// */
		//// ------------------ //
		////  Annotation Rules  //
		//// ------------------ //
		//// General rule for annotations
		//// The different annotation sub rules are tested in order. Hence, order matters!
		//Annotation returns Annotation:
		//    CommentAnnotation |
		//    KeyStringValueAnnotation |
		//    TypedKeyStringValueAnnotation |
		//    TagAnnotation;
		@Override public ParserRule getRule() { return rule; }
		
		//CommentAnnotation |
		//KeyStringValueAnnotation |
		//TypedKeyStringValueAnnotation |
		//TagAnnotation
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//CommentAnnotation
		public RuleCall getCommentAnnotationParserRuleCall_0() { return cCommentAnnotationParserRuleCall_0; }
		
		//KeyStringValueAnnotation
		public RuleCall getKeyStringValueAnnotationParserRuleCall_1() { return cKeyStringValueAnnotationParserRuleCall_1; }
		
		//TypedKeyStringValueAnnotation
		public RuleCall getTypedKeyStringValueAnnotationParserRuleCall_2() { return cTypedKeyStringValueAnnotationParserRuleCall_2; }
		
		//TagAnnotation
		public RuleCall getTagAnnotationParserRuleCall_3() { return cTagAnnotationParserRuleCall_3; }
	}
	public class PragmaElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.annotations.Annotations.Pragma");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cStringPragmaParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cPragmaTagParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//// General rule for pragmas
		//// We only have string and tag pragmas.
		//Pragma returns Pragma:
		//    StringPragma |
		//    PragmaTag;
		@Override public ParserRule getRule() { return rule; }
		
		//StringPragma |
		//PragmaTag
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//StringPragma
		public RuleCall getStringPragmaParserRuleCall_0() { return cStringPragmaParserRuleCall_0; }
		
		//PragmaTag
		public RuleCall getPragmaTagParserRuleCall_1() { return cPragmaTagParserRuleCall_1; }
	}
	public class ValuedAnnotationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.annotations.Annotations.ValuedAnnotation");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cCommentAnnotationParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cKeyStringValueAnnotationParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cTypedKeyStringValueAnnotationParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//// Valued Annotation Rule
		//// Valued annotations must have a value. For instance, tag annotations are not allowed.
		//// Derived grammars may use this rule if the general annotation rules compromises the grammar
		//// due to ambiguities.
		//ValuedAnnotation returns Annotation:
		//    CommentAnnotation |
		//    KeyStringValueAnnotation |
		//    TypedKeyStringValueAnnotation;
		@Override public ParserRule getRule() { return rule; }
		
		//CommentAnnotation |
		//KeyStringValueAnnotation |
		//TypedKeyStringValueAnnotation
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//CommentAnnotation
		public RuleCall getCommentAnnotationParserRuleCall_0() { return cCommentAnnotationParserRuleCall_0; }
		
		//KeyStringValueAnnotation
		public RuleCall getKeyStringValueAnnotationParserRuleCall_1() { return cKeyStringValueAnnotationParserRuleCall_1; }
		
		//TypedKeyStringValueAnnotation
		public RuleCall getTypedKeyStringValueAnnotationParserRuleCall_2() { return cTypedKeyStringValueAnnotationParserRuleCall_2; }
	}
	public class RestrictedTypeAnnotationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.annotations.Annotations.RestrictedTypeAnnotation");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cCommentAnnotationParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cRestrictedKeyStringValueAnnotationParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cRestrictedTypedKeyStringValueAnnotationParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cTagAnnotationParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//// Restricted Type Annotation Rule
		//// The restricted type annotation rule does not allow typed string annotations.
		//// You can use this rule in derived grammars if you don't want to permit typed strings.
		//RestrictedTypeAnnotation returns Annotation:
		//    CommentAnnotation |
		//    RestrictedKeyStringValueAnnotation |
		//    RestrictedTypedKeyStringValueAnnotation |
		//    TagAnnotation;
		@Override public ParserRule getRule() { return rule; }
		
		//CommentAnnotation |
		//RestrictedKeyStringValueAnnotation |
		//RestrictedTypedKeyStringValueAnnotation |
		//TagAnnotation
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//CommentAnnotation
		public RuleCall getCommentAnnotationParserRuleCall_0() { return cCommentAnnotationParserRuleCall_0; }
		
		//RestrictedKeyStringValueAnnotation
		public RuleCall getRestrictedKeyStringValueAnnotationParserRuleCall_1() { return cRestrictedKeyStringValueAnnotationParserRuleCall_1; }
		
		//RestrictedTypedKeyStringValueAnnotation
		public RuleCall getRestrictedTypedKeyStringValueAnnotationParserRuleCall_2() { return cRestrictedTypedKeyStringValueAnnotationParserRuleCall_2; }
		
		//TagAnnotation
		public RuleCall getTagAnnotationParserRuleCall_3() { return cTagAnnotationParserRuleCall_3; }
	}
	public class QuotedStringAnnotationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.annotations.Annotations.QuotedStringAnnotation");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cCommentAnnotationParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cQuotedKeyStringValueAnnotationParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cQuotedTypedKeyStringValueAnnotationParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cTagAnnotationParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//// Quoted String Annotation Rule
		//// The quoted string annotation rules uses quoted key string annotations. You can use this rule in
		//// derived grammars if you don't want to permit unquoted strings.
		//// (If you are looking for an example, the keffects grammar uses this rule for their emission
		//// rule and to avoid grammar ambiguities.)
		//QuotedStringAnnotation returns Annotation:
		//    CommentAnnotation |
		//    QuotedKeyStringValueAnnotation |
		//    QuotedTypedKeyStringValueAnnotation |
		//    TagAnnotation;
		@Override public ParserRule getRule() { return rule; }
		
		//CommentAnnotation |
		//QuotedKeyStringValueAnnotation |
		//QuotedTypedKeyStringValueAnnotation |
		//TagAnnotation
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//CommentAnnotation
		public RuleCall getCommentAnnotationParserRuleCall_0() { return cCommentAnnotationParserRuleCall_0; }
		
		//QuotedKeyStringValueAnnotation
		public RuleCall getQuotedKeyStringValueAnnotationParserRuleCall_1() { return cQuotedKeyStringValueAnnotationParserRuleCall_1; }
		
		//QuotedTypedKeyStringValueAnnotation
		public RuleCall getQuotedTypedKeyStringValueAnnotationParserRuleCall_2() { return cQuotedTypedKeyStringValueAnnotationParserRuleCall_2; }
		
		//TagAnnotation
		public RuleCall getTagAnnotationParserRuleCall_3() { return cTagAnnotationParserRuleCall_3; }
	}
	public class CommentAnnotationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.annotations.Annotations.CommentAnnotation");
		private final Assignment cValuesAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValuesCOMMENT_ANNOTATIONTerminalRuleCall_0 = (RuleCall)cValuesAssignment.eContents().get(0);
		
		//// CommentAnnotation
		//// e.g.: /** semantic comment */
		//CommentAnnotation returns CommentAnnotation:
		//    values += COMMENT_ANNOTATION;
		@Override public ParserRule getRule() { return rule; }
		
		//values += COMMENT_ANNOTATION
		public Assignment getValuesAssignment() { return cValuesAssignment; }
		
		//COMMENT_ANNOTATION
		public RuleCall getValuesCOMMENT_ANNOTATIONTerminalRuleCall_0() { return cValuesCOMMENT_ANNOTATIONTerminalRuleCall_0; }
	}
	public class CommentAnnotatonSLElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.annotations.Annotations.CommentAnnotatonSL");
		private final Assignment cValuesAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValuesSL_COMMENT_ANNOTATIONTerminalRuleCall_0 = (RuleCall)cValuesAssignment.eContents().get(0);
		
		//CommentAnnotatonSL returns CommentAnnotation:
		//    values += SL_COMMENT_ANNOTATION;
		@Override public ParserRule getRule() { return rule; }
		
		//values += SL_COMMENT_ANNOTATION
		public Assignment getValuesAssignment() { return cValuesAssignment; }
		
		//SL_COMMENT_ANNOTATION
		public RuleCall getValuesSL_COMMENT_ANNOTATIONTerminalRuleCall_0() { return cValuesSL_COMMENT_ANNOTATIONTerminalRuleCall_0; }
	}
	public class TagAnnotationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.annotations.Annotations.TagAnnotation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cCommercialAtKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameExtendedIDParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		
		//// TagAnnotation
		//// e.g.: @HVlayout
		//TagAnnotation returns TagAnnotation:
		//    '@' name=ExtendedID;
		@Override public ParserRule getRule() { return rule; }
		
		//'@' name=ExtendedID
		public Group getGroup() { return cGroup; }
		
		//'@'
		public Keyword getCommercialAtKeyword_0() { return cCommercialAtKeyword_0; }
		
		//name=ExtendedID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ExtendedID
		public RuleCall getNameExtendedIDParserRuleCall_1_0() { return cNameExtendedIDParserRuleCall_1_0; }
	}
	public class PragmaTagElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.annotations.Annotations.PragmaTag");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cNumberSignKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameExtendedIDParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		
		//PragmaTag returns Pragma:
		//    '#' name=ExtendedID;
		@Override public ParserRule getRule() { return rule; }
		
		//'#' name=ExtendedID
		public Group getGroup() { return cGroup; }
		
		//'#'
		public Keyword getNumberSignKeyword_0() { return cNumberSignKeyword_0; }
		
		//name=ExtendedID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ExtendedID
		public RuleCall getNameExtendedIDParserRuleCall_1_0() { return cNameExtendedIDParserRuleCall_1_0; }
	}
	public class KeyStringValueAnnotationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.annotations.Annotations.KeyStringValueAnnotation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cCommercialAtKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameExtendedIDParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Assignment cValuesAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cValuesEStringAllTypesParserRuleCall_2_0 = (RuleCall)cValuesAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cCommaKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cValuesAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cValuesEStringAllTypesParserRuleCall_3_1_0 = (RuleCall)cValuesAssignment_3_1.eContents().get(0);
		
		//// KeyStringValueAnnotation
		//// e.g.: @layouter dot
		//// You may separate different values via comma.
		//KeyStringValueAnnotation returns StringAnnotation:
		//    '@' name=ExtendedID values += EStringAllTypes (',' values += EStringAllTypes)*;
		@Override public ParserRule getRule() { return rule; }
		
		//'@' name=ExtendedID values += EStringAllTypes (',' values += EStringAllTypes)*
		public Group getGroup() { return cGroup; }
		
		//'@'
		public Keyword getCommercialAtKeyword_0() { return cCommercialAtKeyword_0; }
		
		//name=ExtendedID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ExtendedID
		public RuleCall getNameExtendedIDParserRuleCall_1_0() { return cNameExtendedIDParserRuleCall_1_0; }
		
		//values += EStringAllTypes
		public Assignment getValuesAssignment_2() { return cValuesAssignment_2; }
		
		//EStringAllTypes
		public RuleCall getValuesEStringAllTypesParserRuleCall_2_0() { return cValuesEStringAllTypesParserRuleCall_2_0; }
		
		//(',' values += EStringAllTypes)*
		public Group getGroup_3() { return cGroup_3; }
		
		//','
		public Keyword getCommaKeyword_3_0() { return cCommaKeyword_3_0; }
		
		//values += EStringAllTypes
		public Assignment getValuesAssignment_3_1() { return cValuesAssignment_3_1; }
		
		//EStringAllTypes
		public RuleCall getValuesEStringAllTypesParserRuleCall_3_1_0() { return cValuesEStringAllTypesParserRuleCall_3_1_0; }
	}
	public class RestrictedKeyStringValueAnnotationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.annotations.Annotations.RestrictedKeyStringValueAnnotation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cCommercialAtKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameExtendedIDParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Assignment cValuesAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cValuesEStringBooleanParserRuleCall_2_0 = (RuleCall)cValuesAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cCommaKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cValuesAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cValuesEStringBooleanParserRuleCall_3_1_0 = (RuleCall)cValuesAssignment_3_1.eContents().get(0);
		
		//RestrictedKeyStringValueAnnotation returns StringAnnotation:
		//    '@' name=ExtendedID values += EStringBoolean (',' values += EStringBoolean)*;
		@Override public ParserRule getRule() { return rule; }
		
		//'@' name=ExtendedID values += EStringBoolean (',' values += EStringBoolean)*
		public Group getGroup() { return cGroup; }
		
		//'@'
		public Keyword getCommercialAtKeyword_0() { return cCommercialAtKeyword_0; }
		
		//name=ExtendedID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ExtendedID
		public RuleCall getNameExtendedIDParserRuleCall_1_0() { return cNameExtendedIDParserRuleCall_1_0; }
		
		//values += EStringBoolean
		public Assignment getValuesAssignment_2() { return cValuesAssignment_2; }
		
		//EStringBoolean
		public RuleCall getValuesEStringBooleanParserRuleCall_2_0() { return cValuesEStringBooleanParserRuleCall_2_0; }
		
		//(',' values += EStringBoolean)*
		public Group getGroup_3() { return cGroup_3; }
		
		//','
		public Keyword getCommaKeyword_3_0() { return cCommaKeyword_3_0; }
		
		//values += EStringBoolean
		public Assignment getValuesAssignment_3_1() { return cValuesAssignment_3_1; }
		
		//EStringBoolean
		public RuleCall getValuesEStringBooleanParserRuleCall_3_1_0() { return cValuesEStringBooleanParserRuleCall_3_1_0; }
	}
	public class StringPragmaElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.annotations.Annotations.StringPragma");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cNumberSignKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameExtendedIDParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Assignment cValuesAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cValuesEStringAllTypesParserRuleCall_2_0 = (RuleCall)cValuesAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cCommaKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cValuesAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cValuesEStringAllTypesParserRuleCall_3_1_0 = (RuleCall)cValuesAssignment_3_1.eContents().get(0);
		
		//StringPragma returns StringPragma:
		//    '#' name=ExtendedID values += EStringAllTypes (',' values += EStringAllTypes)*;
		@Override public ParserRule getRule() { return rule; }
		
		//'#' name=ExtendedID values += EStringAllTypes (',' values += EStringAllTypes)*
		public Group getGroup() { return cGroup; }
		
		//'#'
		public Keyword getNumberSignKeyword_0() { return cNumberSignKeyword_0; }
		
		//name=ExtendedID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ExtendedID
		public RuleCall getNameExtendedIDParserRuleCall_1_0() { return cNameExtendedIDParserRuleCall_1_0; }
		
		//values += EStringAllTypes
		public Assignment getValuesAssignment_2() { return cValuesAssignment_2; }
		
		//EStringAllTypes
		public RuleCall getValuesEStringAllTypesParserRuleCall_2_0() { return cValuesEStringAllTypesParserRuleCall_2_0; }
		
		//(',' values += EStringAllTypes)*
		public Group getGroup_3() { return cGroup_3; }
		
		//','
		public Keyword getCommaKeyword_3_0() { return cCommaKeyword_3_0; }
		
		//values += EStringAllTypes
		public Assignment getValuesAssignment_3_1() { return cValuesAssignment_3_1; }
		
		//EStringAllTypes
		public RuleCall getValuesEStringAllTypesParserRuleCall_3_1_0() { return cValuesEStringAllTypesParserRuleCall_3_1_0; }
	}
	public class TypedKeyStringValueAnnotationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.annotations.Annotations.TypedKeyStringValueAnnotation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cCommercialAtKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameExtendedIDParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cTypeAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cTypeExtendedIDParserRuleCall_3_0 = (RuleCall)cTypeAssignment_3.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cValuesAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cValuesEStringAllTypesParserRuleCall_5_0 = (RuleCall)cValuesAssignment_5.eContents().get(0);
		private final Group cGroup_6 = (Group)cGroup.eContents().get(6);
		private final Keyword cCommaKeyword_6_0 = (Keyword)cGroup_6.eContents().get(0);
		private final Assignment cValuesAssignment_6_1 = (Assignment)cGroup_6.eContents().get(1);
		private final RuleCall cValuesEStringAllTypesParserRuleCall_6_1_0 = (RuleCall)cValuesAssignment_6_1.eContents().get(0);
		
		//// TypedKeyStringValueAnnotation
		//// e.g.: @position[de.cau.cs.kieler.core.math.KVector] "(3,2)"
		//TypedKeyStringValueAnnotation returns TypedStringAnnotation:
		//    '@' name=ExtendedID '[' type=ExtendedID ']' values += EStringAllTypes (',' values += EStringAllTypes)*;
		@Override public ParserRule getRule() { return rule; }
		
		//'@' name=ExtendedID '[' type=ExtendedID ']' values += EStringAllTypes (',' values += EStringAllTypes)*
		public Group getGroup() { return cGroup; }
		
		//'@'
		public Keyword getCommercialAtKeyword_0() { return cCommercialAtKeyword_0; }
		
		//name=ExtendedID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ExtendedID
		public RuleCall getNameExtendedIDParserRuleCall_1_0() { return cNameExtendedIDParserRuleCall_1_0; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_2() { return cLeftSquareBracketKeyword_2; }
		
		//type=ExtendedID
		public Assignment getTypeAssignment_3() { return cTypeAssignment_3; }
		
		//ExtendedID
		public RuleCall getTypeExtendedIDParserRuleCall_3_0() { return cTypeExtendedIDParserRuleCall_3_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_4() { return cRightSquareBracketKeyword_4; }
		
		//values += EStringAllTypes
		public Assignment getValuesAssignment_5() { return cValuesAssignment_5; }
		
		//EStringAllTypes
		public RuleCall getValuesEStringAllTypesParserRuleCall_5_0() { return cValuesEStringAllTypesParserRuleCall_5_0; }
		
		//(',' values += EStringAllTypes)*
		public Group getGroup_6() { return cGroup_6; }
		
		//','
		public Keyword getCommaKeyword_6_0() { return cCommaKeyword_6_0; }
		
		//values += EStringAllTypes
		public Assignment getValuesAssignment_6_1() { return cValuesAssignment_6_1; }
		
		//EStringAllTypes
		public RuleCall getValuesEStringAllTypesParserRuleCall_6_1_0() { return cValuesEStringAllTypesParserRuleCall_6_1_0; }
	}
	public class RestrictedTypedKeyStringValueAnnotationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.annotations.Annotations.RestrictedTypedKeyStringValueAnnotation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cCommercialAtKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameExtendedIDParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cTypeAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cTypeExtendedIDParserRuleCall_3_0 = (RuleCall)cTypeAssignment_3.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cValuesAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cValuesEStringBooleanParserRuleCall_5_0 = (RuleCall)cValuesAssignment_5.eContents().get(0);
		private final Group cGroup_6 = (Group)cGroup.eContents().get(6);
		private final Keyword cCommaKeyword_6_0 = (Keyword)cGroup_6.eContents().get(0);
		private final Assignment cValuesAssignment_6_1 = (Assignment)cGroup_6.eContents().get(1);
		private final RuleCall cValuesEStringBooleanParserRuleCall_6_1_0 = (RuleCall)cValuesAssignment_6_1.eContents().get(0);
		
		//RestrictedTypedKeyStringValueAnnotation returns TypedStringAnnotation:
		//    '@' name=ExtendedID '[' type=ExtendedID ']' values += EStringBoolean (',' values += EStringBoolean)*;
		@Override public ParserRule getRule() { return rule; }
		
		//'@' name=ExtendedID '[' type=ExtendedID ']' values += EStringBoolean (',' values += EStringBoolean)*
		public Group getGroup() { return cGroup; }
		
		//'@'
		public Keyword getCommercialAtKeyword_0() { return cCommercialAtKeyword_0; }
		
		//name=ExtendedID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ExtendedID
		public RuleCall getNameExtendedIDParserRuleCall_1_0() { return cNameExtendedIDParserRuleCall_1_0; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_2() { return cLeftSquareBracketKeyword_2; }
		
		//type=ExtendedID
		public Assignment getTypeAssignment_3() { return cTypeAssignment_3; }
		
		//ExtendedID
		public RuleCall getTypeExtendedIDParserRuleCall_3_0() { return cTypeExtendedIDParserRuleCall_3_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_4() { return cRightSquareBracketKeyword_4; }
		
		//values += EStringBoolean
		public Assignment getValuesAssignment_5() { return cValuesAssignment_5; }
		
		//EStringBoolean
		public RuleCall getValuesEStringBooleanParserRuleCall_5_0() { return cValuesEStringBooleanParserRuleCall_5_0; }
		
		//(',' values += EStringBoolean)*
		public Group getGroup_6() { return cGroup_6; }
		
		//','
		public Keyword getCommaKeyword_6_0() { return cCommaKeyword_6_0; }
		
		//values += EStringBoolean
		public Assignment getValuesAssignment_6_1() { return cValuesAssignment_6_1; }
		
		//EStringBoolean
		public RuleCall getValuesEStringBooleanParserRuleCall_6_1_0() { return cValuesEStringBooleanParserRuleCall_6_1_0; }
	}
	public class QuotedKeyStringValueAnnotationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.annotations.Annotations.QuotedKeyStringValueAnnotation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cCommercialAtKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameExtendedIDParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Assignment cValuesAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cValuesSTRINGTerminalRuleCall_2_0 = (RuleCall)cValuesAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cCommaKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cValuesAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cValuesSTRINGTerminalRuleCall_3_1_0 = (RuleCall)cValuesAssignment_3_1.eContents().get(0);
		
		//// QuotedKeyStringValueAnnotation
		//// The quoted key string value annotation is a replacement derived grammars may use
		//// if they want to disallow quote-less strings in a key string annotation.
		//QuotedKeyStringValueAnnotation returns StringAnnotation:
		//    '@' name=ExtendedID values += STRING (',' values += STRING)*;
		@Override public ParserRule getRule() { return rule; }
		
		//'@' name=ExtendedID values += STRING (',' values += STRING)*
		public Group getGroup() { return cGroup; }
		
		//'@'
		public Keyword getCommercialAtKeyword_0() { return cCommercialAtKeyword_0; }
		
		//name=ExtendedID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ExtendedID
		public RuleCall getNameExtendedIDParserRuleCall_1_0() { return cNameExtendedIDParserRuleCall_1_0; }
		
		//values += STRING
		public Assignment getValuesAssignment_2() { return cValuesAssignment_2; }
		
		//STRING
		public RuleCall getValuesSTRINGTerminalRuleCall_2_0() { return cValuesSTRINGTerminalRuleCall_2_0; }
		
		//(',' values += STRING)*
		public Group getGroup_3() { return cGroup_3; }
		
		//','
		public Keyword getCommaKeyword_3_0() { return cCommaKeyword_3_0; }
		
		//values += STRING
		public Assignment getValuesAssignment_3_1() { return cValuesAssignment_3_1; }
		
		//STRING
		public RuleCall getValuesSTRINGTerminalRuleCall_3_1_0() { return cValuesSTRINGTerminalRuleCall_3_1_0; }
	}
	public class QuotedTypedKeyStringValueAnnotationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.annotations.Annotations.QuotedTypedKeyStringValueAnnotation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cCommercialAtKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameExtendedIDParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cTypeAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cTypeExtendedIDParserRuleCall_3_0 = (RuleCall)cTypeAssignment_3.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cValuesAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cValuesSTRINGTerminalRuleCall_5_0 = (RuleCall)cValuesAssignment_5.eContents().get(0);
		private final Group cGroup_6 = (Group)cGroup.eContents().get(6);
		private final Keyword cCommaKeyword_6_0 = (Keyword)cGroup_6.eContents().get(0);
		private final Assignment cValuesAssignment_6_1 = (Assignment)cGroup_6.eContents().get(1);
		private final RuleCall cValuesSTRINGTerminalRuleCall_6_1_0 = (RuleCall)cValuesAssignment_6_1.eContents().get(0);
		
		//// QuotedTypedKeyStringValueAnnotation
		//// The quoted typed key string value annotation is a replacement derived grammars may use
		//// if they want to disallow quote-less strings in a key string annotation.
		//QuotedTypedKeyStringValueAnnotation returns TypedStringAnnotation:
		//    '@' name=ExtendedID '[' type=ExtendedID ']' values += STRING (',' values += STRING)*;
		@Override public ParserRule getRule() { return rule; }
		
		//'@' name=ExtendedID '[' type=ExtendedID ']' values += STRING (',' values += STRING)*
		public Group getGroup() { return cGroup; }
		
		//'@'
		public Keyword getCommercialAtKeyword_0() { return cCommercialAtKeyword_0; }
		
		//name=ExtendedID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ExtendedID
		public RuleCall getNameExtendedIDParserRuleCall_1_0() { return cNameExtendedIDParserRuleCall_1_0; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_2() { return cLeftSquareBracketKeyword_2; }
		
		//type=ExtendedID
		public Assignment getTypeAssignment_3() { return cTypeAssignment_3; }
		
		//ExtendedID
		public RuleCall getTypeExtendedIDParserRuleCall_3_0() { return cTypeExtendedIDParserRuleCall_3_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_4() { return cRightSquareBracketKeyword_4; }
		
		//values += STRING
		public Assignment getValuesAssignment_5() { return cValuesAssignment_5; }
		
		//STRING
		public RuleCall getValuesSTRINGTerminalRuleCall_5_0() { return cValuesSTRINGTerminalRuleCall_5_0; }
		
		//(',' values += STRING)*
		public Group getGroup_6() { return cGroup_6; }
		
		//','
		public Keyword getCommaKeyword_6_0() { return cCommaKeyword_6_0; }
		
		//values += STRING
		public Assignment getValuesAssignment_6_1() { return cValuesAssignment_6_1; }
		
		//STRING
		public RuleCall getValuesSTRINGTerminalRuleCall_6_1_0() { return cValuesSTRINGTerminalRuleCall_6_1_0; }
	}
	public class EStringElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.annotations.Annotations.EString");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cSTRINGTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cExtendedIDParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//// EString
		//// Allow strings without quotes if they don't contain spaces.
		//// For quoteless strings the ExtendedID rule is used.
		//EString returns ecore::EString:
		//    STRING | ExtendedID;
		@Override public ParserRule getRule() { return rule; }
		
		//STRING | ExtendedID
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//STRING
		public RuleCall getSTRINGTerminalRuleCall_0() { return cSTRINGTerminalRuleCall_0; }
		
		//ExtendedID
		public RuleCall getExtendedIDParserRuleCall_1() { return cExtendedIDParserRuleCall_1; }
	}
	public class EStringBooleanElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.annotations.Annotations.EStringBoolean");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cSTRINGTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cExtendedIDParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cBOOLEANTerminalRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//EStringBoolean returns ecore::EString:
		//    STRING | ExtendedID | BOOLEAN;
		@Override public ParserRule getRule() { return rule; }
		
		//STRING | ExtendedID | BOOLEAN
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//STRING
		public RuleCall getSTRINGTerminalRuleCall_0() { return cSTRINGTerminalRuleCall_0; }
		
		//ExtendedID
		public RuleCall getExtendedIDParserRuleCall_1() { return cExtendedIDParserRuleCall_1; }
		
		//BOOLEAN
		public RuleCall getBOOLEANTerminalRuleCall_2() { return cBOOLEANTerminalRuleCall_2; }
	}
	public class EStringAllTypesElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.annotations.Annotations.EStringAllTypes");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cSTRINGTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cExtendedIDParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cBOOLEANTerminalRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cIntegerParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cFloategerParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		
		//EStringAllTypes returns ecore::EString:
		//    STRING | ExtendedID | BOOLEAN | Integer | Floateger;
		@Override public ParserRule getRule() { return rule; }
		
		//STRING | ExtendedID | BOOLEAN | Integer | Floateger
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//STRING
		public RuleCall getSTRINGTerminalRuleCall_0() { return cSTRINGTerminalRuleCall_0; }
		
		//ExtendedID
		public RuleCall getExtendedIDParserRuleCall_1() { return cExtendedIDParserRuleCall_1; }
		
		//BOOLEAN
		public RuleCall getBOOLEANTerminalRuleCall_2() { return cBOOLEANTerminalRuleCall_2; }
		
		//Integer
		public RuleCall getIntegerParserRuleCall_3() { return cIntegerParserRuleCall_3; }
		
		//Floateger
		public RuleCall getFloategerParserRuleCall_4() { return cFloategerParserRuleCall_4; }
	}
	public class ExtendedIDElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.annotations.Annotations.ExtendedID");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cIDTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_1_0 = (Alternatives)cGroup_1.eContents().get(0);
		private final Keyword cFullStopKeyword_1_0_0 = (Keyword)cAlternatives_1_0.eContents().get(0);
		private final Keyword cHyphenMinusKeyword_1_0_1 = (Keyword)cAlternatives_1_0.eContents().get(1);
		private final RuleCall cIDTerminalRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cNumberSignKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final RuleCall cINTTerminalRuleCall_2_1 = (RuleCall)cGroup_2.eContents().get(1);
		
		//// ExtendedID
		//// ExtendedID extends the ID rule provided by the terminals grammar.
		//// An ID may have dot separated parts and may close with a number separated by a hash mark.
		//ExtendedID returns ecore::EString:
		//  ID (('.'|'-') ID)* (('#') INT)?;
		@Override public ParserRule getRule() { return rule; }
		
		//ID (('.'|'-') ID)* (('#') INT)?
		public Group getGroup() { return cGroup; }
		
		//ID
		public RuleCall getIDTerminalRuleCall_0() { return cIDTerminalRuleCall_0; }
		
		//(('.'|'-') ID)*
		public Group getGroup_1() { return cGroup_1; }
		
		//('.'|'-')
		public Alternatives getAlternatives_1_0() { return cAlternatives_1_0; }
		
		//'.'
		public Keyword getFullStopKeyword_1_0_0() { return cFullStopKeyword_1_0_0; }
		
		//'-'
		public Keyword getHyphenMinusKeyword_1_0_1() { return cHyphenMinusKeyword_1_0_1; }
		
		//ID
		public RuleCall getIDTerminalRuleCall_1_1() { return cIDTerminalRuleCall_1_1; }
		
		//(('#') INT)?
		public Group getGroup_2() { return cGroup_2; }
		
		//('#')
		public Keyword getNumberSignKeyword_2_0() { return cNumberSignKeyword_2_0; }
		
		//INT
		public RuleCall getINTTerminalRuleCall_2_1() { return cINTTerminalRuleCall_2_1; }
	}
	public class QualifiedIDElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.annotations.Annotations.QualifiedID");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cIDTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cFullStopKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cIDTerminalRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		
		//QualifiedID returns ecore::EString:
		//  ID ("." ID)*;
		@Override public ParserRule getRule() { return rule; }
		
		//ID ("." ID)*
		public Group getGroup() { return cGroup; }
		
		//ID
		public RuleCall getIDTerminalRuleCall_0() { return cIDTerminalRuleCall_0; }
		
		//("." ID)*
		public Group getGroup_1() { return cGroup_1; }
		
		//"."
		public Keyword getFullStopKeyword_1_0() { return cFullStopKeyword_1_0; }
		
		//ID
		public RuleCall getIDTerminalRuleCall_1_1() { return cIDTerminalRuleCall_1_1; }
	}
	public class IntegerElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.annotations.Annotations.Integer");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cHyphenMinusKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cINTTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		//// Integer
		//// The integer rule extends the EInt terminal by an optional sign for negative numbers.
		//Integer returns ecore::EInt:
		//    '-'? INT;
		@Override public ParserRule getRule() { return rule; }
		
		//'-'? INT
		public Group getGroup() { return cGroup; }
		
		//'-'?
		public Keyword getHyphenMinusKeyword_0() { return cHyphenMinusKeyword_0; }
		
		//INT
		public RuleCall getINTTerminalRuleCall_1() { return cINTTerminalRuleCall_1; }
	}
	public class FloategerElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.annotations.Annotations.Floateger");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cHyphenMinusKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cFLOATTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		//// Floateger
		//// The floateger rule extends the EFloat terminal by an optional sign for negative numbers.
		//Floateger returns ecore::EDouble:
		//    '-'? FLOAT;
		@Override public ParserRule getRule() { return rule; }
		
		//'-'? FLOAT
		public Group getGroup() { return cGroup; }
		
		//'-'?
		public Keyword getHyphenMinusKeyword_0() { return cHyphenMinusKeyword_0; }
		
		//FLOAT
		public RuleCall getFLOATTerminalRuleCall_1() { return cFLOATTerminalRuleCall_1; }
	}
	
	
	private final AnnotationElements pAnnotation;
	private final PragmaElements pPragma;
	private final ValuedAnnotationElements pValuedAnnotation;
	private final RestrictedTypeAnnotationElements pRestrictedTypeAnnotation;
	private final QuotedStringAnnotationElements pQuotedStringAnnotation;
	private final CommentAnnotationElements pCommentAnnotation;
	private final CommentAnnotatonSLElements pCommentAnnotatonSL;
	private final TagAnnotationElements pTagAnnotation;
	private final PragmaTagElements pPragmaTag;
	private final KeyStringValueAnnotationElements pKeyStringValueAnnotation;
	private final RestrictedKeyStringValueAnnotationElements pRestrictedKeyStringValueAnnotation;
	private final StringPragmaElements pStringPragma;
	private final TypedKeyStringValueAnnotationElements pTypedKeyStringValueAnnotation;
	private final RestrictedTypedKeyStringValueAnnotationElements pRestrictedTypedKeyStringValueAnnotation;
	private final QuotedKeyStringValueAnnotationElements pQuotedKeyStringValueAnnotation;
	private final QuotedTypedKeyStringValueAnnotationElements pQuotedTypedKeyStringValueAnnotation;
	private final EStringElements pEString;
	private final EStringBooleanElements pEStringBoolean;
	private final EStringAllTypesElements pEStringAllTypes;
	private final ExtendedIDElements pExtendedID;
	private final QualifiedIDElements pQualifiedID;
	private final IntegerElements pInteger;
	private final FloategerElements pFloateger;
	private final TerminalRule tCOMMENT_ANNOTATION;
	private final TerminalRule tML_COMMENT;
	private final TerminalRule tSL_COMMENT_ANNOTATION;
	private final TerminalRule tSL_COMMENT;
	private final TerminalRule tNUMBER;
	private final TerminalRule tINT;
	private final TerminalRule tFLOAT;
	private final TerminalRule tBOOLEAN;
	private final TerminalRule tSTRING;
	private final TerminalRule tID;
	
	private final Grammar grammar;
	
	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public AnnotationsGrammarAccess(GrammarProvider grammarProvider,
			TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pAnnotation = new AnnotationElements();
		this.pPragma = new PragmaElements();
		this.pValuedAnnotation = new ValuedAnnotationElements();
		this.pRestrictedTypeAnnotation = new RestrictedTypeAnnotationElements();
		this.pQuotedStringAnnotation = new QuotedStringAnnotationElements();
		this.pCommentAnnotation = new CommentAnnotationElements();
		this.pCommentAnnotatonSL = new CommentAnnotatonSLElements();
		this.pTagAnnotation = new TagAnnotationElements();
		this.pPragmaTag = new PragmaTagElements();
		this.pKeyStringValueAnnotation = new KeyStringValueAnnotationElements();
		this.pRestrictedKeyStringValueAnnotation = new RestrictedKeyStringValueAnnotationElements();
		this.pStringPragma = new StringPragmaElements();
		this.pTypedKeyStringValueAnnotation = new TypedKeyStringValueAnnotationElements();
		this.pRestrictedTypedKeyStringValueAnnotation = new RestrictedTypedKeyStringValueAnnotationElements();
		this.pQuotedKeyStringValueAnnotation = new QuotedKeyStringValueAnnotationElements();
		this.pQuotedTypedKeyStringValueAnnotation = new QuotedTypedKeyStringValueAnnotationElements();
		this.pEString = new EStringElements();
		this.pEStringBoolean = new EStringBooleanElements();
		this.pEStringAllTypes = new EStringAllTypesElements();
		this.pExtendedID = new ExtendedIDElements();
		this.pQualifiedID = new QualifiedIDElements();
		this.pInteger = new IntegerElements();
		this.pFloateger = new FloategerElements();
		this.tCOMMENT_ANNOTATION = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.annotations.Annotations.COMMENT_ANNOTATION");
		this.tML_COMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.annotations.Annotations.ML_COMMENT");
		this.tSL_COMMENT_ANNOTATION = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.annotations.Annotations.SL_COMMENT_ANNOTATION");
		this.tSL_COMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.annotations.Annotations.SL_COMMENT");
		this.tNUMBER = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.annotations.Annotations.NUMBER");
		this.tINT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.annotations.Annotations.INT");
		this.tFLOAT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.annotations.Annotations.FLOAT");
		this.tBOOLEAN = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.annotations.Annotations.BOOLEAN");
		this.tSTRING = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.annotations.Annotations.STRING");
		this.tID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.annotations.Annotations.ID");
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("de.cau.cs.kieler.annotations.Annotations".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	
	
	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	///**
	// * @author ssm
	// * @kieler.design 2015-08-21 proposed
	// * @kieler.rating 2015-08-21 proposed yellow
	// */
	//// ------------------ //
	////  Annotation Rules  //
	//// ------------------ //
	//// General rule for annotations
	//// The different annotation sub rules are tested in order. Hence, order matters!
	//Annotation returns Annotation:
	//    CommentAnnotation |
	//    KeyStringValueAnnotation |
	//    TypedKeyStringValueAnnotation |
	//    TagAnnotation;
	public AnnotationElements getAnnotationAccess() {
		return pAnnotation;
	}
	
	public ParserRule getAnnotationRule() {
		return getAnnotationAccess().getRule();
	}
	
	//// General rule for pragmas
	//// We only have string and tag pragmas.
	//Pragma returns Pragma:
	//    StringPragma |
	//    PragmaTag;
	public PragmaElements getPragmaAccess() {
		return pPragma;
	}
	
	public ParserRule getPragmaRule() {
		return getPragmaAccess().getRule();
	}
	
	//// Valued Annotation Rule
	//// Valued annotations must have a value. For instance, tag annotations are not allowed.
	//// Derived grammars may use this rule if the general annotation rules compromises the grammar
	//// due to ambiguities.
	//ValuedAnnotation returns Annotation:
	//    CommentAnnotation |
	//    KeyStringValueAnnotation |
	//    TypedKeyStringValueAnnotation;
	public ValuedAnnotationElements getValuedAnnotationAccess() {
		return pValuedAnnotation;
	}
	
	public ParserRule getValuedAnnotationRule() {
		return getValuedAnnotationAccess().getRule();
	}
	
	//// Restricted Type Annotation Rule
	//// The restricted type annotation rule does not allow typed string annotations.
	//// You can use this rule in derived grammars if you don't want to permit typed strings.
	//RestrictedTypeAnnotation returns Annotation:
	//    CommentAnnotation |
	//    RestrictedKeyStringValueAnnotation |
	//    RestrictedTypedKeyStringValueAnnotation |
	//    TagAnnotation;
	public RestrictedTypeAnnotationElements getRestrictedTypeAnnotationAccess() {
		return pRestrictedTypeAnnotation;
	}
	
	public ParserRule getRestrictedTypeAnnotationRule() {
		return getRestrictedTypeAnnotationAccess().getRule();
	}
	
	//// Quoted String Annotation Rule
	//// The quoted string annotation rules uses quoted key string annotations. You can use this rule in
	//// derived grammars if you don't want to permit unquoted strings.
	//// (If you are looking for an example, the keffects grammar uses this rule for their emission
	//// rule and to avoid grammar ambiguities.)
	//QuotedStringAnnotation returns Annotation:
	//    CommentAnnotation |
	//    QuotedKeyStringValueAnnotation |
	//    QuotedTypedKeyStringValueAnnotation |
	//    TagAnnotation;
	public QuotedStringAnnotationElements getQuotedStringAnnotationAccess() {
		return pQuotedStringAnnotation;
	}
	
	public ParserRule getQuotedStringAnnotationRule() {
		return getQuotedStringAnnotationAccess().getRule();
	}
	
	//// CommentAnnotation
	//// e.g.: /** semantic comment */
	//CommentAnnotation returns CommentAnnotation:
	//    values += COMMENT_ANNOTATION;
	public CommentAnnotationElements getCommentAnnotationAccess() {
		return pCommentAnnotation;
	}
	
	public ParserRule getCommentAnnotationRule() {
		return getCommentAnnotationAccess().getRule();
	}
	
	//CommentAnnotatonSL returns CommentAnnotation:
	//    values += SL_COMMENT_ANNOTATION;
	public CommentAnnotatonSLElements getCommentAnnotatonSLAccess() {
		return pCommentAnnotatonSL;
	}
	
	public ParserRule getCommentAnnotatonSLRule() {
		return getCommentAnnotatonSLAccess().getRule();
	}
	
	//// TagAnnotation
	//// e.g.: @HVlayout
	//TagAnnotation returns TagAnnotation:
	//    '@' name=ExtendedID;
	public TagAnnotationElements getTagAnnotationAccess() {
		return pTagAnnotation;
	}
	
	public ParserRule getTagAnnotationRule() {
		return getTagAnnotationAccess().getRule();
	}
	
	//PragmaTag returns Pragma:
	//    '#' name=ExtendedID;
	public PragmaTagElements getPragmaTagAccess() {
		return pPragmaTag;
	}
	
	public ParserRule getPragmaTagRule() {
		return getPragmaTagAccess().getRule();
	}
	
	//// KeyStringValueAnnotation
	//// e.g.: @layouter dot
	//// You may separate different values via comma.
	//KeyStringValueAnnotation returns StringAnnotation:
	//    '@' name=ExtendedID values += EStringAllTypes (',' values += EStringAllTypes)*;
	public KeyStringValueAnnotationElements getKeyStringValueAnnotationAccess() {
		return pKeyStringValueAnnotation;
	}
	
	public ParserRule getKeyStringValueAnnotationRule() {
		return getKeyStringValueAnnotationAccess().getRule();
	}
	
	//RestrictedKeyStringValueAnnotation returns StringAnnotation:
	//    '@' name=ExtendedID values += EStringBoolean (',' values += EStringBoolean)*;
	public RestrictedKeyStringValueAnnotationElements getRestrictedKeyStringValueAnnotationAccess() {
		return pRestrictedKeyStringValueAnnotation;
	}
	
	public ParserRule getRestrictedKeyStringValueAnnotationRule() {
		return getRestrictedKeyStringValueAnnotationAccess().getRule();
	}
	
	//StringPragma returns StringPragma:
	//    '#' name=ExtendedID values += EStringAllTypes (',' values += EStringAllTypes)*;
	public StringPragmaElements getStringPragmaAccess() {
		return pStringPragma;
	}
	
	public ParserRule getStringPragmaRule() {
		return getStringPragmaAccess().getRule();
	}
	
	//// TypedKeyStringValueAnnotation
	//// e.g.: @position[de.cau.cs.kieler.core.math.KVector] "(3,2)"
	//TypedKeyStringValueAnnotation returns TypedStringAnnotation:
	//    '@' name=ExtendedID '[' type=ExtendedID ']' values += EStringAllTypes (',' values += EStringAllTypes)*;
	public TypedKeyStringValueAnnotationElements getTypedKeyStringValueAnnotationAccess() {
		return pTypedKeyStringValueAnnotation;
	}
	
	public ParserRule getTypedKeyStringValueAnnotationRule() {
		return getTypedKeyStringValueAnnotationAccess().getRule();
	}
	
	//RestrictedTypedKeyStringValueAnnotation returns TypedStringAnnotation:
	//    '@' name=ExtendedID '[' type=ExtendedID ']' values += EStringBoolean (',' values += EStringBoolean)*;
	public RestrictedTypedKeyStringValueAnnotationElements getRestrictedTypedKeyStringValueAnnotationAccess() {
		return pRestrictedTypedKeyStringValueAnnotation;
	}
	
	public ParserRule getRestrictedTypedKeyStringValueAnnotationRule() {
		return getRestrictedTypedKeyStringValueAnnotationAccess().getRule();
	}
	
	//// QuotedKeyStringValueAnnotation
	//// The quoted key string value annotation is a replacement derived grammars may use
	//// if they want to disallow quote-less strings in a key string annotation.
	//QuotedKeyStringValueAnnotation returns StringAnnotation:
	//    '@' name=ExtendedID values += STRING (',' values += STRING)*;
	public QuotedKeyStringValueAnnotationElements getQuotedKeyStringValueAnnotationAccess() {
		return pQuotedKeyStringValueAnnotation;
	}
	
	public ParserRule getQuotedKeyStringValueAnnotationRule() {
		return getQuotedKeyStringValueAnnotationAccess().getRule();
	}
	
	//// QuotedTypedKeyStringValueAnnotation
	//// The quoted typed key string value annotation is a replacement derived grammars may use
	//// if they want to disallow quote-less strings in a key string annotation.
	//QuotedTypedKeyStringValueAnnotation returns TypedStringAnnotation:
	//    '@' name=ExtendedID '[' type=ExtendedID ']' values += STRING (',' values += STRING)*;
	public QuotedTypedKeyStringValueAnnotationElements getQuotedTypedKeyStringValueAnnotationAccess() {
		return pQuotedTypedKeyStringValueAnnotation;
	}
	
	public ParserRule getQuotedTypedKeyStringValueAnnotationRule() {
		return getQuotedTypedKeyStringValueAnnotationAccess().getRule();
	}
	
	//// EString
	//// Allow strings without quotes if they don't contain spaces.
	//// For quoteless strings the ExtendedID rule is used.
	//EString returns ecore::EString:
	//    STRING | ExtendedID;
	public EStringElements getEStringAccess() {
		return pEString;
	}
	
	public ParserRule getEStringRule() {
		return getEStringAccess().getRule();
	}
	
	//EStringBoolean returns ecore::EString:
	//    STRING | ExtendedID | BOOLEAN;
	public EStringBooleanElements getEStringBooleanAccess() {
		return pEStringBoolean;
	}
	
	public ParserRule getEStringBooleanRule() {
		return getEStringBooleanAccess().getRule();
	}
	
	//EStringAllTypes returns ecore::EString:
	//    STRING | ExtendedID | BOOLEAN | Integer | Floateger;
	public EStringAllTypesElements getEStringAllTypesAccess() {
		return pEStringAllTypes;
	}
	
	public ParserRule getEStringAllTypesRule() {
		return getEStringAllTypesAccess().getRule();
	}
	
	//// ExtendedID
	//// ExtendedID extends the ID rule provided by the terminals grammar.
	//// An ID may have dot separated parts and may close with a number separated by a hash mark.
	//ExtendedID returns ecore::EString:
	//  ID (('.'|'-') ID)* (('#') INT)?;
	public ExtendedIDElements getExtendedIDAccess() {
		return pExtendedID;
	}
	
	public ParserRule getExtendedIDRule() {
		return getExtendedIDAccess().getRule();
	}
	
	//QualifiedID returns ecore::EString:
	//  ID ("." ID)*;
	public QualifiedIDElements getQualifiedIDAccess() {
		return pQualifiedID;
	}
	
	public ParserRule getQualifiedIDRule() {
		return getQualifiedIDAccess().getRule();
	}
	
	//// Integer
	//// The integer rule extends the EInt terminal by an optional sign for negative numbers.
	//Integer returns ecore::EInt:
	//    '-'? INT;
	public IntegerElements getIntegerAccess() {
		return pInteger;
	}
	
	public ParserRule getIntegerRule() {
		return getIntegerAccess().getRule();
	}
	
	//// Floateger
	//// The floateger rule extends the EFloat terminal by an optional sign for negative numbers.
	//Floateger returns ecore::EDouble:
	//    '-'? FLOAT;
	public FloategerElements getFloategerAccess() {
		return pFloateger;
	}
	
	public ParserRule getFloategerRule() {
		return getFloategerAccess().getRule();
	}
	
	//// ---------------------- //
	////  Annotation Terminals  //
	//// ---------------------- //
	//// Comment Annotation Terminal
	//// Custom terminal rule introducing semantic comments.
	//terminal COMMENT_ANNOTATION returns ecore::EString:
	//    '/**' -> '*/';
	public TerminalRule getCOMMENT_ANNOTATIONRule() {
		return tCOMMENT_ANNOTATION;
	}
	
	//// Multiline Comment Terminal
	//// Modified version of Terminals.ML_COMMENT as
	//// COMMENT_ANNOTATION is not recognized correctly with original one.
	//@Override
	//terminal ML_COMMENT returns ecore::EString:
	//    '/*'!'*' -> '*/';
	public TerminalRule getML_COMMENTRule() {
		return tML_COMMENT;
	}
	
	//terminal SL_COMMENT_ANNOTATION returns ecore::EString:
	//    '//*' !('\n'|'\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENT_ANNOTATIONRule() {
		return tSL_COMMENT_ANNOTATION;
	}
	
	//@Override
	//terminal SL_COMMENT:
	//    '//' !'*' !('\n'|'\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return tSL_COMMENT;
	}
	
	//// Number Terminal
	//terminal fragment NUMBER :
	//    '0'..'9';
	public TerminalRule getNUMBERRule() {
		return tNUMBER;
	}
	
	//// Integer Terminal
	//// An INT is a list of numbers.
	//@Override
	//terminal INT returns ecore::EInt:
	//    NUMBER+;
	public TerminalRule getINTRule() {
		return tINT;
	}
	
	//// Float Terminal (internal precision: double!)
	//// Make sure the Float rule does not shadow the INT rule
	//terminal FLOAT returns ecore::EDouble:
	//    NUMBER+ ('.' NUMBER*) (("e"|"E") ("+"|"-")? NUMBER+)? 'f'? |
	//    NUMBER+ 'f';
	public TerminalRule getFLOATRule() {
		return tFLOAT;
	}
	
	//// Boolean Terminal
	//// Introduce boolean values.
	//terminal BOOLEAN returns ecore::EBooleanObject :
	//    'true' | 'false';
	public TerminalRule getBOOLEANRule() {
		return tBOOLEAN;
	}
	
	//// String Terminal
	//// Custom terminal rule for strings, only use double quotes.
	//@Override
	//terminal STRING returns ecore::EString:
	//    '"' ( '\\' ('b'|'t'|'n'|'f'|'r'|'"'|"'"|'\\') | !('\\'|'"') )* '"';
	public TerminalRule getSTRINGRule() {
		return tSTRING;
	}
	
	//@Override
	//terminal ID:
	//    '^'?(('_'?'a'..'z'|'_'?'A'..'Z')|'_''0'..'9'|'__') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*;
	public TerminalRule getIDRule() {
		return tID;
	}
	
	//terminal WS         : (' '|'\t'|'\r'|'\n')+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	}
	
	//terminal ANY_OTHER: .;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	}
}
