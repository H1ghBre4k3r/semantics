/*
 * generated by Xtext
 */
package de.cau.cs.kieler.kexpressions.kext.formatting2;

import com.google.inject.Inject
import de.cau.cs.kieler.annotations.Annotation
import de.cau.cs.kieler.kexpressions.Declaration
import de.cau.cs.kieler.kexpressions.Expression
import de.cau.cs.kieler.kexpressions.GenericTypeReference
import de.cau.cs.kieler.kexpressions.Parameter
import de.cau.cs.kieler.kexpressions.ReferenceDeclaration
import de.cau.cs.kieler.kexpressions.ValuedObject
import de.cau.cs.kieler.kexpressions.VariableDeclaration
import de.cau.cs.kieler.kexpressions.keffects.formatting2.KEffectsFormatter
import de.cau.cs.kieler.kexpressions.kext.AnnotatedExpression
import de.cau.cs.kieler.kexpressions.kext.KExtScope
import de.cau.cs.kieler.kexpressions.kext.Kext
import de.cau.cs.kieler.kexpressions.kext.TestEntity
import de.cau.cs.kieler.kexpressions.kext.services.KExtGrammarAccess
import org.eclipse.xtext.formatting2.IFormattableDocument

class KExtFormatter extends KEffectsFormatter {
	
	@Inject extension KExtGrammarAccess

	def dispatch void format(Kext kext, extension IFormattableDocument document) {
		// TODO: format HiddenRegions around keywords, attributes, cross references, etc. 
		for (KExtScope scopes : kext.getScopes()) {
			format(scopes, document);
		}
	}

	def dispatch void format(KExtScope kextscope, extension IFormattableDocument document) {
		// TODO: format HiddenRegions around keywords, attributes, cross references, etc. 
		for (Declaration declarations : kextscope.getDeclarations()) {
			format(declarations, document);
		}
		for (TestEntity entities : kextscope.getEntities()) {
			format(entities, document);
		}
		for (KExtScope scopes : kextscope.getScopes()) {
			format(scopes, document);
		}
	}

	def dispatch void format(TestEntity testentity, extension IFormattableDocument document) {
		// TODO: format HiddenRegions around keywords, attributes, cross references, etc. 
		format(testentity.getExpression(), document);
		format(testentity.getEffect(), document);
	}

	def dispatch void format(AnnotatedExpression annotatedexpression, extension IFormattableDocument document) {
		// TODO: format HiddenRegions around keywords, attributes, cross references, etc. 
		for (Annotation annotations : annotatedexpression.getAnnotations()) {
			format(annotations, document);
		}
		format(annotatedexpression.getExpression(), document);
	}

	def dispatch void format(VariableDeclaration variabledeclaration, extension IFormattableDocument document) {
		// TODO: format HiddenRegions around keywords, attributes, cross references, etc. 
		for (Annotation annotations : variabledeclaration.getAnnotations()) {
			format(annotations, document);
		}
		
		for (ValuedObject valuedObjects : variabledeclaration.getValuedObjects()) {
			format(valuedObjects, document);
			valuedObjects.append[ noSpace ]
		}
		
		variabledeclaration.append[ newLine lowPriority ]
    }

	def dispatch void format(ReferenceDeclaration referencedeclaration, extension IFormattableDocument document) {
		// TODO: format HiddenRegions around keywords, attributes, cross references, etc. 
		for (Annotation annotations : referencedeclaration.getAnnotations()) {
			format(annotations, document);
		}
		
		for (ValuedObject valuedObjects : referencedeclaration.getValuedObjects()) {
			format(valuedObjects, document);
			valuedObjects.append[ noSpace ]
		}
		
		referencedeclaration.append[ newLine lowPriority ]
	}

	def dispatch void format(ValuedObject valuedobject, extension IFormattableDocument document) {
		// TODO: format HiddenRegions around keywords, attributes, cross references, etc. 
		for (Annotation annotations : valuedobject.getAnnotations()) {
			format(annotations, document);
		}
		
		valuedobject.regionFor.keywords(valuedObjectAccess.leftSquareBracketKeyword_3_0).forEach[prepend[ noSpace ].append[ noSpace ]]
        valuedobject.regionFor.keywords(valuedObjectAccess.rightSquareBracketKeyword_3_2).forEach[prepend[ noSpace ]]
		
		for (Expression cardinalities : valuedobject.getCardinalities()) {
			format(cardinalities, document);
		}
		format(valuedobject.getInitialValue(), document);
	}
	

    def dispatch void format(GenericTypeReference ref, extension IFormattableDocument document) {
        // If there are no spaces, the tokenizer will detect > > as >> (shift) and parsing will fail
        ref.regionFor.keyword(genericTypeReferenceAccess.lessThanSignKeyword_1_0)?.prepend[ noSpace ]//.append[ noSpace ]
        // ref.regionFor.keyword(genericTypeReferenceAccess.greaterThanSignKeyword_1_3)?.prepend[ noSpace ]
        
        for (Parameter parameters : ref.getGenericParameters()) {
            format(parameters, document);
        }
    }
}
