/*
 * generated by Xtext
 */
package de.cau.cs.kieler.kexpressions.kext.validation

import de.cau.cs.kieler.annotations.StringAnnotation
import de.cau.cs.kieler.kexpressions.Declaration
import de.cau.cs.kieler.kexpressions.IntValue
import de.cau.cs.kieler.kexpressions.OperatorExpression
import de.cau.cs.kieler.kexpressions.OperatorType
import de.cau.cs.kieler.kexpressions.Value
import de.cau.cs.kieler.kexpressions.ValueType
import de.cau.cs.kieler.kexpressions.ValuedObject
import de.cau.cs.kieler.kexpressions.ValuedObjectReference
import de.cau.cs.kieler.kexpressions.VariableDeclaration
import de.cau.cs.kieler.kexpressions.keffects.Assignment
import de.cau.cs.kieler.kexpressions.kext.AnnotatedExpression
import de.cau.cs.kieler.kexpressions.kext.Kext
import de.cau.cs.kieler.kexpressions.kext.TestEntity
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.validation.Check

//import org.eclipse.xtext.validation.Check

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class KExtValidator extends AbstractKExtValidator {

    public static val CHECK_ANNOTATION_NAME = "check"
    public static val CHECKALIAS_ANNOTATION_NAME = "aliasCheck"
    
    public static val CHECK_ANNOTATION_ID_ALREADY_EXISTS = "The ID of a check annotation must be unique!";
    public static val CHECK_CHECKALIAS_ANNOTATION_MATCHES_NOTHING = "The alias check reference matches nothing!"
    
    static val WRONG_CARDINALITY_TYPE = "Array cardinalities must be an int literal or a reference to a constant int object."
    static val String NO_CONST_LITERAL = "Const objects must be bound to literals";
    
    @Check
    public def void checkCheckAnnotation(TestEntity testEntity) {
        val rootElement = EcoreUtil2.getRootContainer(testEntity) as Kext;
        val ownCheckId = testEntity.eAllContents.filter(StringAnnotation).filter[ name.equals(CHECK_ANNOTATION_NAME) ].head.values.head 
        
        val identicalCheckIds = rootElement.eAllContents.filter(StringAnnotation).
            filter[ name.equals(CHECK_ANNOTATION_NAME) && values.head.equals(ownCheckId) ].toList
        
        if (identicalCheckIds.size > 1) {
            for(checkId : identicalCheckIds) {
                error(CHECK_ANNOTATION_ID_ALREADY_EXISTS, checkId, null, -1)
            }
        }       
    }
    
    @Check
    public def void checkCheckAliasAnnotation(StringAnnotation stringAnnotation) {
        if (!stringAnnotation.name.equals(CHECKALIAS_ANNOTATION_NAME)) { return; }
        val parent = stringAnnotation.eContainer
        val VOs = <ValuedObject> newArrayList
        if (parent instanceof Assignment) {
            VOs += parent.reference.valuedObject
            if (parent.expression instanceof ValuedObjectReference) {
                VOs += (parent.expression as ValuedObjectReference).valuedObject
            } else {
                VOs += parent.expression.eAllContents.filter(ValuedObjectReference).map[ valuedObject ].toList
            }
        } else if (parent instanceof AnnotatedExpression) {
            if (parent.expression instanceof ValuedObjectReference) {
                VOs += (parent.expression as ValuedObjectReference).valuedObject
            } else {
                VOs += parent.expression.eAllContents.filter(ValuedObjectReference).map[ valuedObject ].toList
            }
        }
        
        val matches = VOs.filter[ name.equals(stringAnnotation.values.head) ]
        if (matches.empty) {
            warning(CHECK_CHECKALIAS_ANNOTATION_MATCHES_NOTHING, stringAnnotation, null, -1)
        }
        
    }
    
    @Check
    def void checkConstDeclarationInArrays(Declaration declaration) {
        for (vo : declaration.valuedObjects) {
            for (card : vo.cardinalities) {
                var ok = false
                if (card instanceof IntValue) ok = true
                if (card instanceof ValuedObjectReference) {
                    val refVO = card.valuedObject
                    val refDecl = refVO.eContainer as VariableDeclaration
                    if (refDecl.const && refDecl.type == ValueType.INT) {
                        if (refVO.initialValue != null && refVO.initialValue instanceof IntValue) ok = true
                    }
                }
                
                if (!ok) {
                    error(WRONG_CARDINALITY_TYPE, card, null)
                } 
            }
        }
    }

   @Check
   def void checkConstBinding(VariableDeclaration declaration) {
       if (declaration.isConst) {
           for (valuedObject : declaration.getValuedObjects) {
               val initialValue = valuedObject.getInitialValue
               if (initialValue != null) {
                   var ok = false
                   // If it is a literal, it's ok.
                   if (initialValue instanceof Value) ok = true
                   
                   // If it is an subtraction operator expression with a single literal, it's ok. E.g., -12
                   if (initialValue instanceof OperatorExpression) {
                       if (initialValue.operator == OperatorType.SUB) {
                           if (initialValue.subExpressions.size == 1 &&
                               initialValue.subExpressions.head instanceof Value) ok = true
                       } 
                   }
                   if (!ok) error(NO_CONST_LITERAL, valuedObject, null, -1);
               }
           }
       }
    }
    
    @Check
    def void checkPureSignal(VariableDeclaration declaration) {
        if (declaration.type == ValueType.PURE && (!declaration.signal)) {
            error("Pure types are only allowed if used in combination with signals.",
                declaration, null, -1)
        }
    }
}
