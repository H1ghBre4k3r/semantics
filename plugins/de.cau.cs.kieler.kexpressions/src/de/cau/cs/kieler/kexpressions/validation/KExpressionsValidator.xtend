/*
 * generated by Xtext
 */
package de.cau.cs.kieler.kexpressions.validation

import de.cau.cs.kieler.kexpressions.VariableDeclaration
import org.eclipse.xtext.validation.Check
import de.cau.cs.kieler.kexpressions.OperatorExpression
import de.cau.cs.kieler.kexpressions.OperatorType
import com.google.inject.Inject
import de.cau.cs.kieler.kexpressions.extensions.KExpressionsTypeExtensions
import de.cau.cs.kieler.kexpressions.AccessModifier
import de.cau.cs.kieler.kexpressions.ValuedObject
import de.cau.cs.kieler.kexpressions.Declaration
import de.cau.cs.kieler.kexpressions.ReferenceDeclaration
import de.cau.cs.kieler.kexpressions.KExpressionsPackage

//import org.eclipse.xtext.validation.Check

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class KExpressionsValidator extends AbstractKExpressionsValidator {

    @Inject extension KExpressionsTypeExtensions

    public static val CONST_DECLARATION_EXPECTS_INITIALIZATION = "A const declaration must have an initialization part!";    
    
    @Check
    public def void checkConstInitialization(VariableDeclaration declaration) {
        if (declaration.isConst && !declaration.isInput) {
            for(vo : declaration.valuedObjects) {
                if (vo.initialValue === null) {
                    error(CONST_DECLARATION_EXPECTS_INITIALIZATION, vo, null, -1)
                }
            }
        }
    }  
    
    @Check
    def void checkFloatModulo(OperatorExpression operatorExpression) {
        if (operatorExpression.operator !== OperatorType.MOD) return;
        
        if (operatorExpression.isFloat) {
            warning("You are using modulo with floats. Most implemented code backend (such as C) will not support this. " 
                + "Use dedicated hostcode functions (such as fmod) to implement the behavior.", operatorExpression, null, -1)
        }
    }
    
    
    @Check
    def void checkPrivateDeclaration(VariableDeclaration declaration) {
        if (declaration.access !== AccessModifier.PUBLIC) {
            if (declaration instanceof VariableDeclaration) {
                if (declaration.input || declaration.output) {
                    error("A private declaration cannot be a public input output interface", declaration, null, -1)
                }
            }
        }
    }
    
    
    @Check
    def void checkGenericParamterOnValuedObject(ValuedObject vo) {
        if (!vo.genericParameters.nullOrEmpty) {
            val decl = vo.eContainer
            if (decl instanceof ReferenceDeclaration) {
                if (!decl.genericParameters.nullOrEmpty) {
                    error("Cannot mix generic parameters in variables and declaration", vo, KExpressionsPackage.eINSTANCE.valuedObject_GenericParameters)
                }
            } else if (decl instanceof Declaration) {
                error("Generic parameters are not allowed in this context", vo, KExpressionsPackage.eINSTANCE.valuedObject_GenericParameters)
            }
        }
    }
}
