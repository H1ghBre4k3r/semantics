grammar de.cau.cs.kieler.yakindu.sccharts.model.stext.Synctext with org.yakindu.sct.model.stext.SText

generate synctext "http://kieler.cs.cau.de/yakindu/sccharts/stext/"

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
import "http://www.yakindu.org/sct/statechart/SText" as stext
import "http://www.yakindu.org/sct/sgraph/2.0.0" as sgraph
import "http://www.yakindu.org/base/types/2.0.0" as types

/*********************************** INTERFACE DECLARATION **************************************** */
////defines the possible scopes for a state
StateScope:
    {SimpleScope} declarations+=(Declaration)*;


    /* ---- declarations ----
a definition is a top level element of a definition scope. */
Declaration returns sgraph::Declaration:
        LocalEntryReaction | LocalDuringReaction | LocalExitReaction | LocalSuspendReaction
        | VariableDeclaration 
        | SignalDeclaration 
        | OperationDeclaration 
;


/************************************************/
/*			 Signal Definition				*/
/************************************************/
SignalDeclaration returns sgraph::Event:
	SignalDefinition;
SignalDefinition:
	{EventDefinition} (isInput?='input')? (isOutput?='output')? 'signal'
	name=ID (':' type=[types::Type|FQN]
	('=' varInitialValue=Expression)?
	('with' varCombineOperator=CombineOperator)?)? ';';


/************************************************/
/*			 Variable Definition				*/
/************************************************/
// A dummy VariableDefinition declaration, which will be override by an other grammar 
//VariableDefinition:
//	{VariableDefinition} 'variable' name=ID ';';
// CMOT changes, want to use VariableDefinitions from SyncText
VariableDeclaration returns sgraph::Variable:VariableDefinition;
VariableDefinition:
    {VariableDefinition} (isInput?='input')? (isOutput?='output')? (isStatic?='static')? type=[types::Type|FQN] name=ID
    ('=' initialValue=Expression)? ('with' varCombineOperator=CombineOperator)? ';';	


/************************************************/
/*			   	LocalReactions  		        */
/************************************************/
OperationDefinition:
    {OperationDefinition} 'extern'  functionType=[types::Type|FQN] name=XID '(' paramType=[types::Type|FQN] ')' ';';
    
LocalEntryReaction:
  {LocalEntryReaction} 'entry' ':' (trigger=ReactionTrigger)? ('/' effect=ReactionEffect) ';';
LocalDuringReaction:
  {LocalDuringReaction} (isImmediate?='immediate')? 'during' ':' (trigger=ReactionTrigger)? '/' effect=ReactionEffect ';';
LocalExitReaction:
  {LocalExitReaction} 'exit' ':' (trigger=ReactionTrigger)? ('/' effect=ReactionEffect) ';';
LocalSuspendReaction:
  {LocalSuspendReaction} (isImmediate?='immediate')? 'suspend' ':' (trigger=ReactionTrigger)? ';';

//{Declaration}    


/******************************************** TRANSITION ***************************************** */
// The ReactionTrigger is a Trigger and has an Expression, 
// an optional delay and isImmediate option represented with a '#'
// cmot change: Get rid of extra brackets
LocalReactionTrigger returns sgraph::Trigger:
    {ReactionTrigger} (delay=INT)? (expression=Expression)?;
ReactionTrigger returns sgraph::Trigger:
    {ReactionTrigger} (labelPriority=INT':')? (delay=INT)? (expression=Expression)?;


    // Original code by wah
    //{ReactionTrigger} (labelPriority=INT':')? (delay=INT)? ((trigger=RegularEventSpec);
    //| ('(' guardExpression=Expression ')'))?;

	// The ReactionEffect is an Effect. 
ReactionEffect returns sgraph::Effect:
	{ReactionEffect} actions+=Expression (=> ';' actions+=Expression)*; // (';')?;



/***************************************** Expressions ******************************************* */
// Override the stext::NumericalMultiplyDivideExpression
// cmot addition: goal is to have some other divisor ":" instead of "/", because "/" is used to separate
// trigger / effect.
NumericalMultiplyDivideExpression returns stext::Expression:
    NumericalUnaryExpression
    ({NumericalMultiplyDivideExpression.leftOperand=current}
    operator=MultiplicativeOperator2
    rightOperand=NumericalUnaryExpression)*;
    
// New MultiplicativeOperator2 (replacing MultiplicativeOperator with ":" instead of "/")    
// cmot addition
enum MultiplicativeOperator2:
    mul='*' | div=':' | mod='%';
    
    
/***************************************** Expressions ******************************************* */
// Override the stext::EventValueReferenceExpression
// override 'valueof()' with 'val()', allow val(pre())    
// cmot change
ValReferenceExpression returns stext::Expression:
  {ValReferenceExpression} 'val'  '(' expression=(FeatureCall|PreReferenceExpression) ')';
    
// Additional pre(), like val(), allow pre(val()) and allow pre(pre())    
// cmot addition
PreReferenceExpression returns stext::Expression:
  {PreReferenceExpression} 'pre'  '(' expression=(FeatureCall|ValReferenceExpression|PreReferenceExpression) ')';
    


/***************************************** Expressions ******************************************* */
// Override the stext::PrimaryExpression
// remove the ActiveStateReferenceExpression and the EventValueReferenceExpression
// and add PreReferenceExpression that returns the previous tick instance of a variable. 
PrimaryExpression returns stext::Expression:
    PrimitiveValueExpression 
    | FeatureCall 
    | ActiveStateReferenceExpression 
    | ValReferenceExpression
    | PreReferenceExpression  
    | ParenthesizedExpression
; 



//todo: pre(x) should return the same type of x
//PreValueExpression returns stext::Expression:
//	{PreValueExpression} 'pre' '(' value=FeatureCall ')';

/***************************************** COMBINE OPERATORS ************************************* */
enum CombineOperator returns CombineOperator:
	NONE="'none'" | ADD="'+'" | MULT="'*'" | MAX="'max'" |
	MIN="'min'" | OR="'or'" | AND="'and'" | HOST="'host'";
