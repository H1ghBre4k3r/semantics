«IMPORT uml»

«REM»
MUST BE:
«EXTENSION model::Extensions»
FOR KIELER RCA !!! Otherwise the Extensions cannot be found!
updatesite fix! extensions not found in models folder because it seems not to be extracted, this is now fixed when building the update site
«ENDREM»
«EXTENSION Extensions»

«DEFINE main FOR Model»
   «EXPAND smLoadAll FOREACH packagedElement»
   «EXPAND sm FOREACH packagedElement»
   «EXPAND smVerts FOREACH packagedElement»
   «EXPAND smEvents FOREACH packagedElement»
   «EXPAND smActions FOREACH packagedElement»
   «EXPAND smTransitions FOREACH packagedElement»
   «EXPAND smStateMachine FOREACH packagedElement»
   «EXPAND smInterface FOREACH packagedElement»
«ENDDEFINE»

«DEFINE main FOR Package»
   «EXPAND smLoadAll FOREACH packagedElement»
   «EXPAND sm FOREACH packagedElement»
   «EXPAND smVerts FOREACH packagedElement»
   «EXPAND smEvents FOREACH packagedElement»
   «EXPAND smActions FOREACH packagedElement»
   «EXPAND smTransitions FOREACH packagedElement»
   «EXPAND smStateMachine FOREACH packagedElement»
   «EXPAND smInterface FOREACH packagedElement»
«ENDDEFINE»

«DEFINE smLoadAll FOR StateMachine»
  «FILE "loadAll.maude"»
    load EVENTSDEF«((String)(GLOBALVAR modelname))».maude
    load ACTIONSDEF«((String)(GLOBALVAR modelname))».maude
    load VERTSDEF«((String)(GLOBALVAR modelname))».maude
    load TRANSITIONSDEF«((String)(GLOBALVAR modelname))».maude
    load STATEMACHINEDEF«((String)(GLOBALVAR modelname))».maude
    
    red 2 .
    red assignAct (vID "y" := (2).Expression) .
  «ENDFILE»
«ENDDEFINE»



«DEFINE smEvents FOR StateMachine»
  «FILE "EVENTSDEF" + ((String)(GLOBALVAR modelname)) +".maude"»

load «((String)(GLOBALVAR maudebasecode))»EVENTSSYNTAX

fmod EVENTSDEF is
  including EVENTSET .
*** // Events //
  ops «FOREACH this.getTriggerEvents() AS event SEPARATOR " "-»«event-»«ENDFOREACH-» : -> Event .
  op allEvents : -> EventSet .

endfm
  «ENDFILE»
«ENDDEFINE»


«DEFINE smActions FOR StateMachine»
  «FILE "ACTIONSDEF" + ((String)(GLOBALVAR modelname)) +".maude"»

load «((String)(GLOBALVAR maudebasecode))»ACTIONSSYNTAX

fmod ACTIONSDEF is
  including ACTION .

*** // allActions //
«REM» ToDo: no double entries, no nils? nil == falsche transitionen, fehlende beschriftung«ENDREM»
«REM» skip needs to be added automatically «ENDREM»

  op skip : -> Action .

endfm

	«ENDFILE»
«ENDDEFINE»




«DEFINE smVerts FOR StateMachine»
	«FILE "VERTSDEF" + ((String)(GLOBALVAR modelname)) +".maude"»

load «((String)(GLOBALVAR maudebasecode))»VERTSSYNTAX

fmod VERTSDEF is
  including VERTSSYNTAX .
***// States //
  «IF  this.getStates().size > 0-»
  ops «FOREACH this.getStates() AS state SEPARATOR " "-»«((State)state).getId()-»«ENDFOREACH-» : -> ModState .
	«FOREACH this.getMaudeStates() AS state SEPARATOR " .\n"-»«state-»«ENDFOREACH-» .

  «ENDIF-»

«REM»also generate history and deep history states«ENDREM»
***// PseudoStates //
*** history
  «IF  this.getHistoryStates().size > 0-»
  ops «FOREACH this.getHistoryStates() AS pseudostate SEPARATOR " "-»«((Pseudostate)pseudostate).getId()-»«ENDFOREACH-» : -> ModState .
	«FOREACH this.getHistoryMaudeStates() AS state SEPARATOR " .\n"-»«state-»«ENDFOREACH-» .
  «ENDIF-»
*** choice
  «IF  this.getRelevantPseudotates().size > 0-»
  ops «FOREACH this.getRelevantPseudotates() AS pseudostate SEPARATOR " "-»«((Pseudostate)pseudostate).getId()-»«ENDFOREACH-» : -> ModState .
	«FOREACH this.getPseudoMaudeStates() AS state SEPARATOR " .\n"-»«state-»«ENDFOREACH-» .
  «ENDIF-»

  	
***// Regions //
  ops «FOREACH this.getRegions() AS region SEPARATOR " "-»«region.getId()-»«ENDFOREACH-» : -> Region .
	«FOREACH this.getMaudeRegions() AS region SEPARATOR " .\n"-»«region-»«ENDFOREACH-» .
***// allVerts //
  op allVerts : -> Verts .
  eq allVerts = «FOREACH this.getRegions() AS region SEPARATOR ", "-»«region.getId()-»«ENDFOREACH-» , «FOREACH this.getStates() AS state SEPARATOR ", "-»«((State)state).getId()-»«ENDFOREACH-» .

endfm
	«ENDFILE»
«ENDDEFINE»


«DEFINE smTransitions FOR StateMachine»
	«FILE "TRANSITIONSDEF" + ((String)(GLOBALVAR modelname)) +".maude"»

load «((String)(GLOBALVAR maudebasecode))»COMPOUNDTRANSITIONSSYNTAX
load EVENTSDEF«((String)(GLOBALVAR modelname))».maude
load ACTIONSDEF«((String)(GLOBALVAR modelname))».maude
load VERTSDEF«((String)(GLOBALVAR modelname))».maude

fmod TRANSITIONSDEF is
  including COMPOUNDTRANSITIONSSYNTAX .
  including EVENTSDEF .
  including ACTIONSDEF .
  including VERTSDEF .
  
«REM» First calculate psudostates (Fork / Join) for complex transition ids «ENDREM»
«clearDoneVertices()-»
«FOREACH this.getForkJoinChoice() AS pseudostate-»
   «IF !pseudostate.isDone("OUTGOING")-»
   «ignore(pseudostate.getPseudoSourceVertices().toString())-»
   «addPseudostate(pseudostate)-»
   «ENDIF-»
«ENDFOREACH-»
«REM»No getPseudostates() can be queried«ENDREM»

*******************
*** basic transitions op declaration
*******************      
*** ToDo: Add trigger statt noevent!!
  ops «FOREACH this.getTransitions().select(e|e.isBasicTrans())  AS transition SEPARATOR "  "-»tr«transition.getId()-»«ENDFOREACH-»
      : -> BasicTransition .

*******************
*** compound transitions op declaration
*******************      
  ops «FOREACH getPseudostates()  AS pseudostate SEPARATOR "  "-»ctr«pseudostate.getId()-»«ENDFOREACH-»
  «FOREACH this.getTransitions().select(e|e.isBasicCompound())  AS transition SEPARATOR "  "-»ctr«transition.getId()-»«ENDFOREACH-»
      : -> Compoundtransition .

      
*******************
*** compound transitions
*******************
  «FOREACH this.getTransitions().select(e|e.isBasicCompound()) AS transition SEPARATOR '\n'-»«transition.genMaudeBasicCompound()-»«ENDFOREACH-»

*******************
*** basic transitions
*******************

  «FOREACH this.getTransitions().select(e|e.isBasicTrans()) AS transition SEPARATOR '\n'-»«transition.genMaude2()-»«ENDFOREACH-»

  «REM» We now work thru the Fork and Join and Choice nodes. «ENDREM»
  «resetPseudostates()-»
  «REM»Clear marked vertices«ENDREM»
  «clearDoneVertices()-»
  «FOREACH this.getForkJoinChoice() AS pseudostate SEPARATOR '\n'-»
   «IF !pseudostate.isDone("OUTGOING")-»
   «REM» Protocol: getPseudoTargetTransitions has to be called BEFORE getComplexTransitionInformation can be called.
   Therefore the PsuedoSourceTransitions list is memorized as a temporary variable as it is used later than the
   getComplexTransitionInformation. 
   «ENDREM»
   «LET pseudostate.getPseudoSourceTransitions() AS PseudoSourceTransitions -»
   	eq ctr«pseudostate.getId()-» = «pseudostate.getClassIdentifier()-» "ctr«pseudostate.getId()-»" «getComplexTransitionInformation("TRIGGER").get(0)» («FOREACH PseudoSourceTransitions AS source SEPARATOR ','-»tr«source.getId()-»«ENDFOREACH-») («FOREACH pseudostate.getPseudoTargetTransitions() AS target SEPARATOR ','-»tr«target.getId()-»«ENDFOREACH-») «getLastRootRegion().getId()-» . «resetLastRootRegion()-»
   «ENDLET»
   «addPseudostate(pseudostate)-»
   «ENDIF-»
  «ENDFOREACH-»
  
  ***(
  «getComplexTransitionInformation("TRIGGER").get(0)»
  
  )***
  
  
  «REM»
   TODO: 
     allTrans mit allen basic und simple transitions?! Dann sollte man die genMaude2() Funktion eher (als Codegenerierung) 
     nach Xpand verlagern und die (wiederverwendbare) Auswahlfunktion/ID-Funktion nach Xtend.
   
  «ENDREM»
  
  op allTrans : -> Compoundtransitions .
  eq allTrans = «FOREACH getPseudostates()  AS pseudostate SEPARATOR ",  "-»ctr«pseudostate.getId()-»«ENDFOREACH-»
  				«IF (getPseudostates().size > 0 && this.getTransitions().select(e|e.isBasicCompound()).size > 0)-»,«ENDIF-»
				«FOREACH this.getTransitions().select(e|e.isBasicCompound()) AS transition SEPARATOR ", "-»ctr«transition.getId()-»«ENDFOREACH-»
 				.

endfm
	«ENDFILE»
«ENDDEFINE»





«DEFINE smStateMachine FOR StateMachine»
	«FILE "STATEMACHINEDEF" + ((String)(GLOBALVAR modelname)) +".maude"»
«REM»
load «((String)(GLOBALVAR maudebasecode))»VERTSSYNTAX
load «((String)(GLOBALVAR maudebasecode))»ACTIONSSYNTAX
load «((String)(GLOBALVAR maudebasecode))»COMPOUNDTRANSITIONSSYNTAX
«ENDREM»
load EVENTSDEF«((String)(GLOBALVAR modelname))».maude
load ACTIONSDEF«((String)(GLOBALVAR modelname))».maude
load VERTSDEF«((String)(GLOBALVAR modelname))».maude
load TRANSITIONSDEF«((String)(GLOBALVAR modelname))».maude
load «((String)(GLOBALVAR maudebasecode))»STATEMACHINESYNTAX

fmod eclipseInterface is
  including VALUATIONS .
  including ACTION .
  including ACTIONSSYNTAX .
  including STATEMACHINESYNTAX .
  including COMPOUNDTRANSITIONSSYNTAX .
  including EVENTSDEF .
  including ACTIONSDEF .
  including VERTSDEF .
  including TRANSITIONSDEF .

  	«REM»FIXME: only consider regions containing initial states for ops and allDefs«ENDREM» 
***// defaults //
  ops «FOREACH this.getRegions() AS region SEPARATOR " "-»«"def"+region.getId()-»«ENDFOREACH-» : -> Default .
  «FOREACH this.getInitialTransitions() AS transition SEPARATOR ""-»«transition.genDefault()-»«ENDFOREACH-»
  op allDefs : -> Defaults .
  eq allDefs = «FOREACH this.getRegions() AS region SEPARATOR ", "-»«"def"+region.getId()-»«ENDFOREACH-» .
  
	«REM»FIXME: only consider regions containing history states with outgoing transitions for ops and allDefs«ENDREM» 
***// deep defaults //
  ops «FOREACH this.getRegions() AS region SEPARATOR " "-»«"dDef"+region.getId()-»«ENDFOREACH-» : -> DeepDefault .
  «FOREACH this.getDHDTransitions() AS transition SEPARATOR ""-»«transition.genDHDefault()-»«ENDFOREACH-»
  op allDHDefs : -> DeepDefaults .
  eq allDHDefs = «FOREACH this.getRegions() AS region SEPARATOR ", "-»«"dDef"+region.getId()-»«ENDFOREACH-» .

	«REM»FIXME: only consider regions containing history states with outgoing transitions for ops and allDefs«ENDREM» 
***// shallow defaults //
  ops «FOREACH this.getRegions() AS region SEPARATOR " "-»«"sDef"+region.getId()-»«ENDFOREACH-» : -> ShallowDefault .
  «FOREACH this.getSHDTransitions() AS transition SEPARATOR ""-»«transition.genSHDefault()-»«ENDFOREACH-»
  
  op allSHDefs : -> ShallowDefaults .
  eq allSHDefs = «FOREACH this.getRegions() AS region SEPARATOR ", "-»«"sDef"+region.getId()-»«ENDFOREACH-» .


	
	 «REM»
	 entryAc__ : Vert Action -> EntryAction
	 laenge «((String)((State)state).entry.name).length» 
		«IF ((String)((State)state).entry.name) != "" -»
		Name «((String)((State)state).entry.name)»
		entryAc «((State)state).getId()-» «((State)state).entry.name-»  
	«ENDIF-»	
	 «ENDREM»
	op allEntry : -> EntryActions . 
	eq allEntry = 
	«IF !this.getStates().select(e|((String)((State)e).entry.name).length > 0).isEmpty -»
	«FOREACH this.getStates().select(e|((String)((State)e).entry.name).length > 0) AS state SEPARATOR " ,\n"-»entryAc «((State)state).getId()-» «((State)state).entry.name-»  
	«ENDFOREACH-» .
	«ELSE»
		(empty).EntryActions .
	«ENDIF-»
	op allExit : -> ExitActions . 
	eq allExit = 
	«IF !this.getStates().select(e|((String)((State)e).exit.name).length > 0).isEmpty -»
	«FOREACH this.getStates().select(e|((String)((State)e).exit.name).length > 0) AS state SEPARATOR " ,\n"-»exitAc «((State)state).getId()-» «((State)state).exit.name-»  
	«ENDFOREACH-» .
	«ELSE»
		(empty).ExitActions .
	«ENDIF-»
***/// A state machine consits of Vertices Defaultsstatesfunction ShallowDefaultstatesfunction DeepDefaultstatesfunction EntryActionsfunction ExitActionsFunction Transitions 
  op SMINT : -> StateMachine .
  ***// ToDo: add entry/exit actions//
  eq SMINT = (allVerts allDefs allSHDefs allDHDefs allEntry allExit allTrans) .


endfm
	«ENDFILE»
«ENDDEFINE»



«DEFINE smInterface FOR StateMachine»
	«FILE ((String)(GLOBALVAR modelname)) +".maude"»
load model-checker
*** next we need getter functions for the SM
load STATEMACHINEDEF«((String)(GLOBALVAR modelname))».maude
load «((String)(GLOBALVAR maudebasecode))»SMGETTER
load «((String)(GLOBALVAR maudebasecode))»VERTS .
load «((String)(GLOBALVAR maudebasecode))»ACTIONS .
load «((String)(GLOBALVAR maudebasecode))»UMLPRIORITY
load «((String)(GLOBALVAR maudebasecode))»COMPOUNDTRANSITIONS
load «((String)(GLOBALVAR maudebasecode))»STATEMACHINE
load «((String)(GLOBALVAR maudebasecode))»SEMANTICSSYNTAX
load «((String)(GLOBALVAR maudebasecode))»SEMANTICS
mod INIT is
	including SEMANTICS .
	including SATISFACTION .
	including LTL .
	including MODEL-CHECKER .
	including LTL-SIMPLIFIER .
	
	vars msst mastate : MState .
	vars V V2 : Verts .
	var E : EventSet .
	vars HC : HistoryConfs .
	vars conf1 conf2 : Configuration .
	vars VALUS : Valuations .
	subsort MState < State .
	
	op aCf : Actions -> Prop .
	op inC : Verts -> Prop .
    ceq maState (stableC<STATEC> V <HISTC> HC <VALUATIONS> VALUS <ENDCONF>) E |= inC(V2) = true if (V2 subset V)  .
	eq msst |= inC(V) = false [owise] .

	op isDoneSM_ : Configuration -> Bool .
	eq isDoneSM doneC<STATEC> V <HISTC> HC <VALUATIONS> VALUS <ENDCONF>	= true .
	eq isDoneSM conf1 = false [owise] .
	
	op isDone_ : MState -> Prop .
    ceq maState conf1 E |= isDone(maState conf1 E) = true if isDoneSM conf1 .
	eq msst |= isDone(msst) = false [owise] .
	
endm

***(
load «((String)(GLOBALVAR maudebasecode))»QUEUESYNTAX
 mod QUEUESEMANTICS is 
 including eclipseInterface .
 including QUEUESIGNATURE .
     sort QueueStatus .
 var el : EventSet .
 var event : Event .
 var equeue : EventQueue .

 op <ready_ > : EventQueue -> QueueStatus .
 op <schedule__ > : EventQueue Event -> QueueStatus .
 op <initQueue> : -> QueueStatus .
  
 rl <ready (QUEUE event, el ENDQUEUE) > => <schedule (QUEUE el, event ENDQUEUE) event > .
 rl <schedule equeue event >  => <ready equeue > .
 rl <initQueue> => <ready emptyQueue > . 

endm
)***
*** load «((String)(GLOBALVAR maudebasecode))»ACCS
*** load «((String)(GLOBALVAR maudebasecode))»BFAIRPOOL
*** load «((String)(GLOBALVAR maudebasecode))»BFPOOLANDSM

*** set trace on .
«REM»

***(
set break on .
break select finishedRTCESINT discardFSetESINT .
)***

***(
#####################################################
##          Interface     for     Eclipse          ##        
#####################################################
search (maState (stableC (State0-885791716,R-2027565592) empty) (d,a)) =>* mastate such that isDone mastate . 

bzw. wenn die ID-String bei dir anders sind 

search (maState (stableC (<Konfiguration>) <HistoryKonfiguration>) (<EventSet>)) =>* mastate such that isDone mastate . 


- <Konfiguration>: eine durch "," getrennte Menge von Regionen und States. Diese muss den Anforderungen im Standard entsprechen.
  z.B: Rroot, Csusp (aus Test.maude)
- <HistoryKonfiguration>: kann erstmal empty sein
- <EventSet>: eine durch "," getrennte Menge von Events die abgearbeitet werden soll




)***
«ENDREM»


	«ENDFILE»
«ENDDEFINE»




	
«DEFINE sm FOR StateMachine»
	«FILE ((String)(GLOBALVAR modelname)) +".maude_old"»
	
load «((String)(GLOBALVAR maudebasecode))»VERTSSYNTAX
load «((String)(GLOBALVAR maudebasecode))»ACTIONSSYNTAX
load «((String)(GLOBALVAR maudebasecode))»EVENTSSYNTAX
load «((String)(GLOBALVAR maudebasecode))»COMPOUNDTRANSITIONSSYNTAX
load «((String)(GLOBALVAR maudebasecode))»STATEMACHINESYNTAX
load «((String)(GLOBALVAR maudebasecode))»SEMANTICSSYNTAX
load «((String)(GLOBALVAR maudebasecode))»VALUATIONS


fmod eclipseInterface is
  including COMPOUNDTRANSITIONSSYNTAX .
  including TRANSITIONSYNTAX .
  including VERTSSYNTAX .
  including SEMANTICSSYNTAX .
  including STATE-ACTION .
  including STATEMACHINESYNTAX . 
 *** // Events //
  ops «FOREACH this.getTriggerEvents() AS event SEPARATOR " "-»«event-»«ENDFOREACH-» : -> Event .
  op allEvents : -> EventSet .

*** // allActions //
«REM» ToDo: no double entries, no nils? nil == falsche transitionen, fehlende beschriftung«ENDREM»	
«REM» skip needs to be added automatically «ENDREM»	
  ops skip «FOREACH this.getActions() AS action SEPARATOR " "-»«action-»«ENDFOREACH-» : -> Action .

***// States //
  «IF  this.getStates().size > 0-»
  ops «FOREACH this.getStates() AS state SEPARATOR " "-»«((State)state).getId()-»«ENDFOREACH-» : -> ModState .	
	«FOREACH this.getMaudeStates() AS state SEPARATOR " .\n"-»«state-»«ENDFOREACH-» .	
  «ENDIF-»
  	
«REM»also generate history and deep history states«ENDREM» 
***// PseudoStates //
*** history
  «IF  this.getHistoryStates().size > 0-»
  ops «FOREACH this.getHistoryStates() AS pseudostate SEPARATOR " "-»«((Pseudostate)pseudostate).getId()-»«ENDFOREACH-» : -> ModState .	
	«FOREACH this.getHistoryMaudeStates() AS state SEPARATOR " .\n"-»«state-»«ENDFOREACH-» .
  «ENDIF-»
*** choice
  «IF  this.getRelevantPseudotates().size > 0-»
  ops «FOREACH this.getRelevantPseudotates() AS pseudostate SEPARATOR " "-»«((Pseudostate)pseudostate).getId()-»«ENDFOREACH-» : -> ModState .	
	«FOREACH this.getPseudoMaudeStates() AS state SEPARATOR " .\n"-»«state-»«ENDFOREACH-» .
  «ENDIF-»

  	
***// Regions //
  ops «FOREACH this.getRegions() AS region SEPARATOR " "-»«region.getId()-»«ENDFOREACH-» : -> Region .
	«FOREACH this.getMaudeRegions() AS region SEPARATOR " .\n"-»«region-»«ENDFOREACH-» .
***// allVerts //
  op allVerts : -> Verts .
  eq allVerts = «FOREACH this.getRegions() AS region SEPARATOR ", "-»«region.getId()-»«ENDFOREACH-» , «FOREACH this.getStates() AS state SEPARATOR ", "-»«((State)state).getId()-»«ENDFOREACH-» .
	
	
  	«REM»FIXME: only consider regions containing initial states for ops and allDefs«ENDREM» 
***// defaults //
  ops «FOREACH this.getRegions() AS region SEPARATOR " "-»«"def"+region.getId()-»«ENDFOREACH-» : -> Default .
  «FOREACH this.getInitialTransitions() AS transition SEPARATOR ""-»«transition.genDefault()-»«ENDFOREACH-»
  op allDefs : -> Defaults .
  eq allDefs = «FOREACH this.getRegions() AS region SEPARATOR ", "-»«"def"+region.getId()-»«ENDFOREACH-» .
  
	«REM»FIXME: only consider regions containing history states with outgoing transitions for ops and allDefs«ENDREM» 
***// deep defaults //
  ops «FOREACH this.getRegions() AS region SEPARATOR " "-»«"dDef"+region.getId()-»«ENDFOREACH-» : -> DeepDefault .
  «FOREACH this.getDHDTransitions() AS transition SEPARATOR ""-»«transition.genDHDefault()-»«ENDFOREACH-»
  op allDHDefs : -> DeepDefaults .
  eq allDHDefs = «FOREACH this.getRegions() AS region SEPARATOR ", "-»«"dDef"+region.getId()-»«ENDFOREACH-» .

	«REM»FIXME: only consider regions containing history states with outgoing transitions for ops and allDefs«ENDREM» 
***// shallow defaults //
  ops «FOREACH this.getRegions() AS region SEPARATOR " "-»«"sDef"+region.getId()-»«ENDFOREACH-» : -> ShallowDefault .
  «FOREACH this.getSHDTransitions() AS transition SEPARATOR ""-»«transition.genSHDefault()-»«ENDFOREACH-»
  
  op allSHDefs : -> ShallowDefaults .
  eq allSHDefs = «FOREACH this.getRegions() AS region SEPARATOR ", "-»«"sDef"+region.getId()-»«ENDFOREACH-» .

*** Transitions
«REM» First calculate psudostates (Fork / Join) for complex transition ids «ENDREM»
«clearDoneVertices()-»
«FOREACH this.getForkJoinChoice() AS pseudostate-»
   «IF !pseudostate.isDone("OUTGOING")-»
   «ignore(pseudostate.getPseudoSourceVertices().toString())-»
   «addPseudostate(pseudostate)-»
   «ENDIF-»
«ENDFOREACH-»
«REM»No getPseudostates() can be queried«ENDREM»

*******************
*** basic transitions op declaration
*******************      
*** ToDo: Add trigger statt noevent!!
  ops «FOREACH this.getTransitions().select(e|e.isBasicTrans())  AS transition SEPARATOR "  "-»tr«transition.getId()-»«ENDFOREACH-»
      : -> BasicTransition .

*******************
*** compound transitions op declaration
*******************      
  ops «FOREACH getPseudostates()  AS pseudostate SEPARATOR "  "-»ctr«pseudostate.getId()-»«ENDFOREACH-»
  «FOREACH this.getTransitions().select(e|e.isBasicCompound())  AS transition SEPARATOR "  "-»ctr«transition.getId()-»«ENDFOREACH-»
      : -> Compoundtransition .

      
*******************
*** compound transitions decalration
*******************
  «FOREACH this.getTransitions().select(e|e.isBasicCompound()) AS transition SEPARATOR '\n'-»«transition.genMaudeBasicCompound()-»«ENDFOREACH-»
*******************
*** basic transitions
*******************
  «FOREACH this.getTransitions().select(e|e.isBasicTrans()) AS transition SEPARATOR '\n'-»«transition.genMaude2()-»«ENDFOREACH-»

  «REM» We now work thru the Fork and Join and Choice nodes. «ENDREM»
  «resetPseudostates()-»
  «REM»Clear marked vertices«ENDREM»
  «clearDoneVertices()-»
  «FOREACH this.getForkJoinChoice() AS pseudostate SEPARATOR '\n'-»
   «IF !pseudostate.isDone("OUTGOING")-»
   «REM» Protocol: getPseudoTargetTransitions has to be called BEFORE getComplexTransitionInformation can be called.
   Therefore the PsuedoSourceTransitions list is memorized as a temporary variable as it is used later than the
   getComplexTransitionInformation. 
   «ENDREM»
   «LET pseudostate.getPseudoSourceTransitions() AS PseudoSourceTransitions -»
   	eq ctr«pseudostate.getId()-» = «pseudostate.getClassIdentifier()-» "ctr«pseudostate.getId()-»" «getComplexTransitionInformation("TRIGGER").get(0)» («FOREACH PseudoSourceTransitions AS source SEPARATOR ','-»tr«source.getId()-»«ENDFOREACH-») («FOREACH pseudostate.getPseudoTargetTransitions() AS target SEPARATOR ','-»tr«target.getId()-»«ENDFOREACH-») «getLastRootRegion().getId()-» . «resetLastRootRegion()-»
   «ENDLET»
   «addPseudostate(pseudostate)-»
   «ENDIF-»
  «ENDFOREACH-»
  
  ***(
  «getComplexTransitionInformation("TRIGGER").get(0)»
  
  )***
  
  
  «REM»
   TODO: 
     allTrans mit allen basic und simple transitions?! Dann sollte man die genMaude2() Funktion eher (als Codegenerierung) 
     nach Xpand verlagern und die (wiederverwendbare) Auswahlfunktion/ID-Funktion nach Xtend.
   
  «ENDREM»
  
  op allTrans : -> Compoundtransitions .
  eq allTrans = «FOREACH getPseudostates()  AS pseudostate SEPARATOR ",  "-»ctr«pseudostate.getId()-»«ENDFOREACH-»
  				«IF (getPseudostates().size > 0 && this.getTransitions().select(e|e.isBasicCompound()).size > 0)-»,«ENDIF-»
				«FOREACH this.getTransitions().select(e|e.isBasicCompound()) AS transition SEPARATOR ", "-»ctr«transition.getId()-»«ENDFOREACH-»
 				.

 				
***/// A state machine consits of Vertices Defaultsstatesfunction ShallowDefaultstatesfunction DeepDefaultstatesfunction EntryActionsfunction ExitActionsFunction Transitions 
  op SMINT : -> StateMachine .
  ***// ToDo: add entry/exit actions//
  eq SMINT = (allVerts allDefs allSHDefs allDHDefs (empty).EntryActions (empty).ExitActions allTrans) .

endfm

load model-checker
*** next we need getter functions for the SM
load «((String)(GLOBALVAR maudebasecode))»SMGETTER
load «((String)(GLOBALVAR maudebasecode))»VERTS .
load «((String)(GLOBALVAR maudebasecode))»ACTIONS .
load «((String)(GLOBALVAR maudebasecode))»UMLPRIORITY
load «((String)(GLOBALVAR maudebasecode))»COMPOUNDTRANSITIONS
load «((String)(GLOBALVAR maudebasecode))»STATEMACHINE
load «((String)(GLOBALVAR maudebasecode))»SEMANTICS
mod INIT is
	including SEMANTICS .
	including SATISFACTION .
	including LTL .
	including MODEL-CHECKER .
	including LTL-SIMPLIFIER .
	
	
	subsort MState < State .

	vars msst mastate : MState .
	vars V V2 : Verts .
	var E : EventSet .
	vars HC : HistoryConfs .
	vars VALUS : Valuations .
	
	subsort MState < State .
	
	op aCf : Actions -> Prop .
	op inC : Verts -> Prop .
    ceq maState (stableC<STATEC> V <HISTC> HC <VALUATIONS> VALUS <ENDCONF>) E |= inC(V2) = true if (V2 subset V)  .
	eq msst |= inC(V) = false [owise] .

	
	op isDone_ : MState -> Bool .
	eq isDone (maState (doneC<STATEC> V <HISTC> HC <VALUATIONS> VALUS <ENDCONF>) E) = true .
	eq isDone msst = false [owise] .
	
endm


load «((String)(GLOBALVAR maudebasecode))»QUEUESYNTAX
 mod QUEUESEMANTICS is 
 including eclipseInterface .
 including QUEUESIGNATURE .
     sort QueueStatus .
 var el : EventSet .
 var event : Event .
 var equeue : EventQueue .

 op <ready_ > : EventQueue -> QueueStatus .
 op <schedule__ > : EventQueue Event -> QueueStatus .
 op <initQueue> : -> QueueStatus .
  
 rl <ready (QUEUE event, el ENDQUEUE) > => <schedule (QUEUE el, event ENDQUEUE) event > .
 rl <schedule equeue event >  => <ready equeue > .
 rl <initQueue> => <ready emptyQueue > . 

endm

load «((String)(GLOBALVAR maudebasecode))»ACCS
load «((String)(GLOBALVAR maudebasecode))»BFAIRPOOL
load «((String)(GLOBALVAR maudebasecode))»BFPOOLANDSM
«REM»

***(
set break on .
break select finishedRTCESINT discardFSetESINT .
)***

***(
#####################################################
##          Interface     for     Eclipse          ##        
#####################################################
search (maState (stableC (State0-885791716,R-2027565592) empty) (d,a)) =>* mastate such that isDone mastate . 

bzw. wenn die ID-String bei dir anders sind 

search (maState (stableC (<Konfiguration>) <HistoryKonfiguration>) (<EventSet>)) =>* mastate such that isDone mastate . 


- <Konfiguration>: eine durch "," getrennte Menge von Regionen und States. Diese muss den Anforderungen im Standard entsprechen.
  z.B: Rroot, Csusp (aus Test.maude)
- <HistoryKonfiguration>: kann erstmal empty sein
- <EventSet>: eine durch "," getrennte Menge von Events die abgearbeitet werden soll




)***
«ENDREM»

	«ENDFILE»
«ENDDEFINE»


«REM» needed else branch - should not be taken but should not have any effect «ENDREM»
«DEFINE smLoadAll FOR PackageableElement»
«ENDDEFINE»
«DEFINE sm FOR PackageableElement»
«ENDDEFINE»
«DEFINE smVerts FOR PackageableElement»
«ENDDEFINE»
«DEFINE smEvents FOR PackageableElement»
«ENDDEFINE»
«DEFINE smActions FOR PackageableElement»
«ENDDEFINE»
«DEFINE smTransitions FOR PackageableElement»
«ENDDEFINE»
«DEFINE smStateMachine FOR PackageableElement»
«ENDDEFINE»
«DEFINE smInterface FOR PackageableElement»
«ENDDEFINE»

«REM» needed else branch - should not be taken but should not have any effect «ENDREM»
«DEFINE init FOR PackageableElement»
«ENDDEFINE»
