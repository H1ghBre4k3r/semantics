fmod VALUATION is 
    sort Valuation .
endfm

view Valuation from TRIV to VALUATION is
    sort Elt to Valuation .
endv

fmod VALUATIONS is
    including SET{Valuation} * (sort Set{Valuation} to Valuations, sort NeSet{Valuation} to NeValuations) .
	
	protecting STRING .
	protecting INT .
	
	sort Expression .
	sort VariableID .
	subsort VariableID < Expression .
	subsort Int < Expression .
	
	op vID_ : String -> VariableID .
	
	var variableID1 variableID2 : VariableID .
	var variableValue1 variableValue2 : Int . 
	var natVar : Valuation .
	var variables : Valuations . 
	var str : String .
	var varID1 varID2 : VariableID .
	var exp : Expression .
	
	op NatVar(_,_) : VariableID Int -> Valuation .
	
	op assign _ to _ in _ : Int VariableID Valuations -> Valuations .
	eq assign variableValue1 to variableID1 in (NatVar(variableID1 , variableValue2), variables) = (NatVar(variableID1 , variableValue1), variables) .
	    
    op _ + _ : Expression Expression -> Expression [ditto] .
    op _ - _ : Expression Expression -> Expression [ditto] .
    
    *** this definiton has to be here because it is used for the evaluation of actions and guards 
    op eval _ with _ : Expression Valuations -> Int .
    eq eval variableValue1 with variables = variableValue1 .
    eq eval varID1 with (NatVar(varID1 , variableValue1) , variables) = variableValue1 .
    eq eval varID1 + exp with (NatVar(varID1 , variableValue1), variables) = variableValue1 + (eval exp with (NatVar(varID1 , variableValue1), variables)) .
    eq eval varID1 - exp with (NatVar(varID1 , variableValue1), variables) = variableValue1 - (eval exp with (NatVar(varID1 , variableValue1), variables)) .

endfm
 
*** red NatVar(vID "a",0) .
*** red NatVar(vID "a",0), NatVar (vID "b",2)  .
*** red vID "a" .
*** red vID "a" + vID "b" .
*** red eval vID "a" with NatVar(vID "a",0) .
*** red eval vID "a" + (vID "b" + vID "c") with (NatVar(vID "a",0), NatVar (vID "b",2), NatVar (vID "c",6)) .
*** red eval vID "c" with (NatVar(vID "a",0), NatVar (vID "b",2), NatVar (vID "c",6)) .
*** red eval vID "b" with (NatVar(vID "a",0), NatVar (vID "b",2), NatVar (vID "c",6)) .
*** red eval vID "c" - vID "b" with (NatVar(vID "a",0), NatVar (vID "b",2), NatVar (vID "c",6)) .
*** red assign 17 to vID "a" in (NatVar(vID "a",0), NatVar (vID "b",2), NatVar (vID "c",6)) .
*** red assign eval vID "c" - vID "b" with (NatVar(vID "a",0), NatVar (vID "b",2), NatVar (vID "c",6)) to vID "a" in (NatVar(vID "a",0), NatVar (vID "b",2), NatVar (vID "c",6)) .

fmod ACTION is
    protecting VALUATIONS .
    sort Action .

    op _ := _ : VariableID Expression -> Action .
    op noac : -> Action .
    op absAct _ : String -> Action .
    

endfm

*** red vID "a" := 1 .
*** red noac .
*** red absAct "bla" .

view Action from TRIV to ACTION is
    sort Elt to Action .
endv


fmod ACTIONS is 
  including LIST{Action} * (sort List{Action} to Actions, sort NeList{Action} to NeActions) .

  
  vars actions1 actions2 actions3 : Actions .
  var action : Action .
  
  op seq_ : Actions -> Action .
  op par_ : Actions -> Action .
    
endfm

load /cygdrive/c/Users/Jens/phd-workspace/maude-Variables/VERTSSYNTAX

fmod GUARD is
  including VERTSSYNTAX .
  including VALUATIONS .
  
  
***  subsort Guard < Bool .
  sorts Guard .
  
  vars exp1 exp2 : Expression .
  vars agd bgd : Guard .
  
  op _>GD_ : Expression Expression -> Guard .
  op _<GD_ : Expression Expression -> Guard .
  eq exp1 <GD exp2 = exp2 >GD exp1 .
  op _==GD_ : Expression Expression -> Guard .
  eq exp1 ==GD exp2 = exp2 >GD exp1 andGD exp2 <GD exp1 .
       
  op trueGD : -> Guard [ctor] .
  op falseGD : -> Guard .
  eq falseGD = notGD trueGD . 

  op inStates_ : Verts -> Guard .
  op choiceelse : -> Guard .
  op notGD_ : Guard -> Guard . 
  op _andGD_ : Guard Guard -> Guard .
  op _orGD_ : Guard Guard -> Guard .
  eq agd orGD bgd = notGD ( (notGD agd) andGD (notGD bgd)) .
  op _=>GD_ : Guard Guard -> Guard .
  eq agd =>GD bgd = notGD agd orGD bgd .
endfm

***red vID "a" >GD (1).Int .
***red choiceelse .
***red vID "a" ==GD vID "b" .
***red (vID "a" ==GD vID "b") orGD vID "a" >GD (1).Int .


fmod EVALGUARD is
  including ACTION .
  including GUARD .
  including VERTSSYNTAX .
  
  
  var gd1 gd2 : Guard .
  var exp1 exp2 : Expression .
  var valuation : Valuations .
  var verts1 verts2 : Verts .
  
  op evalGD___ : Guard Verts Valuations -> Bool .
  eq evalGD inStates verts1 verts2 valuation = verts1 subset verts2 .
  eq evalGD notGD gd1 verts1 valuation = not evalGD gd1 verts1 valuation .
  eq evalGD gd1 andGD gd2 verts1 valuation = evalGD gd1 verts1 valuation and evalGD gd2 verts1 valuation .
  eq evalGD exp1 >GD exp2 verts1 valuation = (eval exp1 with valuation) > (eval exp2 with valuation) .  
endfm
   
***red evalGD vID "a" >GD (1).Int (empty).Verts NatVar(vID "a",0) .
***red evalGD vID "a" >GD (1).Int (empty).Verts NatVar(vID "a",0) .
***red evalGD inStates (root(R "0"), root(R "0"): C "1") (root(R "0"), root(R "0"): C "1", root(R "0"): C "2") NatVar(vID "a",0) .
***red evalGD vID "a" <GD (1).Int andGD inStates (root(R "0"), root(R "0"): C "1") (root(R "0"), root(R "0"): C "1", root(R "0"): C "2") NatVar(vID "a",0) .
