fmod VALUATION is 
    sort Valuation .
endfm

view Valuation from TRIV to VALUATION is
    sort Elt to Valuation .
endv

fmod VALUATIONS is
    including SET{Valuation} * (sort Set{Valuation} to Valuations, sort NeSet{Valuation} to NeValuations) .
	
	protecting STRING .
	protecting INT .
	
	sort Expression .
	sort VariableID .
	subsort VariableID < Expression .
	subsort Int < Expression .
	
	op vID_ : String -> VariableID .
	
	var variableID1 variableID2 : VariableID .
	var variableValue1 variableValue2 : Int . 
	var natVar : Valuation .
	var variables : Valuations . 
	var str : String .
	var varID1 varID2 : VariableID .
	var exp : Expression .
	
	op NatVar(_,_) : VariableID Int -> Valuation .
	
	op assign _ to _ in _ : Int VariableID Valuations -> Valuations .
	eq assign variableValue1 to variableID1 in (NatVar(variableID1 , variableValue2), variables) = (NatVar(variableID1 , variableValue1), variables) .
	    
    op _ + _ : Expression Expression -> Expression [ditto] .
    op _ - _ : Expression Expression -> Expression [ditto] .
    
    *** this definiton has to be here because it is used for the evaluation of actions and guards 
    op eval _ with _ : Expression Valuations -> Int .
    eq eval variableValue1 with variables = variableValue1 .
    eq eval varID1 with (NatVar(varID1 , variableValue1) , variables) = variableValue1 .
    eq eval varID1 + exp with (NatVar(varID1 , variableValue1), variables) = variableValue1 + (eval exp with (NatVar(varID1 , variableValue1), variables)) .
    eq eval varID1 - exp with (NatVar(varID1 , variableValue1), variables) = variableValue1 - (eval exp with (NatVar(varID1 , variableValue1), variables)) .

endfm
 
*** red NatVar(vID "a",0) .
*** red NatVar(vID "a",0), NatVar (vID "b",2)  .
*** red vID "a" .
*** red vID "a" + vID "b" .
*** red eval vID "a" with NatVar(vID "a",0) .
*** red eval vID "a" + (vID "b" + vID "c") with (NatVar(vID "a",0), NatVar (vID "b",2), NatVar (vID "c",6)) .
*** red eval vID "c" with (NatVar(vID "a",0), NatVar (vID "b",2), NatVar (vID "c",6)) .
*** red eval vID "b" with (NatVar(vID "a",0), NatVar (vID "b",2), NatVar (vID "c",6)) .
*** red eval vID "c" - vID "b" with (NatVar(vID "a",0), NatVar (vID "b",2), NatVar (vID "c",6)) .
*** red assign 17 to vID "a" in (NatVar(vID "a",0), NatVar (vID "b",2), NatVar (vID "c",6)) .
*** red assign eval vID "c" - vID "b" with (NatVar(vID "a",0), NatVar (vID "b",2), NatVar (vID "c",6)) to vID "a" in (NatVar(vID "a",0), NatVar (vID "b",2), NatVar (vID "c",6)) .




fmod ACTION is
    protecting VALUATIONS .
    sort Action .

	var vid : VariableID .
	vars exp1 : Expression .
	vars VALUS : Valuations .
	
    op assignAct _ := _ : VariableID Expression -> Action .
    op noac : -> Action .
    op absAct _ : String -> Action .
    
    op applyAct2Valuation__ : Action Valuations -> Valuations .
    eq applyAct2Valuation (assignAct vid := exp1) VALUS = assign (eval exp1 with VALUS) to vid in VALUS .
	
endfm
red vID "a" .
red (1).Expression .
red assignAct vID "a" := 1 .
*** red noac .
*** red absAct "bla" .

view Action from TRIV to ACTION is
    sort Elt to Action .
endv


fmod ACTIONSSYNTAX is 
  including LIST{Action} * (sort List{Action} to Actions, sort NeList{Action} to NeActions) .

  
  vars actions1 actions2 actions3 : Actions .
  var action : Action .
  
  op seq_ : Actions -> Action .
  op par_ : Actions -> Action .
    
endfm



***(






****************************************************************
*** ToDos in diesem File
*** - Kommentare
*** - gatherActions siehe unten
****************************************************************

fmod VALUATION is
  including INT .
  including STRING .
  sort Variable .
  sort VarID .
  op Var-_ : String -> VarID [ctor] .
  
  op (_->_) : VarID Int -> Valuation .
     
endfm

fmod ACTION is
  protecting STRING .
  sorts Action .
  
  *** op skip : -> Action [ctor] .
  op noac : -> Action .
  op ac:_ : String -> Action [ctor] .
endfm

view Action from TRIV to ACTION is
  sort Elt to Action . 
endv

view Valuation from TRIV to VALUATION is
  sort Elt to Valuation . 
endv


fmod ACTIONSSYNTAX is 
  including ACTION .
  including VALUATION .
  including LIST{Action} * (sort List{Action} to Actions, sort NeList{Action} to NeActions) .
  including SET{Valuation} * (sort Set{Valuation} to Valuations, sort NeSet{Valuation} to NeValuations) .
  
  op seq_ : Actions -> Action .
  op par_ : Actions -> Action .
  
  sort Expression .
  subsort VarID < Expression .
  subsort Int < Expression .
    
  vars int1 int2 : Int .
  vars exp1 exp2 : Expression .
  var varid : VarID .
  var variable : Valuation .
  var variables : Valuations .
  
  op _:=_ : VarID Expression -> Action . 
  
  op -_ : Expression -> Expression [ditto] .
  op _+_ : Expression Expression -> Expression 
  [assoc comm prec 33
         special (id-hook ACU_NumberOpSymbol (+)
                  op-hook succSymbol (s_ : Nat ~> NzNat)
                  op-hook minusSymbol (-_ : NzNat ~> Int))] .  
  op evalEXP__ : Expression Valuations -> Expression .
  eq evalEXP (exp1 + varid) ((varid -> int2), variables) = evalEXP (exp1 + int2) ((varid -> int2), variables) .  
  eq evalEXP int1 variables = int1 .  
  
  op evalAction__ : Action Valuations -> Valuations .
  eq evalAction (varid := exp1) ((varid -> int2), variables) = 
    (
    (varid -> (evalEXP exp1 ((varid -> int2), variables))), 
     variables) .
  
endfm
*** red (((Var- "y")-> 7), ((Var- "x")-> 9))  .
*** red (evalEXP (Var- "x" + Var- "y")  (((Var- "y")-> 7), ((Var- "x")-> 9)))  .
*** red (evalAction (Var- "x" := (Var- "x" + Var- "y"))  (((Var- "y")-> 7), ((Var- "x")-> 9)))  .

)***